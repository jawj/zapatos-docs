<!DOCTYPE html><html><head>
        <!-- tocbot -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.min.js"></script>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.css">
        <!-- highlighting -->
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/default.min.css">
        <!-- monaco editor -->
        <script src="monaco/vs/loader.js"></script>
        <script src="zapatos-bundle.js"></script>
        <!-- custom -->
        <link rel="stylesheet" href="https://use.typekit.net/mdb7zvi.css">
        <link rel="stylesheet" href="docs.css">
      </head>
      <body>
        <div id="toc"></div>
        <div id="content"><h1 id="zapatos-zero-abstraction">Zapatos: <em>Zero-Abstraction Postgres for TypeScript</em></h1>
<h2 id="what-does-it-do">What does it do?</h2>
<p><a href="https://www.postgresql.org/">Postgres</a> and <a href="https://www.typescriptlang.org/">TypeScript</a> are independently awesome. Zapatos is a library that aims to make them awesome together.</p>
<p>To achieve that, it does these five things:</p>
<ul>
<li>
<p><strong>Typescript schema</strong> &nbsp; A command-line tool speaks to your Postgres database and writes up a TypeScript schema of detailed types for every table. This enables the following three things. <a href="#typescript-schema">Show me »</a></p>
</li>
<li>
<p><strong>Arbitrary SQL</strong> &nbsp; Simple building blocks help you write arbitrary SQL using <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_templates">tagged templates</a>, and manually apply the right types to what goes in and what comes back. <a href="#arbitrary-sql">Show me »</a></p>
</li>
<li>
<p><strong>Everyday CRUD</strong> &nbsp; Shortcut functions produce everyday <a href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete">CRUD</a> queries with no fuss and no surprises, fully and automatically typed. <a href="#everyday-crud">Show me »</a></p>
</li>
<li>
<p><strong>JOINs as nested JSON</strong> &nbsp; Nested shortcut calls generate <a href="https://www.postgresql.org/docs/12/queries-table-expressions.html#id-1.5.6.6.5.10.2">LATERAL JOIN</a> queries, resulting in arbitrarily complex nested JSON structures, still fully and automatically typed. <a href="#joins-as-nested-json">Show me »</a></p>
</li>
<li>
<p><strong>Transactions</strong> &nbsp; A transaction function helps with managing and retrying transactions. <a href="#transaction">Show me »</a></p>
</li>
</ul>
<h3 id="why-does-it-do-that">Why does it do that?</h3>
<p>It is a truth universally acknowledged that <a href="https://en.wikipedia.org/wiki/Object-relational_impedance_mismatch">ORMs aren’t very good</a>.</p>
<p>I like SQL, and Postgres especially. In my experience, abstractions that obscure the underlying SQL, or that prioritise ease of switching to another database tomorrow over effective use of <em>this</em> database <em>today</em>, are a source of misery.</p>
<p>I’ve also come to love strongly typed languages, and TypeScript in particular. VS Code’s type checking and autocomplete speed development, prevent bugs, and simplify refactoring. Especially when they <em>just happen</em>, they bring joy.</p>
<p>Zapatos aims to minimise the misery of abstraction, intensify the joy of type inference, and represent a credible alternative to traditional ORMs.</p>
<h3 id="how-does-that-look">How does that look?</h3>
<h4 id="typescript-schema">Typescript schema</h4>
<p><strong>A command-line tool speaks to your Postgres database and writes up a TypeScript schema of detailed types for every table.</strong></p>
<p>Take this ultra-simple SQL schema for a single table, <code>authors</code>:</p>
<pre class="language-sql"><code><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">"authors"</span> 
( <span class="hljs-string">"id"</span> <span class="hljs-built_in">SERIAL</span> PRIMARY <span class="hljs-keyword">KEY</span>
, <span class="hljs-string">"name"</span> <span class="hljs-built_in">TEXT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>
, <span class="hljs-string">"isLiving"</span> <span class="hljs-built_in">BOOLEAN</span> );
</code></pre>
<p>We run <code>npx zapatos</code> to generate a file named <code>schema.ts</code>, including table definitions like this one:</p>
<pre class="language-typescript norun"><code><span class="hljs-keyword">export</span> <span class="hljs-keyword">namespace</span> authors {
  <span class="hljs-comment">/* ... */</span>
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> Selectable {
    id: <span class="hljs-built_in">number</span>;
    name: <span class="hljs-built_in">string</span>;
    isLiving: <span class="hljs-built_in">boolean</span> | <span class="hljs-literal">null</span>;
  };
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> Insertable {
    id?: <span class="hljs-built_in">number</span> | DefaultType | SQLFragment;
    name: <span class="hljs-built_in">string</span> | SQLFragment;
    isLiving?: <span class="hljs-built_in">boolean</span> | <span class="hljs-literal">null</span> | DefaultType | SQLFragment;
  };
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> Updatable <span class="hljs-keyword">extends</span> Partial&lt;Insertable&gt; { };
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> Whereable = { [K <span class="hljs-keyword">in</span> keyof Insertable]?: 
    Exclude&lt;Insertable[K] | ParentColumn, <span class="hljs-literal">null</span> | DefaultType&gt; };
  <span class="hljs-comment">/* ... */</span>
}
</code></pre>
<p>The types are, I hope, pretty self-explanatory. <code>authors.Selectable</code> is what I’ll get back from a <code>SELECT</code> query on this table. <code>authors.Insertable</code> is what I can <code>INSERT</code>: similar to the <code>Selectable</code>, but any fields that are <code>NULL</code>able and/or have <code>DEFAULT</code> values are allowed to be missing, <code>NULL</code> or <code>DEFAULT</code>. <code>authors.Updatable</code> is what I can <code>UPDATE</code> the table with: like what I can <code>INSERT</code>, but all columns are optional: it’s a simple <code>Partial&lt;authors.Insertable&gt;</code>. <code>authors.Whereable</code>, finally, is what I can use in a <code>WHERE</code> condition</p>
<p><code>schema.ts</code> includes a few other types that get used internally, including some handy type mappings, such as this one:</p>
<pre class="language-typescript norun"><code><span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> SelectableForTable&lt;T <span class="hljs-keyword">extends</span> Table&gt; = {
  authors: authors.Selectable,
  books: books.Selectable,
  tags: tags.Selectable,
  <span class="hljs-comment">/* ... */</span>
}[T];
</code></pre>
<p><a href="#detail1">Tell me more about the command line tool »</a></p>
<h4 id="arbitrary-sql">Arbitrary SQL</h4>
<p><strong>Simple building blocks help you write arbitrary SQL using <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_templates">tagged templates</a>, and manually apply the right types to what goes in and what comes back.</strong></p>
<p>Let’s insert something into that <code>authors</code> table for which we just generated the types. We’ll write the SQL query ourselves, to show how that works (though we’ll see an easier way <a href="#everyday-crud">in the next section</a>):</p>
<pre class="language-typescript runnable"><code><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> db <span class="hljs-keyword">from</span> <span class="hljs-string">'./zapatos/src'</span>;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> s <span class="hljs-keyword">from</span> <span class="hljs-string">'./zapatos/schema'</span>;
<span class="hljs-keyword">import</span> { pool } <span class="hljs-keyword">from</span> <span class="hljs-string">'./pgPool'</span>;

<span class="hljs-keyword">const</span>
  author: s.authors.Insertable = {
    name: <span class="hljs-string">'Gabriel Garcia Marquez'</span>,
    isLiving: <span class="hljs-literal">false</span>,
  },
  [insertedAuthor] = <span class="hljs-keyword">await</span> db.sql&lt;s.authors.SQL, s.authors.Selectable[]&gt;<span class="hljs-string">`
      INSERT INTO <span class="hljs-subst">${<span class="hljs-string">"authors"</span>}</span> (<span class="hljs-subst">${db.cols(author)}</span>)
      VALUES(<span class="hljs-subst">${db.vals(author)}</span>) RETURNING *`</span>
    .run(pool);
</code></pre><div class="sqlstuff">
<pre class="sqltext"><code><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">"authors"</span> (<span class="hljs-string">"isLiving"</span>, <span class="hljs-string">"name"</span>)<br>  <span class="hljs-keyword">VALUES</span> ($<span class="hljs-number">1</span>, $<span class="hljs-number">2</span>)<br><span class="hljs-keyword">RETURNING</span> *</code></pre>
<pre class="sqlvalues"><code>[<span class="hljs-literal">false</span>, <span class="hljs-string">"Gabriel Garcia Marquez"</span>]</code></pre>
<pre class="sqlresult"><code>[<br>  {<br>    <span class="hljs-attr">"id"</span>: <span class="hljs-number">307</span>,<br>    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Gabriel Garcia Marquez"</span>,<br>    <span class="hljs-attr">"isLiving"</span>: <span class="hljs-literal">false</span><br>  }<br>]</code></pre>
</div>
<p>We’ve applied the appropriate type to the object we’re trying to insert (<code>s.authors.Insertable</code>), giving us type-checking and autocompletion on that object. And we’ve specified both which types are allowed as interpolated values in the template string (<code>s.authors.SQL</code>) and what type is going to be returned (<code>s.authors.Selectable[]</code>)&nbsp;when the query runs.</p>
<p><em>You can click ‘Explore types’ above to open the code in an embedded Monaco (VS Code) editor, so you can check those typings for yourself.</em></p>
<p><a href="#detail2">Tell me more about writing arbitrary SQL »</a></p>
<h4 id="everyday-crud">Everyday CRUD</h4>
<p><strong>Shortcut functions produce everyday <a href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete">CRUD</a> queries with no fuss and no surprises, fully and automatically typed.</strong></p>
<p>So —&nbsp;writing SQL with Zapatos is nicer than constructing a query and all its input and output types from scratch. But for a totally bog-standard CRUD query like the <code>INSERT</code> above, it still involves quite a lot of boilerplate.</p>
<p>To eliminate the boilerplate, Zapatos supplies some simple functions to generate these sorts of queries, fully and automatically typed.</p>
<p>Let’s use one of them — <code>insert</code> — to add two more authors:</p>
<pre class="language-typescript runnable"><code><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> db <span class="hljs-keyword">from</span> <span class="hljs-string">'./zapatos/src'</span>;
<span class="hljs-keyword">import</span> { pool } <span class="hljs-keyword">from</span> <span class="hljs-string">'./pgPool'</span>;

<span class="hljs-keyword">const</span> [doug, janey] = <span class="hljs-keyword">await</span> db.insert(<span class="hljs-string">'authors'</span>, [
  { name: <span class="hljs-string">'Douglas Adams'</span>, isLiving: <span class="hljs-literal">false</span> },
  { name: <span class="hljs-string">'Jane Austen'</span>, isLiving: <span class="hljs-literal">false</span>},
]).run(pool);
</code></pre><div class="sqlstuff">
<pre class="sqltext"><code><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">"authors"</span> (<span class="hljs-string">"isLiving"</span>, <span class="hljs-string">"name"</span>)<br>  <span class="hljs-keyword">VALUES</span> ($<span class="hljs-number">1</span>, $<span class="hljs-number">2</span>), ($<span class="hljs-number">3</span>, $<span class="hljs-number">4</span>)<br><span class="hljs-keyword">RETURNING</span> to_jsonb (<span class="hljs-string">"authors"</span>.*) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">result</span></code></pre>
<pre class="sqlvalues"><code>[<span class="hljs-literal">false</span>, <span class="hljs-string">"Douglas Adams"</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">"Jane Austen"</span>]</code></pre>
<pre class="sqlresult"><code>[<br>  {<br>    <span class="hljs-attr">"id"</span>: <span class="hljs-number">308</span>,<br>    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Douglas Adams"</span>,<br>    <span class="hljs-attr">"isLiving"</span>: <span class="hljs-literal">false</span><br>  },<br>  {<br>    <span class="hljs-attr">"id"</span>: <span class="hljs-number">309</span>,<br>    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Jane Austen"</span>,<br>    <span class="hljs-attr">"isLiving"</span>: <span class="hljs-literal">false</span><br>  }<br>]</code></pre>
</div>
<p>The <code>insert</code> shortcut accepts a single <code>Insertable</code> or an <code>Insertable[]</code> array, and correspondingly returns a single <code>Selectable</code> or a <code>Selectable[]</code> array. Since we specified <code>'authors'</code> as the first argument here, and an array as the second, input and output will be checked and auto-completed as <code>authors.Insertable[]</code> and <code>authors.Selectable[]</code> respectively.</p>
<p><em>Again, click ‘Explore types’ to play around and check those typings.</em></p>
<p>In addition to <code>insert</code>, there are shortcuts for <code>select</code>, <code>selectOne</code> and <code>count</code>, and for <code>update</code>, <code>upsert</code>, <code>delete</code> and <code>truncate</code>.</p>
<p><a href="#detail2">Tell me more about the shortcut functions »</a></p>
<h4 id="joins-as-nested-json">JOINs as nested JSON</h4>
<p><strong>Nested shortcut calls generate <a href="https://www.postgresql.org/docs/12/queries-table-expressions.html#id-1.5.6.6.5.10.2">LATERAL JOIN</a> queries, resulting in arbitrarily complex nested JSON structures, still fully and automatically typed.</strong></p>
<p>CRUD is our bread and butter, but the power of SQL is that it’s <em>relational</em> — it’s in the <code>JOIN</code>s. And Postgres has some powerful JSON features that can deliver us sensibly-structured <code>JOIN</code> results without any post-processing (that’s <code>json_agg</code>, <code>json_build_object</code>, and so on).</p>
<p>To demonstrate, let’s say that <code>authors</code> have <code>books</code> and <code>books</code> have <code>tags</code>, adding two new tables to our simple schema:</p>
<pre class="language-sql"><code><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">"books"</span> 
( <span class="hljs-string">"id"</span> <span class="hljs-built_in">SERIAL</span> PRIMARY <span class="hljs-keyword">KEY</span>
, <span class="hljs-string">"authorId"</span> <span class="hljs-built_in">INTEGER</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">REFERENCES</span> <span class="hljs-string">"authors"</span>(<span class="hljs-string">"id"</span>)
, <span class="hljs-string">"title"</span> <span class="hljs-built_in">TEXT</span>
, <span class="hljs-string">"createdAt"</span> TIMESTAMPTZ <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">now</span>() );

<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">"tags"</span>
( <span class="hljs-string">"tag"</span> <span class="hljs-built_in">TEXT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>
, <span class="hljs-string">"bookId"</span> <span class="hljs-built_in">INTEGER</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">REFERENCES</span> <span class="hljs-string">"books"</span>(<span class="hljs-string">"id"</span>) );

<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">UNIQUE</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-string">"tagsUniqueIdx"</span> <span class="hljs-keyword">ON</span> <span class="hljs-string">"tags"</span>(<span class="hljs-string">"tag"</span>, <span class="hljs-string">"bookId"</span>);
</code></pre>
<p>Now, let’s say I want to show a list of books, each with its (one) author and (many) associated tags. We could knock up a manual query for this, of course, but it gets quite hairy. The <code>select</code> shortcut has an option called <code>lateral</code> that can nest other <code>select</code> queries and do it for us.</p>
<p>Let’s try it:</p>
<pre class="language-typescript runnable"><code><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> db <span class="hljs-keyword">from</span> <span class="hljs-string">'./zapatos/src'</span>;
<span class="hljs-keyword">import</span> { pool } <span class="hljs-keyword">from</span> <span class="hljs-string">'./pgPool'</span>;

<span class="hljs-keyword">const</span> bookAuthorTags = <span class="hljs-keyword">await</span> db.select(<span class="hljs-string">'books'</span>, db.all, {
  lateral: {
    author: db.selectOne(<span class="hljs-string">'authors'</span>, { id: db.parent(<span class="hljs-string">'authorId'</span>) }),
    tags: db.select(<span class="hljs-string">'tags'</span>, { bookId: db.parent(<span class="hljs-string">'id'</span>) }),
  }
}).run(pool);

bookAuthorTags.map(<span class="hljs-function"><span class="hljs-params">b</span> =&gt;</span> 
  <span class="hljs-string">`<span class="hljs-subst">${b.author!.name}</span>: <span class="hljs-subst">${b.title}</span> (<span class="hljs-subst">${b.tags.map(t =&gt; t.tag).join(<span class="hljs-string">', '</span>)}</span>)`</span>);
</code></pre><div class="sqlstuff">
<pre class="sqltext"><code><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">coalesce</span>(jsonb_agg(<span class="hljs-keyword">result</span>), <span class="hljs-string">'[]'</span>) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">result</span><br><span class="hljs-keyword">FROM</span> (<br>  <span class="hljs-keyword">SELECT</span> to_jsonb (<span class="hljs-string">"books"</span>.*) || jsonb_build_object(<span class="hljs-string">'author'</span>, <span class="hljs-string">"cj_author"</span>.result, <span class="hljs-string">'tags'</span>, <span class="hljs-string">"cj_tags"</span>.result) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">result</span><br>  <span class="hljs-keyword">FROM</span> <span class="hljs-string">"books"</span><br>  <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">LATERAL</span> (<br>    <span class="hljs-keyword">SELECT</span> to_jsonb (<span class="hljs-string">"authors"</span>.*) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">result</span><br>    <span class="hljs-keyword">FROM</span> <span class="hljs-string">"authors"</span><br>    <span class="hljs-keyword">WHERE</span> (<span class="hljs-string">"id"</span> = <span class="hljs-string">"books"</span>.<span class="hljs-string">"authorId"</span>)<br>  <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">1</span>) <span class="hljs-keyword">AS</span> <span class="hljs-string">"cj_author"</span> <span class="hljs-keyword">ON</span> <span class="hljs-literal">true</span><br>  <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">LATERAL</span> (<br>    <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">coalesce</span>(jsonb_agg(<span class="hljs-keyword">result</span>), <span class="hljs-string">'[]'</span>) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">result</span><br>    <span class="hljs-keyword">FROM</span> (<br>      <span class="hljs-keyword">SELECT</span> to_jsonb (<span class="hljs-string">"tags"</span>.*) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">result</span><br>      <span class="hljs-keyword">FROM</span> <span class="hljs-string">"tags"</span><br>      <span class="hljs-keyword">WHERE</span> (<span class="hljs-string">"bookId"</span> = <span class="hljs-string">"books"</span>.<span class="hljs-string">"id"</span>)) <span class="hljs-keyword">AS</span> <span class="hljs-string">"sq_tags"</span>) <span class="hljs-keyword">AS</span> <span class="hljs-string">"cj_tags"</span> <span class="hljs-keyword">ON</span> <span class="hljs-literal">true</span>) <span class="hljs-keyword">AS</span> <span class="hljs-string">"sq_books"</span></code></pre>
<pre class="sqlresult"><code>[<br>  {<br>    <span class="hljs-attr">"id"</span>: <span class="hljs-number">1005</span>,<br>    <span class="hljs-attr">"tags"</span>: [<br>      {<br>        <span class="hljs-attr">"tag"</span>: <span class="hljs-string">"19th century"</span>,<br>        <span class="hljs-attr">"bookId"</span>: <span class="hljs-number">1005</span><br>      },<br>      {<br>        <span class="hljs-attr">"tag"</span>: <span class="hljs-string">"Romance"</span>,<br>        <span class="hljs-attr">"bookId"</span>: <span class="hljs-number">1005</span><br>      }<br>    ],<br>    <span class="hljs-attr">"title"</span>: <span class="hljs-string">"Pride and Prejudice"</span>,<br>    <span class="hljs-attr">"author"</span>: {<br>      <span class="hljs-attr">"id"</span>: <span class="hljs-number">1</span>,<br>      <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Jane Austen"</span>,<br>      <span class="hljs-attr">"isLiving"</span>: <span class="hljs-literal">false</span><br>    },<br>    <span class="hljs-attr">"authorId"</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">"createdAt"</span>: <span class="hljs-string">"2020-04-21T20:26:18.793003+01:00"</span>,<br>    <span class="hljs-attr">"updatedAt"</span>: <span class="hljs-string">"2020-04-21T20:26:18.793003+01:00"</span><br>  },<br>  {<br>    <span class="hljs-attr">"id"</span>: <span class="hljs-number">1006</span>,<br>    <span class="hljs-attr">"tags"</span>: [<br>      {<br>        <span class="hljs-attr">"tag"</span>: <span class="hljs-string">"1980s"</span>,<br>        <span class="hljs-attr">"bookId"</span>: <span class="hljs-number">1006</span><br>      },<br>      {<br>        <span class="hljs-attr">"tag"</span>: <span class="hljs-string">"Lovesickness"</span>,<br>        <span class="hljs-attr">"bookId"</span>: <span class="hljs-number">1006</span><br>      }<br>    ],<br>    <span class="hljs-attr">"title"</span>: <span class="hljs-string">"Love in the Time of Cholera"</span>,<br>    <span class="hljs-attr">"author"</span>: {<br>      <span class="hljs-attr">"id"</span>: <span class="hljs-number">123</span>,<br>      <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Gabriel Garcia Marquez"</span>,<br>      <span class="hljs-attr">"isLiving"</span>: <span class="hljs-literal">false</span><br>    },<br>    <span class="hljs-attr">"authorId"</span>: <span class="hljs-number">123</span>,<br>    <span class="hljs-attr">"createdAt"</span>: <span class="hljs-string">"2020-04-21T20:26:18.793003+01:00"</span>,<br>    <span class="hljs-attr">"updatedAt"</span>: <span class="hljs-string">"2020-04-21T20:26:18.793003+01:00"</span><br>  },<br>  {<br>    <span class="hljs-attr">"id"</span>: <span class="hljs-number">1007</span>,<br>    <span class="hljs-attr">"tags"</span>: [],<br>    <span class="hljs-attr">"title"</span>: <span class="hljs-string">"One Hundred Years of Solitude"</span>,<br>    <span class="hljs-attr">"author"</span>: {<br>      <span class="hljs-attr">"id"</span>: <span class="hljs-number">123</span>,<br>      <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Gabriel Garcia Marquez"</span>,<br>      <span class="hljs-attr">"isLiving"</span>: <span class="hljs-literal">false</span><br>    },<br>    <span class="hljs-attr">"authorId"</span>: <span class="hljs-number">123</span>,<br>    <span class="hljs-attr">"createdAt"</span>: <span class="hljs-string">"2020-04-21T20:26:18.804031+01:00"</span>,<br>    <span class="hljs-attr">"updatedAt"</span>: <span class="hljs-string">"2020-04-21T20:26:18.804031+01:00"</span><br>  },<br>  {<br>    <span class="hljs-attr">"id"</span>: <span class="hljs-number">1008</span>,<br>    <span class="hljs-attr">"tags"</span>: [],<br>    <span class="hljs-attr">"title"</span>: <span class="hljs-string">"News of a Kidnapping"</span>,<br>    <span class="hljs-attr">"author"</span>: {<br>      <span class="hljs-attr">"id"</span>: <span class="hljs-number">123</span>,<br>      <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Gabriel Garcia Marquez"</span>,<br>      <span class="hljs-attr">"isLiving"</span>: <span class="hljs-literal">false</span><br>    },<br>    <span class="hljs-attr">"authorId"</span>: <span class="hljs-number">123</span>,<br>    <span class="hljs-attr">"createdAt"</span>: <span class="hljs-string">"2020-04-21T20:26:18.819739+01:00"</span>,<br>    <span class="hljs-attr">"updatedAt"</span>: <span class="hljs-string">"2020-04-21T20:26:18.819739+01:00"</span><br>  }<br>]</code></pre>
</div>
<p>This generates an efficient three-table <code>LATERAL JOIN</code> that returns a nested JSON structure directly from the database. Every nested element is again fully and automatically typed.</p>
<p><em>Once again, the code above is in a Monaco (VS Code) editor, so you can play with it and and check that.</em></p>
<p>We can of course extend this to deeper nesting (e.g. query each author, with their books, with their tags); to self-joins (of a table with itself, e.g. employees to their managers in the same <code>employees</code> table); and to joins on relationships other than foreign keys (e.g. joining the nearest <em>N</em> somethings using the PostGIS <code>&lt;-&gt;</code> distance operator).</p>
<p><a href="#detail2">Tell me more about nested select queries »</a></p>
<h4 id="transactions">Transactions</h4>
<p><strong>A transaction function helps with managing and retrying transactions.</strong></p>
<p>Transactions are where I’ve found traditional ORMs like TypeORM and Sequelize probably most footgun-prone. Zapatos is always explicit about what client or pool is running your query —&nbsp;hence the <code>pool</code> argument in all our examples so far.</p>
<p>Zapatos also offers a simple <code>transaction</code> helper function that handles issuing a <code>ROLLBACK</code> on error, releasing the database client in a <code>finally</code> clause (i.e. whether or not an error was thrown), and automatically retrying queries in case of serialization failures. It looks like this:</p>
<pre class="language-typescript noresult runnable"><code><span class="hljs-keyword">const</span> result = db.transaction(pool, db.Isolation.Serializable, <span class="hljs-keyword">async</span> txnClient =&gt; {
  <span class="hljs-comment">/* queries here use txnClient instead of pool */</span>
});
</code></pre>
<p>For example, take this <code>accounts</code> table:</p>
<pre class="language-sql"><code><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> accounts (
  <span class="hljs-keyword">id</span> <span class="hljs-built_in">SERIAL</span> PRIMARY <span class="hljs-keyword">KEY</span>,
  balance <span class="hljs-built_in">INTEGER</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> <span class="hljs-keyword">CHECK</span> (balance &gt; <span class="hljs-number">0</span>)
);
</code></pre>
<p>We can use the <code>transaction</code> helper like so:</p>
<pre class="language-typescript runnable"><code><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> db <span class="hljs-keyword">from</span> <span class="hljs-string">'./zapatos/src'</span>;
<span class="hljs-keyword">import</span> { pool } <span class="hljs-keyword">from</span> <span class="hljs-string">'./pgPool'</span>;

<span class="hljs-keyword">const</span> [accountA, accountB] = <span class="hljs-keyword">await</span> db.insert(<span class="hljs-string">'accounts'</span>, 
  [{ balance: <span class="hljs-number">50</span> }, { balance: <span class="hljs-number">50</span> }]).run(pool);

<span class="hljs-keyword">const</span> transferMoney = <span class="hljs-function">(<span class="hljs-params">sendingAccountId: <span class="hljs-built_in">number</span>, receivingAccountId: <span class="hljs-built_in">number</span>, amount: <span class="hljs-built_in">number</span></span>) =&gt;</span>
  db.transaction(pool, db.Isolation.Serializable, <span class="hljs-function"><span class="hljs-params">txnClient</span> =&gt;</span> <span class="hljs-built_in">Promise</span>.all([
    db.update(<span class="hljs-string">'accounts'</span>,
      { balance: db.sql&lt;db.SQL&gt;<span class="hljs-string">`<span class="hljs-subst">${db.self}</span> - <span class="hljs-subst">${db.param(amount)}</span>`</span> },
      { id: sendingAccountId }).run(txnClient),
    db.update(<span class="hljs-string">'accounts'</span>,
      { balance: db.sql&lt;db.SQL&gt;<span class="hljs-string">`<span class="hljs-subst">${db.self}</span> + <span class="hljs-subst">${db.param(amount)}</span>`</span> },
      { id: receivingAccountId }).run(txnClient),
  ]));

<span class="hljs-keyword">try</span> {
  <span class="hljs-keyword">const</span> [updatedAccountA, updatedAccountB] = <span class="hljs-keyword">await</span> transferMoney(accountA.id, accountB.id, <span class="hljs-number">60</span>);
} <span class="hljs-keyword">catch</span>(err) {
  <span class="hljs-built_in">console</span>.log(err.message, <span class="hljs-string">'/'</span>, err.detail);
}
</code></pre><div class="sqlstuff">
<pre class="sqltext"><code><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">"accounts"</span> (<span class="hljs-string">"balance"</span>)<br>  <span class="hljs-keyword">VALUES</span> ($<span class="hljs-number">1</span>), ($<span class="hljs-number">2</span>)<br><span class="hljs-keyword">RETURNING</span> to_jsonb (<span class="hljs-string">"accounts"</span>.*) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">result</span></code></pre>
<pre class="sqlvalues"><code>[<span class="hljs-number">50</span>, <span class="hljs-number">50</span>]</code></pre>
<pre class="sqlresult"><code>[<br>  {<br>    <span class="hljs-attr">"id"</span>: <span class="hljs-number">107</span>,<br>    <span class="hljs-attr">"balance"</span>: <span class="hljs-number">50</span><br>  },<br>  {<br>    <span class="hljs-attr">"id"</span>: <span class="hljs-number">108</span>,<br>    <span class="hljs-attr">"balance"</span>: <span class="hljs-number">50</span><br>  }<br>]</code></pre>
<pre class="sqltext"><code><span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span> <span class="hljs-keyword">ISOLATION</span> <span class="hljs-keyword">LEVEL</span> <span class="hljs-keyword">SERIALIZABLE</span></code></pre>
<pre class="sqltext"><code><span class="hljs-keyword">UPDATE</span><br>  <span class="hljs-string">"accounts"</span><br><span class="hljs-keyword">SET</span> (<span class="hljs-string">"balance"</span>) = <span class="hljs-keyword">ROW</span> (<span class="hljs-string">"balance"</span> - $<span class="hljs-number">1</span>)<br><span class="hljs-keyword">WHERE</span> (<span class="hljs-string">"id"</span> = $<span class="hljs-number">2</span>)<br><span class="hljs-keyword">RETURNING</span> to_jsonb (<span class="hljs-string">"accounts"</span>.*) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">result</span></code></pre>
<pre class="sqlvalues"><code>[<span class="hljs-number">60</span>, <span class="hljs-number">107</span>]</code></pre>
<pre class="sqltext"><code><span class="hljs-keyword">UPDATE</span><br>  <span class="hljs-string">"accounts"</span><br><span class="hljs-keyword">SET</span> (<span class="hljs-string">"balance"</span>) = <span class="hljs-keyword">ROW</span> (<span class="hljs-string">"balance"</span> + $<span class="hljs-number">1</span>)<br><span class="hljs-keyword">WHERE</span> (<span class="hljs-string">"id"</span> = $<span class="hljs-number">2</span>)<br><span class="hljs-keyword">RETURNING</span> to_jsonb (<span class="hljs-string">"accounts"</span>.*) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">result</span></code></pre>
<pre class="sqlvalues"><code>[<span class="hljs-number">60</span>, <span class="hljs-number">108</span>]</code></pre>
<pre class="sqltext"><code><span class="hljs-keyword">ROLLBACK</span></code></pre>
<pre class="console"><code>new row for relation "accounts" violates check constraint "accounts_balance_check" / Failing row contains (107, -10).</code></pre>
</div>
<p>Finally, it provides a set of hierarchical isolation types so that, for example, if you type a <code>txnClient</code> argument to a function as <code>TxnSatisfying.RepeatableRead</code>, you can call it with <code>Isolation.Serializable</code> or <code>Isolation.RepeatableRead</code> but not <code>Isolation.ReadCommitted</code>.</p>
<h3 id="what-doesnt-it-do">What doesn’t it do?</h3>
<p>Zapatos doesn’t handle schema migrations. Other tools can help you with this: check out <a href="https://github.com/amacneil/dbmate">dbmate</a>, for instance.</p>
<p>It doesn’t manage the <code>pg</code> connection pool for you, as some ORMs do — mainly because this is so trivially easy. For example, my <code>pgPool.ts</code> looks something like this:</p>
<pre class="language-typescript norun"><code><span class="hljs-keyword">import</span> pg <span class="hljs-keyword">from</span> <span class="hljs-string">'pg'</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> pool = <span class="hljs-keyword">new</span> pg.Pool({ connectionString: process.env.DATABASE_URL });
</code></pre>
<p>Finally, it won’t tell you how to structure your code. Zapatos doesn’t deal in the ‘model’ classes beloved of traditional ORMs, just (fully-typed) <a href="https://twitter.com/_ericelliott/status/831965087749533698?lang=en">POJOs</a>.</p>
<h2 id="how-do-i-use-it">How do I use it?</h2>
<p>Zapatos provides a command line tool, which is run like so:</p>
<pre><code>npx zapatos
</code></pre>
<p>This generates the TypeScript schema for your database in a folder named <code>zapatos/schema.ts</code>, and copies (or symlinks) the Zapatos source files into <code>zapatos/src</code>.</p>
<p><strong>You <em>must</em> import the Zapatos source files from this copied/symlinked <code>zapatos/src</code> directory, <em>not</em> <code>from 'zapatos'</code> in the usual way (which would find them in <code>node_modules</code>).</strong></p>
<p>That’s because the source files depend on themselves importing your custom-generated <code>schema.ts</code>, which they cannot do if they’re imported in the usual way.</p>
<p>Of course, before you can run <code>npx zapatos</code>, you need to install and configure it.</p>
<h3 id="installation">Installation</h3>
<p>Install it with <code>npm</code>:</p>
<pre><code>npm install --save-dev zapatos
</code></pre>
<p>If you are copying the source files, which is the recommended default, you can make the library a <code>devDependency</code> with <code>--save-dev</code> (conversely, if you are symlinking them, which is not recommended, you will need the library as a standard <code>dependency</code> with plain old <code>--save</code>).</p>
<h3 id="configuration">Configuration</h3>
<p>Add a top-level file <code>zapatosconfig.json</code> to your project. Here’s an example:</p>
<pre class="language-json"><code>{
  <span class="hljs-attr">"db"</span>: {
    <span class="hljs-attr">"connectionString"</span>: <span class="hljs-string">"postgresql://localhost/example_db"</span>
  },
  <span class="hljs-attr">"outDir"</span>: <span class="hljs-string">"./src"</span>,
  <span class="hljs-attr">"schemas"</span>: {
    <span class="hljs-attr">"public"</span>: {
      <span class="hljs-attr">"include"</span>: <span class="hljs-string">"*"</span>,
      <span class="hljs-attr">"exclude"</span>: [<span class="hljs-string">"excluded_table_1"</span>, <span class="hljs-string">"excluded_table_2"</span>]
    }
  }
}
</code></pre>
<p>This file has up to four top-level keys:</p>
<ul>
<li>
<p><code>"db"</code> gives Postgres connection details. You can provide <a href="https://node-postgres.com/features/connecting#Programmatic">anything that you’d pass</a> to <code>new pg.Pool(/* ... */)</code> here. This key is required.</p>
</li>
<li>
<p><code>"outDir"</code> defines where your <code>zapatos</code> folder will be created, relative to the project root. If not specified, it defaults to the project root, i.e. <code>"."</code>.</p>
</li>
<li>
<p><code>"srcMode"</code> can take the values <code>"copy"</code> (the default) or <code>"symlink"</code>, determining whether <code>zapatos/src</code> will be a copy of the folder <code>node_modules/zapatos/src</code> or just a symlink to it. The symlink option can cause enormous headaches with tools like <code>ts-node</code> and <code>ts-jest</code>, which refuse to compile anything inside <code>node_modules</code>, and is not recommended.</p>
</li>
<li>
<p><code>"schemas"</code> is an object that lets you define schemas and tables to include and exclude. Each key is a schema name, and each value is an object with keys <code>"include"</code> and <code>"exclude"</code>. Those keys can take the values <code>"*"</code> (for all tables in schema) or an array of table names. The <code>"exclude"</code> list takes precedence over the <code>"include"</code> list.</p>
<p>Note that schemas are not fully supported by Zapatos, since they are not included in the output types, but they will work by using Postgres’s search path if none of your table names is duplicated across different schemas.</p>
<p>If not specified, the default value for <code>"schemas"</code> includes all tables in the <code>public</code> schema, i.e.:</p>
<pre class="language-json"><code>"schemas": {
  "public": {
    "include": "*",
    "exclude: []
  }
}
</code></pre>
<p>One more example: if you use PostGIS, you’ll likely want to exclude its system tables:</p>
<pre class="language-json"><code>"schemas": {
  "public": {
    "include": "*",
    "exclude": [
      "geography_columns", 
      "geometry_columns", 
      "raster_columns", 
      "raster_overviews", 
      "spatial_ref_sys"
    ]
  }
}
</code></pre>
</li>
</ul>
<h4 id="environment-variables">Environment variables</h4>
<p>All values in <code>zapatosconfig.json</code> can have environment variables (node.js’s <code>process.env.SOMETHING</code>) interpolated via <a href="https://handlebarsjs.com/">handlebars</a>-style doubly-curly-brackets <code>{{variables}}</code>.</p>
<p>This is likely most useful for the database connection details. For example, on Heroku you’d probably configure your database as:</p>
<pre class="language-json"><code>"db": {
  "connectionString": "{{DATABASE_URL}}"
}
</code></pre>
<h2 id="full-documentation">Full documentation</h2>
<h3 id="sql-tagged-template-strings"><code>sql</code> tagged template strings</h3>
<p>Arbitrary queries are written using the tagged template function <code>sql</code>, which returns <a href="#sqlfragment"><code>SQLFragment</code></a> class instances.</p>
<p>The <code>sql</code> function is <a href="https://www.typescriptlang.org/docs/handbook/generics.html">generic</a>, having two type variables. For example:</p>
<pre class="language-typescript noresult runnable"><code><span class="hljs-keyword">const</span> authorQuery = db.sql&lt;s.authors.SQL, s.authors.Selectable[]&gt;<span class="hljs-string">`
  SELECT * FROM <span class="hljs-subst">${<span class="hljs-string">"authors"</span>}</span>`</span>;
</code></pre>
<p>The first type variable, <code>Interpolations</code>, defines allowable interpolation values. If we were joining the <code>authors</code> and <code>books</code> tables, say, then we could specify <code>s.authors.SQL | s.books.SQL</code> here.</p>
<p>The <code>Interpolations</code> type variable defaults to <code>db.SQL</code> if not specified. This is the union of all per-table <code>SQL</code> types, and thus allows all table and column names present in the database as string interpolations. However, TypeScript will infer a more specific type from the first interpolated value, so if you have multiple interpolated values of different types you need to specify a value explicitly (either <code>db.SQL</code> or something more precise).</p>
<p>The second type variable, <code>RunResult</code>, describes what will be returned if we call <code>run()</code> on the query (after any transformations performed in <a href="#runresulttransform"><code>runResultTransform()</code></a>), or if we embed it within the <a href="#extras"><code>extras</code></a> or <a href="#lateral"><code>lateral</code></a> query options. Its default value if not specified is <code>any[]</code>.</p>
<p>Take another example of these type variables:</p>
<pre class="language-typescript noresult runnable"><code><span class="hljs-keyword">const</span> [{ random }] = <span class="hljs-keyword">await</span> db.sql&lt;never, [{ random: <span class="hljs-built_in">number</span> }]&gt;<span class="hljs-string">`
  SELECT random()`</span>.run(pool);
</code></pre>
<p><code>Interpolations</code> is <code>never</code> because nothing needs to be interpolated in this query, and the <code>RunResult</code> type says that the query will return one row comprising one numeric column, named <code>random</code>. The <code>random</code> TypeScript variable we initialize will of course be typed as a <code>number</code>.</p>
<p>If you’re happy to have your types tied down a little less tightly, it’s also fine to wholly omit the type variables in this query, falling back on their defaults:</p>
<pre class="language-typescript noresult runnable"><code><span class="hljs-keyword">const</span> [{ random }] = <span class="hljs-keyword">await</span> db.sql<span class="hljs-string">`SELECT random()`</span>.run(pool);
</code></pre>
<p>In this case, the <code>random</code> variable is of course still a <code>number</code>, but it is typed as <code>any</code>.</p>
<h3 id="sqlfragment"><code>SQLFragment</code></h3>
<p><code>SQLFragment&lt;RunResult&gt;</code> class instances are returned by the <code>sql</code> tagged template function (you’re unlikely ever to contruct them directly with <code>new</code>). They take on the <code>RunResult</code> type variable from the <code>sql</code>  function.</p>
<p>You can <a href="#other-sql-template-strings">interpolate them</a> in other <code>sql</code> tagged template strings, or call/access the following properties on them:</p>
<h4 id="async-runqueryable-queryable"><code>async run(queryable: Queryable): Promise&lt;RunResult&gt;</code></h4>
<p>The <code>run</code> function compiles, executes, and returns the transformed result of the query represented by this <code>SQLFragment</code>. The <code>awaited</code> return value is typed according to the <code>SQLFragment</code>'s <code>RunResult</code> type variable.</p>
<p>Taking that one step at a a time:</p>
<ol>
<li>
<p>First, the <code>compile</code> function is called, recursively compiling this <code>SQLFragment</code> and its interpolated values into a <code>{ text: '', values: [] }</code> query that can be passed straight to the <code>pg</code> module. If a <code>queryListener</code> function <a href="#run-time-configuration">has been configured</a>, it is called with the query as its argument now.</p>
</li>
<li>
<p>Next, the compiled SQL query is executed against the supplied <code>Queryable</code>, which is defined as either a <code>pg.Pool</code> instance or a subtype of <code>pg.PoolClient</code> (<code>TxnClient</code>) as provided by the <a href="#transactions"><code>transaction</code> helper function</a>.</p>
</li>
<li>
<p>Finally, the result returned from <code>pg</code> is fed through this <code>SQLFragment</code>'s <a href="#runresulttransform"><code>runResultTransform()</code></a> function, whose default implementation simply returns the <code>rows</code> property of the result. If a <code>resultListener</code> function <a href="#run-time-configuration">has been configured</a>, it is called with the transformed result as its argument now.</p>
</li>
</ol>
<p>Examples of the <code>run</code> function are scattered throughout this documentation.</p>
<h4 id="compile-sqlquery"><code>compile(): SQLQuery</code></h4>
<p>The <code>compile</code> function recursively transforms this <code>SQLFragment</code> and its interpolated values into a <code>SQLQuery</code> object (<code>{ text: string; values: any[]; }</code>) that can be passed straight to the <code>pg</code> module. It is called without arguments (the arguments it can take are for internal use).</p>
<p>For example:</p>
<pre class="language-typescript runnable"><code><span class="hljs-keyword">const</span> 
  authorId = <span class="hljs-number">12</span>,  <span class="hljs-comment">// from some untrusted source</span>
  query = db.sql&lt;s.books.SQL, s.books.Selectable[]&gt;<span class="hljs-string">`
    SELECT * FROM <span class="hljs-subst">${<span class="hljs-string">"books"</span>}</span> WHERE <span class="hljs-subst">${{authorId}</span>}`</span>,
  compiled = query.compile();

<span class="hljs-built_in">console</span>.log(compiled);
</code></pre><div class="sqlstuff">
<pre class="console"><code>{
  text: '\n    SELECT * FROM "books" WHERE ("authorId" = $1)',
  values: [ 12 ]
}</code></pre>
</div>
<p>You may never need this function. Use it if and when you want to see the SQL that would be executed by the <code>run</code> function, without in fact executing it.</p>
<h4 id="runresulttransform-qr"><code>runResultTransform: (qr: pg.QueryResult) =&gt; any</code></h4>
<p>When you call <code>run</code>, the function stored in this property is applied to the result object returned by <code>pg</code>, in order to produce the result that’s then returned by the function.</p>
<p>By default, the <code>rows</code> property (an array) is returned: the default implementation is just <code>qr =&gt; qr.rows</code>. However, the <a href="#shortcut-functions-and-lateral">shortcut functions</a> supply their own <code>runResultTransform</code> implementations in order to match their declared <code>RunResult</code> types.</p>
<p>Generally you will not need to call this function directly, but there may be cases where you want to assign a new function to replace the default implementation.</p>
<p>For example, imagine we wanted to create a function returning a query that, when run, returns the current database timestamp directly as a <code>Date</code>. We could do so like this:</p>
<pre class="language-typescript runnable"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dbNowQuery</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> query = db.sql&lt;never, <span class="hljs-built_in">Date</span>&gt;<span class="hljs-string">`SELECT now()`</span>;
  query.runResultTransform = <span class="hljs-function"><span class="hljs-params">qr</span> =&gt;</span> qr.rows[<span class="hljs-number">0</span>].now;
  <span class="hljs-keyword">return</span> query;
}

<span class="hljs-keyword">const</span> dbNow = <span class="hljs-keyword">await</span> dbNowQuery().run(pool);
<span class="hljs-comment">// dbNow is a Date: the result shown below has come via JSON.stringify</span>
</code></pre><div class="sqlstuff">
<pre class="sqltext"><code><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">now</span>()</code></pre>
<pre class="sqlresult"><code><span class="hljs-string">"2020-04-22T16:23:28.063Z"</span></code></pre>
</div>
<p>Note that the <code>RunResult</code> type variable on the <code>sql</code> template function (in this case, <code>Date</code>) reflects the type of the <em>transformed</em> result, not what comes straight back from <code>pg</code> (which in this case is roughly <code>{ rows: [{ now: Date }] }</code>).</p>
<p>If a <code>SQLFragment</code> does not have <code>run</code> called on it directly —&nbsp;for example, if it is instead interpolated into another <code>SQLFragment</code>, or given as the value of the <code>lateral</code> option to the <code>select</code> shortcut — then the <code>runResultTransform</code> function is never applied.</p>
<h3 id="sql-template-interpolation-types"><code>sql</code> template interpolation types</h3>
<h4 id="strings"><code>String</code>s</h4>
<p>The strings that can be directly interpolated into a <code>sql</code> template string are defined by its <code>Interpolations</code> type variable, <a href="#sql-tagged-template-strings">as noted above</a>. Typically, this will limit them to the names of tables and columns.</p>
<p>Interpolated strings are passed through double-quoted but otherwise unchanged. It’s preferable to use interpolated string literals rather than just including the strings in the query itself, in order to benefit from auto-completion and (ongoing) type-checking.</p>
<p>So, for example, write —</p>
<pre class="language-typescript noresult runnable"><code><span class="hljs-keyword">const</span> title = <span class="hljs-keyword">await</span> db.sql<span class="hljs-string">`
  SELECT <span class="hljs-subst">${<span class="hljs-string">"title"</span>}</span> FROM <span class="hljs-subst">${<span class="hljs-string">"books"</span>}</span> LIMIT 1`</span>.run(pool);
</code></pre>
<p>— rather than —</p>
<pre class="language-typescript noresult runnable"><code><span class="hljs-keyword">const</span> title = <span class="hljs-keyword">await</span> db.sql<span class="hljs-string">`
  SELECT "title" FROM "books" LIMIT 1`</span>.run(pool);  <span class="hljs-comment">// no, don't do this!</span>
</code></pre>
<p>—&nbsp;even though they produce identical results right now.</p>
<h4 id="arrays"><code>Array</code>s</h4>
<h4 id="other-sql-template-strings">Other <code>sql</code> template strings</h4>
<h4 id="cols-columnnames-and-vals"><code>cols</code> (<code>ColumnNames</code>) and <code>vals</code> (<code>ColumnValues</code>)</h4>
<h4 id="whereable"><code>Whereable</code></h4>
<h4 id="self"><code>self</code></h4>
<h4 id="param-parameter"><code>param</code> (<code>Parameter</code>)</h4>
<h4 id="default"><code>default</code></h4>
<h4 id="parentcolumnname-parentcolumn"><code>parent('columnName')</code> (<code>ParentColumn</code>)</h4>
<h3 id="shortcut-functions-and-lateral">Shortcut functions and lateral joins</h3>
<h4 id="insert">insert</h4>
<h4 id="update">update</h4>
<h4 id="upsert">upsert</h4>
<h4 id="delete">delete</h4>
<h4 id="truncate">truncate</h4>
<h4 id="select">select</h4>
<h5>extras</h5>
<h5>lateral</h5>
<h4 id="selectone">selectOne</h4>
<h4 id="count">count</h4>
<h3 id="transactions-1">Transactions</h3>
<h3 id="run-time-configuration">Run-time configuration</h3>
<h2 id="licence">Licence</h2>
<!--
What's happening here? First, we've applied the appropriate type to the object we're trying to insert: namely, `s.authors.Insertable`. This will give us type-checking and autocompletion on that object. 

Then we've used our [tagged template function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals), `db.sql`, to put together the query. We've specified both which types are allowed as interpolated values in the template string (`s.authors.SQL`) and what type is going to be returned (`s.authors.Selectable[]`) when the query runs.

Within the query, we've interpolated the table name, `${"authors"}`. Only the `authors` table and its column names are allowed as interpolated strings with `s.authors.SQL` specified, so it's hard to get that wrong. And we've used two helper functions, `db.cols` and `db.vals`, which split our `Insertable` into matching-ordered column names and (`$1`, `$2`, ... parameterized) values.

Finally, we've run the query using a specific `pg` client or pool, and accessed the newly inserted record's serial `id` value.
-->
<!--
Let's try one more raw SQL query, and search for the record we just inserted:

```typescript
import * as db from './zapatos/src';
import * as s from './zapatos/schema';
import { pool } from './pgPool';

const 
  searchPattern = '%marquez%',  // could be untrusted 
  [firstFoundAuthor] = await db.sql<s.authors.SQL, s.authors.Selectable[]>`
    SELECT * FROM ${"authors"} WHERE ${{
      isLiving: false,
      name: db.sql<db.SQL>`${db.self} ILIKE ${db.param(searchPattern)}`,
    }}`
  .run(pool);

console.log(firstFoundAuthor?.name);
```

Much of this is familiar. What's new is the object we've interpolated in our `WHERE` clause, an `s.authors.Wherable` that compiles to the conjunction of the given conditions. 

You'll notice that a `Whereable` can take either primitive values, which are simply tested for equality, or a `SQLFragment` (the return type of `db.sql`), in which case we can do whatever we want, using the symbol `db.self` to refer to the keyed column name.
-->
</div>
        <script src="docs.js"></script>
      
    
  </body></html>