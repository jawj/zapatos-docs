const zapatosBundle = {"custom/PgGeometry.d.ts":"/*\n** Please edit this file as needed **\nIt's been generated by Zapatos as a custom type definition placeholder, and won't be overwritten\n*/\n\ndeclare module 'zapatos/custom' {\n  export type PgGeometry = any;  // replace with your custom type or interface as desired\n}\n","custom/index.d.ts":"/*\n** DON'T EDIT THIS FILE **\nIt's been generated by Zapatos, and is liable to be overwritten\n\nZapatos: https://jawj.github.io/zapatos/\nCopyright (C) 2020 - 2023 George MacKerron\nReleased under the MIT licence: see LICENCE file\n*/\n\n// this empty declaration appears to fix relative imports in other custom type files\ndeclare module 'zapatos/custom' { }\n","schema.d.ts":"/*\n** DON'T EDIT THIS FILE **\nIt's been generated by Zapatos, and is liable to be overwritten\n\nZapatos: https://jawj.github.io/zapatos/\nCopyright (C) 2020 - 2023 George MacKerron\nReleased under the MIT licence: see LICENCE file\n*/\n\ndeclare module 'zapatos/schema' {\n\n  import type * as db from 'zapatos/db';\n  import type * as c from 'zapatos/custom';\n\n  // got a type error on schemaVersionCanary below? update by running `npx zapatos`\n  export interface schemaVersionCanary extends db.SchemaVersionCanary { version: 104 }\n\n\n  /* === schema: public === */\n\n  /* --- enums --- */\n\n  export type appleEnvironment = 'PROD' | 'Sandbox';\n  export namespace every {\n    export type appleEnvironment = ['PROD', 'Sandbox'];\n  }\n\n  /* --- tables --- */\n\n  /**\n   * **appleTransactions**\n   * - Table in database\n   */\n  export namespace appleTransactions {\n    export type Table = 'appleTransactions';\n    export interface Selectable {\n      /**\n      * **appleTransactions.environment**\n      * - `appleEnvironment` in database\n      * - `NOT NULL`, no default\n      */\n      environment: appleEnvironment;\n      /**\n      * **appleTransactions.originalTransactionId**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      originalTransactionId: string;\n      /**\n      * **appleTransactions.accountId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      accountId: number;\n      /**\n      * **appleTransactions.latestReceiptData**\n      * - `text` in database\n      * - Nullable, no default\n      */\n      latestReceiptData: string | null;\n    }\n    export interface JSONSelectable {\n      /**\n      * **appleTransactions.environment**\n      * - `appleEnvironment` in database\n      * - `NOT NULL`, no default\n      */\n      environment: appleEnvironment;\n      /**\n      * **appleTransactions.originalTransactionId**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      originalTransactionId: string;\n      /**\n      * **appleTransactions.accountId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      accountId: number;\n      /**\n      * **appleTransactions.latestReceiptData**\n      * - `text` in database\n      * - Nullable, no default\n      */\n      latestReceiptData: string | null;\n    }\n    export interface Whereable {\n      /**\n      * **appleTransactions.environment**\n      * - `appleEnvironment` in database\n      * - `NOT NULL`, no default\n      */\n      environment?: appleEnvironment | db.Parameter<appleEnvironment> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, appleEnvironment | db.Parameter<appleEnvironment> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **appleTransactions.originalTransactionId**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      originalTransactionId?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **appleTransactions.accountId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      accountId?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **appleTransactions.latestReceiptData**\n      * - `text` in database\n      * - Nullable, no default\n      */\n      latestReceiptData?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **appleTransactions.environment**\n      * - `appleEnvironment` in database\n      * - `NOT NULL`, no default\n      */\n      environment: appleEnvironment | db.Parameter<appleEnvironment> | db.SQLFragment;\n      /**\n      * **appleTransactions.originalTransactionId**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      originalTransactionId: string | db.Parameter<string> | db.SQLFragment;\n      /**\n      * **appleTransactions.accountId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      accountId: number | db.Parameter<number> | db.SQLFragment;\n      /**\n      * **appleTransactions.latestReceiptData**\n      * - `text` in database\n      * - Nullable, no default\n      */\n      latestReceiptData?: string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **appleTransactions.environment**\n      * - `appleEnvironment` in database\n      * - `NOT NULL`, no default\n      */\n      environment?: appleEnvironment | db.Parameter<appleEnvironment> | db.SQLFragment | db.SQLFragment<any, appleEnvironment | db.Parameter<appleEnvironment> | db.SQLFragment>;\n      /**\n      * **appleTransactions.originalTransactionId**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      originalTransactionId?: string | db.Parameter<string> | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment>;\n      /**\n      * **appleTransactions.accountId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      accountId?: number | db.Parameter<number> | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment>;\n      /**\n      * **appleTransactions.latestReceiptData**\n      * - `text` in database\n      * - Nullable, no default\n      */\n      latestReceiptData?: string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment>;\n    }\n    export type UniqueIndex = 'appleTransactionsPrimaryKey';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = Table | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Whereable | Column | db.ParentColumn | db.GenericSQLExpression;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  /**\n   * **arrays**\n   * - Table in database\n   */\n  export namespace arrays {\n    export type Table = 'arrays';\n    export interface Selectable {\n      /**\n      * **arrays.jsonValue**\n      * - `jsonb` in database\n      * - Nullable, no default\n      */\n      jsonValue: db.JSONValue | null;\n      /**\n      * **arrays.textArray**\n      * - `_text` in database\n      * - Nullable, no default\n      */\n      textArray: string[] | null;\n    }\n    export interface JSONSelectable {\n      /**\n      * **arrays.jsonValue**\n      * - `jsonb` in database\n      * - Nullable, no default\n      */\n      jsonValue: db.JSONValue | null;\n      /**\n      * **arrays.textArray**\n      * - `_text` in database\n      * - Nullable, no default\n      */\n      textArray: string[] | null;\n    }\n    export interface Whereable {\n      /**\n      * **arrays.jsonValue**\n      * - `jsonb` in database\n      * - Nullable, no default\n      */\n      jsonValue?: db.JSONValue | db.Parameter<db.JSONValue> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, db.JSONValue | db.Parameter<db.JSONValue> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **arrays.textArray**\n      * - `_text` in database\n      * - Nullable, no default\n      */\n      textArray?: string[] | db.Parameter<string[]> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string[] | db.Parameter<string[]> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **arrays.jsonValue**\n      * - `jsonb` in database\n      * - Nullable, no default\n      */\n      jsonValue?: db.JSONValue | db.Parameter<db.JSONValue> | null | db.DefaultType | db.SQLFragment;\n      /**\n      * **arrays.textArray**\n      * - `_text` in database\n      * - Nullable, no default\n      */\n      textArray?: string[] | db.Parameter<string[]> | null | db.DefaultType | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **arrays.jsonValue**\n      * - `jsonb` in database\n      * - Nullable, no default\n      */\n      jsonValue?: db.JSONValue | db.Parameter<db.JSONValue> | null | db.DefaultType | db.SQLFragment | db.SQLFragment<any, db.JSONValue | db.Parameter<db.JSONValue> | null | db.DefaultType | db.SQLFragment>;\n      /**\n      * **arrays.textArray**\n      * - `_text` in database\n      * - Nullable, no default\n      */\n      textArray?: string[] | db.Parameter<string[]> | null | db.DefaultType | db.SQLFragment | db.SQLFragment<any, string[] | db.Parameter<string[]> | null | db.DefaultType | db.SQLFragment>;\n    }\n    export type UniqueIndex = never;\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = Table | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Whereable | Column | db.ParentColumn | db.GenericSQLExpression;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  /**\n   * **authors**\n   * - Table in database\n   */\n  export namespace authors {\n    export type Table = 'authors';\n    export interface Selectable {\n      /**\n      * **authors.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('authors_id_seq'::regclass)`\n      */\n      id: number;\n      /**\n      * **authors.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name: string;\n      /**\n      * **authors.isLiving**\n      * - `bool` in database\n      * - Nullable, no default\n      */\n      isLiving: boolean | null;\n    }\n    export interface JSONSelectable {\n      /**\n      * **authors.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('authors_id_seq'::regclass)`\n      */\n      id: number;\n      /**\n      * **authors.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name: string;\n      /**\n      * **authors.isLiving**\n      * - `bool` in database\n      * - Nullable, no default\n      */\n      isLiving: boolean | null;\n    }\n    export interface Whereable {\n      /**\n      * **authors.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('authors_id_seq'::regclass)`\n      */\n      id?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **authors.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **authors.isLiving**\n      * - `bool` in database\n      * - Nullable, no default\n      */\n      isLiving?: boolean | db.Parameter<boolean> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, boolean | db.Parameter<boolean> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **authors.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('authors_id_seq'::regclass)`\n      */\n      id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;\n      /**\n      * **authors.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name: string | db.Parameter<string> | db.SQLFragment;\n      /**\n      * **authors.isLiving**\n      * - `bool` in database\n      * - Nullable, no default\n      */\n      isLiving?: boolean | db.Parameter<boolean> | null | db.DefaultType | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **authors.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('authors_id_seq'::regclass)`\n      */\n      id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.DefaultType | db.SQLFragment>;\n      /**\n      * **authors.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name?: string | db.Parameter<string> | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment>;\n      /**\n      * **authors.isLiving**\n      * - `bool` in database\n      * - Nullable, no default\n      */\n      isLiving?: boolean | db.Parameter<boolean> | null | db.DefaultType | db.SQLFragment | db.SQLFragment<any, boolean | db.Parameter<boolean> | null | db.DefaultType | db.SQLFragment>;\n    }\n    export type UniqueIndex = 'authors_pkey';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = Table | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Whereable | Column | db.ParentColumn | db.GenericSQLExpression;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  /**\n   * **bankAccounts**\n   * - Table in database\n   */\n  export namespace bankAccounts {\n    export type Table = 'bankAccounts';\n    export interface Selectable {\n      /**\n      * **bankAccounts.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('\"bankAccounts_id_seq\"'::regclass)`\n      */\n      id: number;\n      /**\n      * **bankAccounts.balance**\n      * - `int4` in database\n      * - `NOT NULL`, default: `0`\n      */\n      balance: number;\n    }\n    export interface JSONSelectable {\n      /**\n      * **bankAccounts.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('\"bankAccounts_id_seq\"'::regclass)`\n      */\n      id: number;\n      /**\n      * **bankAccounts.balance**\n      * - `int4` in database\n      * - `NOT NULL`, default: `0`\n      */\n      balance: number;\n    }\n    export interface Whereable {\n      /**\n      * **bankAccounts.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('\"bankAccounts_id_seq\"'::regclass)`\n      */\n      id?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **bankAccounts.balance**\n      * - `int4` in database\n      * - `NOT NULL`, default: `0`\n      */\n      balance?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **bankAccounts.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('\"bankAccounts_id_seq\"'::regclass)`\n      */\n      id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;\n      /**\n      * **bankAccounts.balance**\n      * - `int4` in database\n      * - `NOT NULL`, default: `0`\n      */\n      balance?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **bankAccounts.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('\"bankAccounts_id_seq\"'::regclass)`\n      */\n      id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.DefaultType | db.SQLFragment>;\n      /**\n      * **bankAccounts.balance**\n      * - `int4` in database\n      * - `NOT NULL`, default: `0`\n      */\n      balance?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.DefaultType | db.SQLFragment>;\n    }\n    export type UniqueIndex = 'bankAccounts_pkey';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = Table | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Whereable | Column | db.ParentColumn | db.GenericSQLExpression;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  /**\n   * **bigints**\n   * - Table in database\n   */\n  export namespace bigints {\n    export type Table = 'bigints';\n    export interface Selectable {\n      /**\n      * **bigints.bigintValue**\n      * - `int8` in database\n      * - `NOT NULL`, no default\n      */\n      bigintValue: db.Int8String;\n    }\n    export interface JSONSelectable {\n      /**\n      * **bigints.bigintValue**\n      * - `int8` in database\n      * - `NOT NULL`, no default\n      */\n      bigintValue: (number | db.Int8String);\n    }\n    export interface Whereable {\n      /**\n      * **bigints.bigintValue**\n      * - `int8` in database\n      * - `NOT NULL`, no default\n      */\n      bigintValue?: (number | db.Int8String) | db.Parameter<(number | db.Int8String)> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, (number | db.Int8String) | db.Parameter<(number | db.Int8String)> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **bigints.bigintValue**\n      * - `int8` in database\n      * - `NOT NULL`, no default\n      */\n      bigintValue: (number | db.Int8String) | db.Parameter<(number | db.Int8String)> | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **bigints.bigintValue**\n      * - `int8` in database\n      * - `NOT NULL`, no default\n      */\n      bigintValue?: (number | db.Int8String) | db.Parameter<(number | db.Int8String)> | db.SQLFragment | db.SQLFragment<any, (number | db.Int8String) | db.Parameter<(number | db.Int8String)> | db.SQLFragment>;\n    }\n    export type UniqueIndex = never;\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = Table | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Whereable | Column | db.ParentColumn | db.GenericSQLExpression;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  /**\n   * **books**\n   * - Table in database\n   */\n  export namespace books {\n    export type Table = 'books';\n    export interface Selectable {\n      /**\n      * **books.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('books_id_seq'::regclass)`\n      */\n      id: number;\n      /**\n      * **books.authorId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      authorId: number;\n      /**\n      * **books.title**\n      * - `text` in database\n      * - Nullable, no default\n      */\n      title: string | null;\n      /**\n      * **books.createdAt**\n      * - `timestamptz` in database\n      * - `NOT NULL`, default: `now()`\n      */\n      createdAt: Date;\n    }\n    export interface JSONSelectable {\n      /**\n      * **books.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('books_id_seq'::regclass)`\n      */\n      id: number;\n      /**\n      * **books.authorId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      authorId: number;\n      /**\n      * **books.title**\n      * - `text` in database\n      * - Nullable, no default\n      */\n      title: string | null;\n      /**\n      * **books.createdAt**\n      * - `timestamptz` in database\n      * - `NOT NULL`, default: `now()`\n      */\n      createdAt: db.TimestampTzString;\n    }\n    export interface Whereable {\n      /**\n      * **books.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('books_id_seq'::regclass)`\n      */\n      id?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **books.authorId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      authorId?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **books.title**\n      * - `text` in database\n      * - Nullable, no default\n      */\n      title?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **books.createdAt**\n      * - `timestamptz` in database\n      * - `NOT NULL`, default: `now()`\n      */\n      createdAt?: (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **books.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('books_id_seq'::regclass)`\n      */\n      id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;\n      /**\n      * **books.authorId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      authorId: number | db.Parameter<number> | db.SQLFragment;\n      /**\n      * **books.title**\n      * - `text` in database\n      * - Nullable, no default\n      */\n      title?: string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment;\n      /**\n      * **books.createdAt**\n      * - `timestamptz` in database\n      * - `NOT NULL`, default: `now()`\n      */\n      createdAt?: (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | db.DefaultType | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **books.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('books_id_seq'::regclass)`\n      */\n      id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.DefaultType | db.SQLFragment>;\n      /**\n      * **books.authorId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      authorId?: number | db.Parameter<number> | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment>;\n      /**\n      * **books.title**\n      * - `text` in database\n      * - Nullable, no default\n      */\n      title?: string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment>;\n      /**\n      * **books.createdAt**\n      * - `timestamptz` in database\n      * - `NOT NULL`, default: `now()`\n      */\n      createdAt?: (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | db.DefaultType | db.SQLFragment>;\n    }\n    export type UniqueIndex = 'books_pkey';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = Table | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Whereable | Column | db.ParentColumn | db.GenericSQLExpression;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  /**\n   * **doctors**\n   * - Table in database\n   */\n  export namespace doctors {\n    export type Table = 'doctors';\n    export interface Selectable {\n      /**\n      * **doctors.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('doctors_id_seq'::regclass)`\n      */\n      id: number;\n      /**\n      * **doctors.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name: string;\n    }\n    export interface JSONSelectable {\n      /**\n      * **doctors.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('doctors_id_seq'::regclass)`\n      */\n      id: number;\n      /**\n      * **doctors.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name: string;\n    }\n    export interface Whereable {\n      /**\n      * **doctors.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('doctors_id_seq'::regclass)`\n      */\n      id?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **doctors.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **doctors.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('doctors_id_seq'::regclass)`\n      */\n      id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;\n      /**\n      * **doctors.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name: string | db.Parameter<string> | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **doctors.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('doctors_id_seq'::regclass)`\n      */\n      id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.DefaultType | db.SQLFragment>;\n      /**\n      * **doctors.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name?: string | db.Parameter<string> | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment>;\n    }\n    export type UniqueIndex = 'doctors_pkey';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = Table | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Whereable | Column | db.ParentColumn | db.GenericSQLExpression;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  /**\n   * **emailAuthentication**\n   * - Table in database\n   */\n  export namespace emailAuthentication {\n    export type Table = 'emailAuthentication';\n    export interface Selectable {\n      /**\n      * **emailAuthentication.email**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      email: string;\n      /**\n      * **emailAuthentication.consecutiveFailedLogins**\n      * - `int4` in database\n      * - `NOT NULL`, default: `0`\n      */\n      consecutiveFailedLogins: number;\n      /**\n      * **emailAuthentication.lastFailedLogin**\n      * - `timestamptz` in database\n      * - Nullable, no default\n      */\n      lastFailedLogin: Date | null;\n    }\n    export interface JSONSelectable {\n      /**\n      * **emailAuthentication.email**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      email: string;\n      /**\n      * **emailAuthentication.consecutiveFailedLogins**\n      * - `int4` in database\n      * - `NOT NULL`, default: `0`\n      */\n      consecutiveFailedLogins: number;\n      /**\n      * **emailAuthentication.lastFailedLogin**\n      * - `timestamptz` in database\n      * - Nullable, no default\n      */\n      lastFailedLogin: db.TimestampTzString | null;\n    }\n    export interface Whereable {\n      /**\n      * **emailAuthentication.email**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      email?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **emailAuthentication.consecutiveFailedLogins**\n      * - `int4` in database\n      * - `NOT NULL`, default: `0`\n      */\n      consecutiveFailedLogins?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **emailAuthentication.lastFailedLogin**\n      * - `timestamptz` in database\n      * - Nullable, no default\n      */\n      lastFailedLogin?: (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **emailAuthentication.email**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      email: string | db.Parameter<string> | db.SQLFragment;\n      /**\n      * **emailAuthentication.consecutiveFailedLogins**\n      * - `int4` in database\n      * - `NOT NULL`, default: `0`\n      */\n      consecutiveFailedLogins?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;\n      /**\n      * **emailAuthentication.lastFailedLogin**\n      * - `timestamptz` in database\n      * - Nullable, no default\n      */\n      lastFailedLogin?: (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | null | db.DefaultType | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **emailAuthentication.email**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      email?: string | db.Parameter<string> | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment>;\n      /**\n      * **emailAuthentication.consecutiveFailedLogins**\n      * - `int4` in database\n      * - `NOT NULL`, default: `0`\n      */\n      consecutiveFailedLogins?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.DefaultType | db.SQLFragment>;\n      /**\n      * **emailAuthentication.lastFailedLogin**\n      * - `timestamptz` in database\n      * - Nullable, no default\n      */\n      lastFailedLogin?: (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | null | db.DefaultType | db.SQLFragment | db.SQLFragment<any, (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | null | db.DefaultType | db.SQLFragment>;\n    }\n    export type UniqueIndex = 'emailAuthentication_pkey';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = Table | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Whereable | Column | db.ParentColumn | db.GenericSQLExpression;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  /**\n   * **employees**\n   * - Table in database\n   */\n  export namespace employees {\n    export type Table = 'employees';\n    export interface Selectable {\n      /**\n      * **employees.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('employees_id_seq'::regclass)`\n      */\n      id: number;\n      /**\n      * **employees.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name: string;\n      /**\n      * **employees.managerId**\n      * - `int4` in database\n      * - Nullable, no default\n      */\n      managerId: number | null;\n    }\n    export interface JSONSelectable {\n      /**\n      * **employees.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('employees_id_seq'::regclass)`\n      */\n      id: number;\n      /**\n      * **employees.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name: string;\n      /**\n      * **employees.managerId**\n      * - `int4` in database\n      * - Nullable, no default\n      */\n      managerId: number | null;\n    }\n    export interface Whereable {\n      /**\n      * **employees.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('employees_id_seq'::regclass)`\n      */\n      id?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **employees.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **employees.managerId**\n      * - `int4` in database\n      * - Nullable, no default\n      */\n      managerId?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **employees.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('employees_id_seq'::regclass)`\n      */\n      id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;\n      /**\n      * **employees.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name: string | db.Parameter<string> | db.SQLFragment;\n      /**\n      * **employees.managerId**\n      * - `int4` in database\n      * - Nullable, no default\n      */\n      managerId?: number | db.Parameter<number> | null | db.DefaultType | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **employees.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('employees_id_seq'::regclass)`\n      */\n      id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.DefaultType | db.SQLFragment>;\n      /**\n      * **employees.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name?: string | db.Parameter<string> | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment>;\n      /**\n      * **employees.managerId**\n      * - `int4` in database\n      * - Nullable, no default\n      */\n      managerId?: number | db.Parameter<number> | null | db.DefaultType | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | null | db.DefaultType | db.SQLFragment>;\n    }\n    export type UniqueIndex = 'employees_pkey';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = Table | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Whereable | Column | db.ParentColumn | db.GenericSQLExpression;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  /**\n   * **nameCounts**\n   * - Table in database\n   */\n  export namespace nameCounts {\n    export type Table = 'nameCounts';\n    export interface Selectable {\n      /**\n      * **nameCounts.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name: string;\n      /**\n      * **nameCounts.count**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      count: number;\n    }\n    export interface JSONSelectable {\n      /**\n      * **nameCounts.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name: string;\n      /**\n      * **nameCounts.count**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      count: number;\n    }\n    export interface Whereable {\n      /**\n      * **nameCounts.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **nameCounts.count**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      count?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **nameCounts.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name: string | db.Parameter<string> | db.SQLFragment;\n      /**\n      * **nameCounts.count**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      count: number | db.Parameter<number> | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **nameCounts.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name?: string | db.Parameter<string> | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment>;\n      /**\n      * **nameCounts.count**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      count?: number | db.Parameter<number> | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment>;\n    }\n    export type UniqueIndex = 'nameCounts_pkey';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = Table | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Whereable | Column | db.ParentColumn | db.GenericSQLExpression;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  /**\n   * **numerics**\n   * - Table in database\n   */\n  export namespace numerics {\n    export type Table = 'numerics';\n    export interface Selectable {\n      /**\n      * **numerics.numericValue**\n      * - `numeric` in database\n      * - `NOT NULL`, no default\n      */\n      numericValue: db.NumericString;\n    }\n    export interface JSONSelectable {\n      /**\n      * **numerics.numericValue**\n      * - `numeric` in database\n      * - `NOT NULL`, no default\n      */\n      numericValue: (number | db.NumericString);\n    }\n    export interface Whereable {\n      /**\n      * **numerics.numericValue**\n      * - `numeric` in database\n      * - `NOT NULL`, no default\n      */\n      numericValue?: (number | db.NumericString) | db.Parameter<(number | db.NumericString)> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, (number | db.NumericString) | db.Parameter<(number | db.NumericString)> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **numerics.numericValue**\n      * - `numeric` in database\n      * - `NOT NULL`, no default\n      */\n      numericValue: (number | db.NumericString) | db.Parameter<(number | db.NumericString)> | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **numerics.numericValue**\n      * - `numeric` in database\n      * - `NOT NULL`, no default\n      */\n      numericValue?: (number | db.NumericString) | db.Parameter<(number | db.NumericString)> | db.SQLFragment | db.SQLFragment<any, (number | db.NumericString) | db.Parameter<(number | db.NumericString)> | db.SQLFragment>;\n    }\n    export type UniqueIndex = never;\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = Table | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Whereable | Column | db.ParentColumn | db.GenericSQLExpression;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  /**\n   * **photos**\n   * - Table in database\n   */\n  export namespace photos {\n    export type Table = 'photos';\n    export interface Selectable {\n      /**\n      * **photos.photoId**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n      photoId: number;\n      /**\n      * **photos.url**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      url: string;\n    }\n    export interface JSONSelectable {\n      /**\n      * **photos.photoId**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n      photoId: number;\n      /**\n      * **photos.url**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      url: string;\n    }\n    export interface Whereable {\n      /**\n      * **photos.photoId**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n      photoId?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **photos.url**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      url?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **photos.photoId**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n      photoId?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;\n      /**\n      * **photos.url**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      url: string | db.Parameter<string> | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **photos.photoId**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n      photoId?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.DefaultType | db.SQLFragment>;\n      /**\n      * **photos.url**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      url?: string | db.Parameter<string> | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment>;\n    }\n    export type UniqueIndex = 'photos_pkey';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = Table | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Whereable | Column | db.ParentColumn | db.GenericSQLExpression;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  /**\n   * **shifts**\n   * - Table in database\n   */\n  export namespace shifts {\n    export type Table = 'shifts';\n    export interface Selectable {\n      /**\n      * **shifts.day**\n      * - `date` in database\n      * - `NOT NULL`, no default\n      */\n      day: Date;\n      /**\n      * **shifts.doctorId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      doctorId: number;\n    }\n    export interface JSONSelectable {\n      /**\n      * **shifts.day**\n      * - `date` in database\n      * - `NOT NULL`, no default\n      */\n      day: db.DateString;\n      /**\n      * **shifts.doctorId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      doctorId: number;\n    }\n    export interface Whereable {\n      /**\n      * **shifts.day**\n      * - `date` in database\n      * - `NOT NULL`, no default\n      */\n      day?: (db.DateString | Date) | db.Parameter<(db.DateString | Date)> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, (db.DateString | Date) | db.Parameter<(db.DateString | Date)> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **shifts.doctorId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      doctorId?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **shifts.day**\n      * - `date` in database\n      * - `NOT NULL`, no default\n      */\n      day: (db.DateString | Date) | db.Parameter<(db.DateString | Date)> | db.SQLFragment;\n      /**\n      * **shifts.doctorId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      doctorId: number | db.Parameter<number> | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **shifts.day**\n      * - `date` in database\n      * - `NOT NULL`, no default\n      */\n      day?: (db.DateString | Date) | db.Parameter<(db.DateString | Date)> | db.SQLFragment | db.SQLFragment<any, (db.DateString | Date) | db.Parameter<(db.DateString | Date)> | db.SQLFragment>;\n      /**\n      * **shifts.doctorId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      doctorId?: number | db.Parameter<number> | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment>;\n    }\n    export type UniqueIndex = 'shifts_pkey';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = Table | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Whereable | Column | db.ParentColumn | db.GenericSQLExpression;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  /**\n   * **stores**\n   * - Table in database\n   */\n  export namespace stores {\n    export type Table = 'stores';\n    export interface Selectable {\n      /**\n      * **stores.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('stores_id_seq'::regclass)`\n      */\n      id: number;\n      /**\n      * **stores.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name: string;\n      /**\n      * **stores.geom**\n      * - `geometry` in database\n      * - `NOT NULL`, no default\n      */\n      geom: c.PgGeometry;\n    }\n    export interface JSONSelectable {\n      /**\n      * **stores.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('stores_id_seq'::regclass)`\n      */\n      id: number;\n      /**\n      * **stores.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name: string;\n      /**\n      * **stores.geom**\n      * - `geometry` in database\n      * - `NOT NULL`, no default\n      */\n      geom: c.PgGeometry;\n    }\n    export interface Whereable {\n      /**\n      * **stores.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('stores_id_seq'::regclass)`\n      */\n      id?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **stores.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **stores.geom**\n      * - `geometry` in database\n      * - `NOT NULL`, no default\n      */\n      geom?: c.PgGeometry | db.Parameter<c.PgGeometry> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, c.PgGeometry | db.Parameter<c.PgGeometry> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **stores.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('stores_id_seq'::regclass)`\n      */\n      id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;\n      /**\n      * **stores.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name: string | db.Parameter<string> | db.SQLFragment;\n      /**\n      * **stores.geom**\n      * - `geometry` in database\n      * - `NOT NULL`, no default\n      */\n      geom: c.PgGeometry | db.Parameter<c.PgGeometry> | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **stores.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('stores_id_seq'::regclass)`\n      */\n      id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.DefaultType | db.SQLFragment>;\n      /**\n      * **stores.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name?: string | db.Parameter<string> | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment>;\n      /**\n      * **stores.geom**\n      * - `geometry` in database\n      * - `NOT NULL`, no default\n      */\n      geom?: c.PgGeometry | db.Parameter<c.PgGeometry> | db.SQLFragment | db.SQLFragment<any, c.PgGeometry | db.Parameter<c.PgGeometry> | db.SQLFragment>;\n    }\n    export type UniqueIndex = 'stores_pkey';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = Table | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Whereable | Column | db.ParentColumn | db.GenericSQLExpression;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  /**\n   * **subjectPhotos**\n   * - Table in database\n   */\n  export namespace subjectPhotos {\n    export type Table = 'subjectPhotos';\n    export interface Selectable {\n      /**\n      * **subjectPhotos.subjectId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      subjectId: number;\n      /**\n      * **subjectPhotos.photoId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      photoId: number;\n    }\n    export interface JSONSelectable {\n      /**\n      * **subjectPhotos.subjectId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      subjectId: number;\n      /**\n      * **subjectPhotos.photoId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      photoId: number;\n    }\n    export interface Whereable {\n      /**\n      * **subjectPhotos.subjectId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      subjectId?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **subjectPhotos.photoId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      photoId?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **subjectPhotos.subjectId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      subjectId: number | db.Parameter<number> | db.SQLFragment;\n      /**\n      * **subjectPhotos.photoId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      photoId: number | db.Parameter<number> | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **subjectPhotos.subjectId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      subjectId?: number | db.Parameter<number> | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment>;\n      /**\n      * **subjectPhotos.photoId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      photoId?: number | db.Parameter<number> | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment>;\n    }\n    export type UniqueIndex = 'userphotosunique';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = Table | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Whereable | Column | db.ParentColumn | db.GenericSQLExpression;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  /**\n   * **subjects**\n   * - Table in database\n   */\n  export namespace subjects {\n    export type Table = 'subjects';\n    export interface Selectable {\n      /**\n      * **subjects.subjectId**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n      subjectId: number;\n      /**\n      * **subjects.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name: string;\n    }\n    export interface JSONSelectable {\n      /**\n      * **subjects.subjectId**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n      subjectId: number;\n      /**\n      * **subjects.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name: string;\n    }\n    export interface Whereable {\n      /**\n      * **subjects.subjectId**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n      subjectId?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **subjects.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **subjects.subjectId**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n      subjectId?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;\n      /**\n      * **subjects.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name: string | db.Parameter<string> | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **subjects.subjectId**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n      subjectId?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.DefaultType | db.SQLFragment>;\n      /**\n      * **subjects.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name?: string | db.Parameter<string> | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment>;\n    }\n    export type UniqueIndex = 'subjects_pkey';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = Table | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Whereable | Column | db.ParentColumn | db.GenericSQLExpression;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  /**\n   * **tags**\n   * - Table in database\n   */\n  export namespace tags {\n    export type Table = 'tags';\n    export interface Selectable {\n      /**\n      * **tags.tag**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      tag: string;\n      /**\n      * **tags.bookId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      bookId: number;\n    }\n    export interface JSONSelectable {\n      /**\n      * **tags.tag**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      tag: string;\n      /**\n      * **tags.bookId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      bookId: number;\n    }\n    export interface Whereable {\n      /**\n      * **tags.tag**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      tag?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **tags.bookId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      bookId?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **tags.tag**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      tag: string | db.Parameter<string> | db.SQLFragment;\n      /**\n      * **tags.bookId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      bookId: number | db.Parameter<number> | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **tags.tag**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      tag?: string | db.Parameter<string> | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment>;\n      /**\n      * **tags.bookId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      bookId?: number | db.Parameter<number> | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment>;\n    }\n    export type UniqueIndex = 'tagsUniqueIdx';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = Table | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Whereable | Column | db.ParentColumn | db.GenericSQLExpression;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  /**\n   * **usedVoucherCodes**\n   * - Table in database\n   */\n  export namespace usedVoucherCodes {\n    export type Table = 'usedVoucherCodes';\n    export interface Selectable {\n      /**\n      * **usedVoucherCodes.code**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      code: string;\n      /**\n      * **usedVoucherCodes.redeemedAt**\n      * - `timestamptz` in database\n      * - `NOT NULL`, default: `now()`\n      */\n      redeemedAt: Date;\n    }\n    export interface JSONSelectable {\n      /**\n      * **usedVoucherCodes.code**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      code: string;\n      /**\n      * **usedVoucherCodes.redeemedAt**\n      * - `timestamptz` in database\n      * - `NOT NULL`, default: `now()`\n      */\n      redeemedAt: db.TimestampTzString;\n    }\n    export interface Whereable {\n      /**\n      * **usedVoucherCodes.code**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      code?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **usedVoucherCodes.redeemedAt**\n      * - `timestamptz` in database\n      * - `NOT NULL`, default: `now()`\n      */\n      redeemedAt?: (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **usedVoucherCodes.code**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      code: string | db.Parameter<string> | db.SQLFragment;\n      /**\n      * **usedVoucherCodes.redeemedAt**\n      * - `timestamptz` in database\n      * - `NOT NULL`, default: `now()`\n      */\n      redeemedAt?: (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | db.DefaultType | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **usedVoucherCodes.code**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      code?: string | db.Parameter<string> | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment>;\n      /**\n      * **usedVoucherCodes.redeemedAt**\n      * - `timestamptz` in database\n      * - `NOT NULL`, default: `now()`\n      */\n      redeemedAt?: (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | db.DefaultType | db.SQLFragment>;\n    }\n    export type UniqueIndex = 'usedVoucherCodes_pkey';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = Table | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Whereable | Column | db.ParentColumn | db.GenericSQLExpression;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  /**\n   * **users**\n   * - Table in database\n   */\n  export namespace users {\n    export type Table = 'users';\n    export interface Selectable {\n      /**\n      * **users.id**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n      id: number;\n      /**\n      * **users.ipOctet**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n      ipOctet: number;\n      /**\n      * **users.friendlyName**\n      * - `text` in database\n      * - Nullable, no default\n      */\n      friendlyName: string | null;\n    }\n    export interface JSONSelectable {\n      /**\n      * **users.id**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n      id: number;\n      /**\n      * **users.ipOctet**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n      ipOctet: number;\n      /**\n      * **users.friendlyName**\n      * - `text` in database\n      * - Nullable, no default\n      */\n      friendlyName: string | null;\n    }\n    export interface Whereable {\n      /**\n      * **users.id**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n      id?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **users.ipOctet**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n      ipOctet?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **users.friendlyName**\n      * - `text` in database\n      * - Nullable, no default\n      */\n      friendlyName?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **users.id**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n      id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;\n      /**\n      * **users.ipOctet**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n      ipOctet?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;\n      /**\n      * **users.friendlyName**\n      * - `text` in database\n      * - Nullable, no default\n      */\n      friendlyName?: string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **users.id**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n      id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.DefaultType | db.SQLFragment>;\n      /**\n      * **users.ipOctet**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n      ipOctet?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.DefaultType | db.SQLFragment>;\n      /**\n      * **users.friendlyName**\n      * - `text` in database\n      * - Nullable, no default\n      */\n      friendlyName?: string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment>;\n    }\n    export type UniqueIndex = 'users_ipOctet_key' | 'users_pkey';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = Table | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Whereable | Column | db.ParentColumn | db.GenericSQLExpression;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  /* --- aggregate types --- */\n\n  export namespace public {  \n    export type Table = appleTransactions.Table | arrays.Table | authors.Table | bankAccounts.Table | bigints.Table | books.Table | doctors.Table | emailAuthentication.Table | employees.Table | nameCounts.Table | numerics.Table | photos.Table | shifts.Table | stores.Table | subjectPhotos.Table | subjects.Table | tags.Table | usedVoucherCodes.Table | users.Table;\n    export type Selectable = appleTransactions.Selectable | arrays.Selectable | authors.Selectable | bankAccounts.Selectable | bigints.Selectable | books.Selectable | doctors.Selectable | emailAuthentication.Selectable | employees.Selectable | nameCounts.Selectable | numerics.Selectable | photos.Selectable | shifts.Selectable | stores.Selectable | subjectPhotos.Selectable | subjects.Selectable | tags.Selectable | usedVoucherCodes.Selectable | users.Selectable;\n    export type JSONSelectable = appleTransactions.JSONSelectable | arrays.JSONSelectable | authors.JSONSelectable | bankAccounts.JSONSelectable | bigints.JSONSelectable | books.JSONSelectable | doctors.JSONSelectable | emailAuthentication.JSONSelectable | employees.JSONSelectable | nameCounts.JSONSelectable | numerics.JSONSelectable | photos.JSONSelectable | shifts.JSONSelectable | stores.JSONSelectable | subjectPhotos.JSONSelectable | subjects.JSONSelectable | tags.JSONSelectable | usedVoucherCodes.JSONSelectable | users.JSONSelectable;\n    export type Whereable = appleTransactions.Whereable | arrays.Whereable | authors.Whereable | bankAccounts.Whereable | bigints.Whereable | books.Whereable | doctors.Whereable | emailAuthentication.Whereable | employees.Whereable | nameCounts.Whereable | numerics.Whereable | photos.Whereable | shifts.Whereable | stores.Whereable | subjectPhotos.Whereable | subjects.Whereable | tags.Whereable | usedVoucherCodes.Whereable | users.Whereable;\n    export type Insertable = appleTransactions.Insertable | arrays.Insertable | authors.Insertable | bankAccounts.Insertable | bigints.Insertable | books.Insertable | doctors.Insertable | emailAuthentication.Insertable | employees.Insertable | nameCounts.Insertable | numerics.Insertable | photos.Insertable | shifts.Insertable | stores.Insertable | subjectPhotos.Insertable | subjects.Insertable | tags.Insertable | usedVoucherCodes.Insertable | users.Insertable;\n    export type Updatable = appleTransactions.Updatable | arrays.Updatable | authors.Updatable | bankAccounts.Updatable | bigints.Updatable | books.Updatable | doctors.Updatable | emailAuthentication.Updatable | employees.Updatable | nameCounts.Updatable | numerics.Updatable | photos.Updatable | shifts.Updatable | stores.Updatable | subjectPhotos.Updatable | subjects.Updatable | tags.Updatable | usedVoucherCodes.Updatable | users.Updatable;\n    export type UniqueIndex = appleTransactions.UniqueIndex | arrays.UniqueIndex | authors.UniqueIndex | bankAccounts.UniqueIndex | bigints.UniqueIndex | books.UniqueIndex | doctors.UniqueIndex | emailAuthentication.UniqueIndex | employees.UniqueIndex | nameCounts.UniqueIndex | numerics.UniqueIndex | photos.UniqueIndex | shifts.UniqueIndex | stores.UniqueIndex | subjectPhotos.UniqueIndex | subjects.UniqueIndex | tags.UniqueIndex | usedVoucherCodes.UniqueIndex | users.UniqueIndex;\n    export type Column = appleTransactions.Column | arrays.Column | authors.Column | bankAccounts.Column | bigints.Column | books.Column | doctors.Column | emailAuthentication.Column | employees.Column | nameCounts.Column | numerics.Column | photos.Column | shifts.Column | stores.Column | subjectPhotos.Column | subjects.Column | tags.Column | usedVoucherCodes.Column | users.Column;\n  \n    export type AllBaseTables = [appleTransactions.Table, arrays.Table, authors.Table, bankAccounts.Table, bigints.Table, books.Table, doctors.Table, emailAuthentication.Table, employees.Table, nameCounts.Table, numerics.Table, photos.Table, shifts.Table, stores.Table, subjectPhotos.Table, subjects.Table, tags.Table, usedVoucherCodes.Table, users.Table];\n    export type AllForeignTables = [];\n    export type AllViews = [];\n    export type AllMaterializedViews = [];\n    export type AllTablesAndViews = [appleTransactions.Table, arrays.Table, authors.Table, bankAccounts.Table, bigints.Table, books.Table, doctors.Table, emailAuthentication.Table, employees.Table, nameCounts.Table, numerics.Table, photos.Table, shifts.Table, stores.Table, subjectPhotos.Table, subjects.Table, tags.Table, usedVoucherCodes.Table, users.Table];\n  }\n\n\n\n  /* === global aggregate types === */\n\n  export type Schema = 'public';\n  export type Table = public.Table;\n  export type Selectable = public.Selectable;\n  export type JSONSelectable = public.JSONSelectable;\n  export type Whereable = public.Whereable;\n  export type Insertable = public.Insertable;\n  export type Updatable = public.Updatable;\n  export type UniqueIndex = public.UniqueIndex;\n  export type Column = public.Column;\n\n  export type AllSchemas = ['public'];\n  export type AllBaseTables = [...public.AllBaseTables];\n  export type AllForeignTables = [...public.AllForeignTables];\n  export type AllViews = [...public.AllViews];\n  export type AllMaterializedViews = [...public.AllMaterializedViews];\n  export type AllTablesAndViews = [...public.AllTablesAndViews];\n\n\n  /* === lookups === */\n\n  export type SelectableForTable<T extends Table> = {\n    \"appleTransactions\": appleTransactions.Selectable;\n    \"arrays\": arrays.Selectable;\n    \"authors\": authors.Selectable;\n    \"bankAccounts\": bankAccounts.Selectable;\n    \"bigints\": bigints.Selectable;\n    \"books\": books.Selectable;\n    \"doctors\": doctors.Selectable;\n    \"emailAuthentication\": emailAuthentication.Selectable;\n    \"employees\": employees.Selectable;\n    \"nameCounts\": nameCounts.Selectable;\n    \"numerics\": numerics.Selectable;\n    \"photos\": photos.Selectable;\n    \"shifts\": shifts.Selectable;\n    \"stores\": stores.Selectable;\n    \"subjectPhotos\": subjectPhotos.Selectable;\n    \"subjects\": subjects.Selectable;\n    \"tags\": tags.Selectable;\n    \"usedVoucherCodes\": usedVoucherCodes.Selectable;\n    \"users\": users.Selectable;\n  }[T];\n\n  export type JSONSelectableForTable<T extends Table> = {\n    \"appleTransactions\": appleTransactions.JSONSelectable;\n    \"arrays\": arrays.JSONSelectable;\n    \"authors\": authors.JSONSelectable;\n    \"bankAccounts\": bankAccounts.JSONSelectable;\n    \"bigints\": bigints.JSONSelectable;\n    \"books\": books.JSONSelectable;\n    \"doctors\": doctors.JSONSelectable;\n    \"emailAuthentication\": emailAuthentication.JSONSelectable;\n    \"employees\": employees.JSONSelectable;\n    \"nameCounts\": nameCounts.JSONSelectable;\n    \"numerics\": numerics.JSONSelectable;\n    \"photos\": photos.JSONSelectable;\n    \"shifts\": shifts.JSONSelectable;\n    \"stores\": stores.JSONSelectable;\n    \"subjectPhotos\": subjectPhotos.JSONSelectable;\n    \"subjects\": subjects.JSONSelectable;\n    \"tags\": tags.JSONSelectable;\n    \"usedVoucherCodes\": usedVoucherCodes.JSONSelectable;\n    \"users\": users.JSONSelectable;\n  }[T];\n\n  export type WhereableForTable<T extends Table> = {\n    \"appleTransactions\": appleTransactions.Whereable;\n    \"arrays\": arrays.Whereable;\n    \"authors\": authors.Whereable;\n    \"bankAccounts\": bankAccounts.Whereable;\n    \"bigints\": bigints.Whereable;\n    \"books\": books.Whereable;\n    \"doctors\": doctors.Whereable;\n    \"emailAuthentication\": emailAuthentication.Whereable;\n    \"employees\": employees.Whereable;\n    \"nameCounts\": nameCounts.Whereable;\n    \"numerics\": numerics.Whereable;\n    \"photos\": photos.Whereable;\n    \"shifts\": shifts.Whereable;\n    \"stores\": stores.Whereable;\n    \"subjectPhotos\": subjectPhotos.Whereable;\n    \"subjects\": subjects.Whereable;\n    \"tags\": tags.Whereable;\n    \"usedVoucherCodes\": usedVoucherCodes.Whereable;\n    \"users\": users.Whereable;\n  }[T];\n\n  export type InsertableForTable<T extends Table> = {\n    \"appleTransactions\": appleTransactions.Insertable;\n    \"arrays\": arrays.Insertable;\n    \"authors\": authors.Insertable;\n    \"bankAccounts\": bankAccounts.Insertable;\n    \"bigints\": bigints.Insertable;\n    \"books\": books.Insertable;\n    \"doctors\": doctors.Insertable;\n    \"emailAuthentication\": emailAuthentication.Insertable;\n    \"employees\": employees.Insertable;\n    \"nameCounts\": nameCounts.Insertable;\n    \"numerics\": numerics.Insertable;\n    \"photos\": photos.Insertable;\n    \"shifts\": shifts.Insertable;\n    \"stores\": stores.Insertable;\n    \"subjectPhotos\": subjectPhotos.Insertable;\n    \"subjects\": subjects.Insertable;\n    \"tags\": tags.Insertable;\n    \"usedVoucherCodes\": usedVoucherCodes.Insertable;\n    \"users\": users.Insertable;\n  }[T];\n\n  export type UpdatableForTable<T extends Table> = {\n    \"appleTransactions\": appleTransactions.Updatable;\n    \"arrays\": arrays.Updatable;\n    \"authors\": authors.Updatable;\n    \"bankAccounts\": bankAccounts.Updatable;\n    \"bigints\": bigints.Updatable;\n    \"books\": books.Updatable;\n    \"doctors\": doctors.Updatable;\n    \"emailAuthentication\": emailAuthentication.Updatable;\n    \"employees\": employees.Updatable;\n    \"nameCounts\": nameCounts.Updatable;\n    \"numerics\": numerics.Updatable;\n    \"photos\": photos.Updatable;\n    \"shifts\": shifts.Updatable;\n    \"stores\": stores.Updatable;\n    \"subjectPhotos\": subjectPhotos.Updatable;\n    \"subjects\": subjects.Updatable;\n    \"tags\": tags.Updatable;\n    \"usedVoucherCodes\": usedVoucherCodes.Updatable;\n    \"users\": users.Updatable;\n  }[T];\n\n  export type UniqueIndexForTable<T extends Table> = {\n    \"appleTransactions\": appleTransactions.UniqueIndex;\n    \"arrays\": arrays.UniqueIndex;\n    \"authors\": authors.UniqueIndex;\n    \"bankAccounts\": bankAccounts.UniqueIndex;\n    \"bigints\": bigints.UniqueIndex;\n    \"books\": books.UniqueIndex;\n    \"doctors\": doctors.UniqueIndex;\n    \"emailAuthentication\": emailAuthentication.UniqueIndex;\n    \"employees\": employees.UniqueIndex;\n    \"nameCounts\": nameCounts.UniqueIndex;\n    \"numerics\": numerics.UniqueIndex;\n    \"photos\": photos.UniqueIndex;\n    \"shifts\": shifts.UniqueIndex;\n    \"stores\": stores.UniqueIndex;\n    \"subjectPhotos\": subjectPhotos.UniqueIndex;\n    \"subjects\": subjects.UniqueIndex;\n    \"tags\": tags.UniqueIndex;\n    \"usedVoucherCodes\": usedVoucherCodes.UniqueIndex;\n    \"users\": users.UniqueIndex;\n  }[T];\n\n  export type ColumnForTable<T extends Table> = {\n    \"appleTransactions\": appleTransactions.Column;\n    \"arrays\": arrays.Column;\n    \"authors\": authors.Column;\n    \"bankAccounts\": bankAccounts.Column;\n    \"bigints\": bigints.Column;\n    \"books\": books.Column;\n    \"doctors\": doctors.Column;\n    \"emailAuthentication\": emailAuthentication.Column;\n    \"employees\": employees.Column;\n    \"nameCounts\": nameCounts.Column;\n    \"numerics\": numerics.Column;\n    \"photos\": photos.Column;\n    \"shifts\": shifts.Column;\n    \"stores\": stores.Column;\n    \"subjectPhotos\": subjectPhotos.Column;\n    \"subjects\": subjects.Column;\n    \"tags\": tags.Column;\n    \"usedVoucherCodes\": usedVoucherCodes.Column;\n    \"users\": users.Column;\n  }[T];\n\n  export type SQLForTable<T extends Table> = {\n    \"appleTransactions\": appleTransactions.SQL;\n    \"arrays\": arrays.SQL;\n    \"authors\": authors.SQL;\n    \"bankAccounts\": bankAccounts.SQL;\n    \"bigints\": bigints.SQL;\n    \"books\": books.SQL;\n    \"doctors\": doctors.SQL;\n    \"emailAuthentication\": emailAuthentication.SQL;\n    \"employees\": employees.SQL;\n    \"nameCounts\": nameCounts.SQL;\n    \"numerics\": numerics.SQL;\n    \"photos\": photos.SQL;\n    \"shifts\": shifts.SQL;\n    \"stores\": stores.SQL;\n    \"subjectPhotos\": subjectPhotos.SQL;\n    \"subjects\": subjects.SQL;\n    \"tags\": tags.SQL;\n    \"usedVoucherCodes\": usedVoucherCodes.SQL;\n    \"users\": users.SQL;\n  }[T];\n\n}\n","node_modules/@types/zapatos/db/canary.d.ts":"/**\n * This value gets incremented whenever there's an incompatible change to the\n * generated schema format, in order to raise a type error and thereby force\n * schema regeneration.\n */\nexport interface SchemaVersionCanary {\n    version: 104;\n}\n","node_modules/@types/zapatos/db/conditions.d.ts":"import { SQLFragment } from './core';\nimport type { Whereable } from 'zapatos/schema';\nexport declare const isNull: SQLFragment<boolean, never>;\nexport declare const isNotNull: SQLFragment<boolean, never>;\nexport declare const isTrue: SQLFragment<boolean, never>;\nexport declare const isNotTrue: SQLFragment<boolean, never>;\nexport declare const isFalse: SQLFragment<boolean, never>;\nexport declare const isNotFalse: SQLFragment<boolean, never>;\nexport declare const isUnknown: SQLFragment<boolean, never>;\nexport declare const isNotUnknown: SQLFragment<boolean, never>;\nexport declare const isDistinctFrom: <T>(a: T) => SQLFragment<boolean, T>;\nexport declare const isNotDistinctFrom: <T>(a: T) => SQLFragment<boolean, T>;\nexport declare const eq: <T>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const ne: <T>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const gt: <T>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const gte: <T>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const lt: <T>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const lte: <T>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const between: <T>(a: T, b: T) => SQLFragment<boolean | null, T>;\nexport declare const betweenSymmetric: <T>(a: T, b: T) => SQLFragment<boolean | null, T>;\nexport declare const notBetween: <T>(a: T, b: T) => SQLFragment<boolean | null, T>;\nexport declare const notBetweenSymmetric: <T>(a: T, b: T) => SQLFragment<boolean | null, T>;\nexport declare const like: <T extends string>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const notLike: <T extends string>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const ilike: <T extends string>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const notIlike: <T extends string>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const similarTo: <T extends string>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const notSimilarTo: <T extends string>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const reMatch: <T extends string>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const reImatch: <T extends string>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const notReMatch: <T extends string>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const notReImatch: <T extends string>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const isIn: <T>(a: readonly T[]) => SQLFragment<any[], never> | SQLFragment<boolean | null, T>;\nexport declare const isNotIn: <T>(a: readonly T[]) => SQLFragment<any[], never> | SQLFragment<boolean | null, T>;\nexport declare const or: <T>(...conditions: (Whereable | SQLFragment<any, T>)[]) => SQLFragment<boolean | null, T>;\nexport declare const and: <T>(...conditions: (Whereable | SQLFragment<any, T>)[]) => SQLFragment<boolean | null, T>;\nexport declare const not: <T>(condition: Whereable | SQLFragment<any, T>) => SQLFragment<boolean | null, T>;\ntype PluralisingIntervalUnit = 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day' | 'week' | 'month' | 'year' | 'decade';\ntype IntervalUnit = PluralisingIntervalUnit | `${PluralisingIntervalUnit}s` | 'century' | 'centuries' | 'millennium' | 'millennia';\nexport declare const fromNow: (n: number, unit?: IntervalUnit) => SQLFragment<any[], never>;\nexport declare const after: <T>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const before: <T>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const now: SQLFragment<any[], never>;\nexport declare const add: <T extends number | Date>(a: T) => SQLFragment<number, T>;\nexport declare const subtract: <T extends number | Date>(a: T) => SQLFragment<number, T>;\nexport {};\n","node_modules/@types/zapatos/db/config.d.ts":"export interface SQLQuery {\n    text: string;\n    values: any[];\n    name?: string;\n}\nexport interface Config {\n    transactionAttemptsMax: number;\n    transactionRetryDelay: {\n        minMs: number;\n        maxMs: number;\n    };\n    castArrayParamsToJson: boolean;\n    castObjectParamsToJson: boolean;\n    queryListener?(query: SQLQuery, txnId?: number): void;\n    resultListener?(result: any, txnId?: number, elapsedMs?: number): void;\n    transactionListener?(message: string, txnId?: number): void;\n}\nexport type NewConfig = Partial<Config>;\n/**\n * Get (a copy of) the current configuration.\n */\nexport declare const getConfig: () => {\n    transactionAttemptsMax: number;\n    transactionRetryDelay: {\n        minMs: number;\n        maxMs: number;\n    };\n    castArrayParamsToJson: boolean;\n    castObjectParamsToJson: boolean;\n    queryListener?(query: SQLQuery, txnId?: number): void;\n    resultListener?(result: any, txnId?: number, elapsedMs?: number): void;\n    transactionListener?(message: string, txnId?: number): void;\n};\n/**\n * Set key(s) on the configuration.\n * @param newConfig Partial configuration object\n */\nexport declare const setConfig: (newConfig: NewConfig) => {\n    transactionAttemptsMax: number;\n    transactionRetryDelay: {\n        minMs: number;\n        maxMs: number;\n    };\n    castArrayParamsToJson: boolean;\n    castObjectParamsToJson: boolean;\n    queryListener?: (query: SQLQuery, txnId?: number) => void;\n    resultListener?: (result: any, txnId?: number, elapsedMs?: number) => void;\n    transactionListener?: (message: string, txnId?: number) => void;\n};\n","node_modules/@types/zapatos/db/core.d.ts":"/// <reference types=\"node\" />\nimport type * as pg from 'pg';\nimport { SQLQuery } from './config';\nimport { NoInfer } from './utils';\nimport type { Updatable, Whereable, Table, Column } from 'zapatos/schema';\n/**\n * Compiles to `DEFAULT` for use in `INSERT`/`UPDATE` queries.\n */\nexport declare const Default: unique symbol;\nexport type DefaultType = typeof Default;\n/**\n * Compiles to the current column name within a `Whereable`.\n */\nexport declare const self: unique symbol;\nexport type SelfType = typeof self;\n/**\n * Signals all rows are to be returned (without filtering via a `WHERE` clause)\n */\nexport declare const all: unique symbol;\nexport type AllType = typeof all;\n/**\n * JSON types\n */\nexport type JSONValue = null | boolean | number | string | JSONObject | JSONArray;\nexport type JSONObject = {\n    [k: string]: JSONValue;\n};\nexport type JSONArray = JSONValue[];\n/**\n * `int8` or `numeric` value represented as a string\n */\nexport type Int8String = `${number}`;\nexport type NumericString = `${number}`;\n/**\n * Generic range value represented as a string\n */\nexport type RangeString<Bound extends string | number> = `${'[' | '('}${Bound},${Bound}${']' | ')'}`;\n/**\n * `tsrange`, `tstzrange` or `daterange` value represented as a string. The\n * format of the upper and lower bound `date`, `timestamp` or `timestamptz`\n * values depends on pg's `DateStyle` setting.\n */\nexport type DateRangeString = RangeString<string>;\n/**\n * `int4range`, `int8range` or `numrange` value represented as a string\n */\nexport type NumberRangeString = RangeString<number | ''>;\n/**\n * `bytea` value represented as a hex string. Note: for large objects, use\n * something like https://www.npmjs.com/package/pg-large-object instead.\n */\nexport type ByteArrayString = `\\\\x${string}`;\n/**\n * Make a function `STRICT` in the Postgres sense — where it's an alias for\n * `RETURNS NULL ON NULL INPUT` — with appropriate typing.\n *\n * For example, Zapatos' `toBuffer()` function is defined as:\n *\n * ```\n * export const toBuffer = strict((ba: ByteArrayString) => Buffer.from(ba.slice(2), 'hex'));\n * ```\n *\n * The generic input and output types `FnIn` and `FnOut` can be inferred from\n * `fn`, as seen above, but can also be explicitly narrowed. For example, to\n * convert specifically from `TimestampTzString` to Luxon's `DateTime`, but\n * pass through `null`s unchanged:\n *\n * ```\n * const toDateTime = db.strict<db.TimestampTzString, DateTime>(DateTime.fromISO);\n * ```\n *\n * @param fn The single-argument transformation function to be made strict.\n */\nexport declare function strict<FnIn, FnOut>(fn: (x: FnIn) => FnOut): <T extends FnIn | null>(d: T) => T extends FnIn ? Exclude<T, FnIn> | FnOut : T;\n/**\n * Convert a `bytea` hex representation to a JavaScript `Buffer`. Note: for\n * large objects, use something like\n * [pg-large-object](https://www.npmjs.com/package/pg-large-object) instead.\n *\n * @param ba The `ByteArrayString` hex representation (or `null`)\n */\nexport declare const toBuffer: <T extends `\\\\x${string}` | null>(d: T) => T extends `\\\\x${string}` ? Buffer | Exclude<T, `\\\\x${string}`> : T;\n/**\n * Compiles to a numbered query parameter (`$1`, `$2`, etc) and adds the wrapped value\n * at the appropriate position of the values array passed to `pg`.\n * @param x The value to be wrapped\n * @param cast Optional cast type. If a string, the parameter will be cast to\n * this type within the query e.g. `CAST($1 AS type)` instead of plain `$1`. If\n * `true`, the value will be JSON stringified and cast to `json` (irrespective\n * of the configuration parameters `castArrayParamsToJson` and\n * `castObjectParamsToJson`). If `false`, the value will **not** be JSON-\n * stringified or cast to `json` (again irrespective of the configuration\n * parameters `castArrayParamsToJson` and `castObjectParamsToJson`).\n */\nexport declare class Parameter<T = any> {\n    value: T;\n    cast?: string | boolean | undefined;\n    constructor(value: T, cast?: string | boolean | undefined);\n}\n/**\n * Returns a `Parameter` instance, which compiles to a numbered query parameter\n * (`$1`, `$2`, etc) and adds its wrapped value at the appropriate position of\n * the values array passed to `pg`.\n * @param x The value to be wrapped\n * @param cast Optional cast type. If a string, the parameter will be cast to\n * this type within the query e.g. `CAST($1 AS type)` instead of plain `$1`. If\n * `true`, the value will be JSON stringified and cast to `json` (irrespective\n * of the configuration parameters `castArrayParamsToJson` and\n * `castObjectParamsToJson`). If `false`, the value will **not** be JSON\n * stringified or cast to `json` (again irrespective of the configuration\n * parameters `castArrayParamsToJson` and `castObjectParamsToJson`).\n */\nexport declare function param<T = any>(x: T, cast?: boolean | string): Parameter<T>;\n/**\n * 💥💥💣 **DANGEROUS** 💣💥💥\n *\n * Compiles to the wrapped string value, as is, which may enable SQL injection\n * attacks.\n */\nexport declare class DangerousRawString {\n    value: string;\n    constructor(value: string);\n}\n/**\n * 💥💥💣 **DANGEROUS** 💣💥💥\n *\n * Remember [Little Bobby Tables](https://xkcd.com/327/).\n * Did you want `db.param` instead?\n * ---\n * Returns a `DangerousRawString` instance, wrapping a string.\n * `DangerousRawString` compiles to the wrapped string value, as-is, which may\n * enable SQL injection attacks.\n */\nexport declare function raw(x: string): DangerousRawString;\n/**\n * Wraps either an array or object, and compiles to a quoted, comma-separated\n * list of array values (for use in a `SELECT` query) or object keys (for use\n * in an `INSERT`, `UPDATE` or `UPSERT` query, alongside `ColumnValues`).\n */\nexport declare class ColumnNames<T> {\n    value: T;\n    constructor(value: T);\n}\n/**\n * Returns a `ColumnNames` instance, wrapping either an array or an object.\n * `ColumnNames` compiles to a quoted, comma-separated list of array values (for\n * use in a `SELECT` query) or object keys (for use in an `INSERT`, `UDPATE` or\n * `UPSERT` query alongside a `ColumnValues`).\n */\nexport declare function cols<T>(x: T): ColumnNames<T>;\n/**\n * Compiles to a quoted, comma-separated list of object keys for use in an\n * `INSERT`, `UPDATE` or `UPSERT` query, alongside `ColumnNames`.\n */\nexport declare class ColumnValues<T> {\n    value: T;\n    constructor(value: T);\n}\n/**\n * Returns a ColumnValues instance, wrapping an object. ColumnValues compiles to\n * a quoted, comma-separated list of object keys for use in an INSERT, UPDATE\n * or UPSERT query alongside a `ColumnNames`.\n */\nexport declare function vals<T>(x: T): ColumnValues<T>;\n/**\n * Compiles to the name of the column it wraps in the table of the parent query.\n * @param value The column name\n */\nexport declare class ParentColumn<T extends Column | undefined = Column | undefined> {\n    value?: T | undefined;\n    constructor(value?: T | undefined);\n}\n/**\n * Returns a `ParentColumn` instance, wrapping a column name, which compiles to\n * that column name of the table of the parent query.\n */\nexport declare function parent<T extends Column | undefined = Column | undefined>(x?: T): ParentColumn<T>;\nexport type GenericSQLExpression = SQLFragment<any, any> | Parameter | DefaultType | DangerousRawString | SelfType;\nexport type SQLExpression = Table | ColumnNames<Updatable | (keyof Updatable)[]> | ColumnValues<Updatable | any[]> | Whereable | Column | ParentColumn | GenericSQLExpression;\nexport type SQL = SQLExpression | SQLExpression[];\nexport type Queryable = pg.ClientBase | pg.Pool;\n/**\n * Tagged template function returning a `SQLFragment`. The first generic type\n * argument defines what interpolated value types are allowed. The second\n * defines what type the `SQLFragment` produces, where relevant (i.e. when\n * calling `.run(...)` on it, or using it as the value of an `extras` object).\n */\nexport declare function sql<Interpolations = SQL, RunResult = pg.QueryResult['rows'], Constraint = never>(literals: TemplateStringsArray, ...expressions: NoInfer<Interpolations>[]): SQLFragment<RunResult, Constraint>;\nexport declare class SQLFragment<RunResult = pg.QueryResult['rows'], Constraint = never> {\n    protected literals: string[];\n    protected expressions: SQL[];\n    protected constraint?: Constraint;\n    /**\n     * When calling `run`, this function is applied to the object returned by `pg`\n     * to produce the result that is returned. By default, the `rows` array is\n     * returned — i.e. `(qr) => qr.rows` — but some shortcut functions alter this\n     * in order to match their declared `RunResult` type.\n     */\n    runResultTransform: (qr: pg.QueryResult) => any;\n    parentTable?: string;\n    preparedName?: string;\n    noop: boolean;\n    noopResult: any;\n    constructor(literals: string[], expressions: SQL[]);\n    /**\n     * Instruct Postgres to treat this as a prepared statement: see\n     * https://node-postgres.com/features/queries#prepared-statements\n     * @param name A name for the prepared query. If not specified, it takes the\n     * value '_zapatos_prepared_N', where N is an increasing sequence number.\n     */\n    prepared: (name?: string) => this;\n    /**\n     * Compile and run this query using the provided database connection. What's\n     * returned is piped via `runResultTransform` before being returned.\n     * @param queryable A database client or pool\n     * @param force If true, force this query to hit the DB even if it's marked as a no-op\n     */\n    run: (queryable: Queryable, force?: boolean) => Promise<RunResult>;\n    /**\n     * Compile this query, returning a `{ text: string, values: any[] }` object\n     * that could be passed to the `pg` query function. Arguments are generally\n     * only passed when the function calls itself recursively.\n     */\n    compile: (result?: SQLQuery, parentTable?: string, currentColumn?: Column) => SQLQuery;\n    compileExpression: (expression: SQL, result?: SQLQuery, parentTable?: string, currentColumn?: Column) => void;\n}\n","node_modules/@types/zapatos/db/customJSON.d.ts":"import type * as pgLib from 'pg';\nexport declare function enableCustomJSONParsingForLargeNumbers(pg: typeof pgLib): void;\n","node_modules/@types/zapatos/db/date.d.ts":"/**\n * An ISO8601-formatted date string, such as `\"2021-05-25\"`.\n */\nexport type DateString = `${number}-${number}-${number}`;\n/**\n * An ISO8601-formatted time string, such as `\"14:41\"` or `\"14:41:10.249\"`.\n */\nexport type TimeString = `${number}:${number}${'' | `:${number}`}`;\n/**\n * A timezone suffix string, such as `\"Z\"`, `\"-02\"`, or `\"+01:00\"`.\n */\nexport type TzSuffix = 'Z' | `${'+' | '-'}${number}${'' | `:${number}`}`;\n/**\n * A time and timezone string, such as `\"14:41:10+02\"`. **Postgres docs advise\n * against use of this type except in legacy contexts.**\n */\nexport type TimeTzString = `${TimeString}${TzSuffix}`;\n/**\n * An ISO8601-formatted date and time string **with no timezone**, such as\n * `\"2021-05-25T14:41.10.249097\"`.\n */\nexport type TimestampString = `${DateString}T${TimeString}`;\n/**\n * An ISO8601-formatted date, time and (numeric) timezone string, such as\n * `\"2021-05-25T14:41.10.249097+01:00\"`.\n */\nexport type TimestampTzString = `${TimestampString}${TzSuffix}`;\ntype TzLocalOrUTC = 'UTC' | 'local';\ninterface ToDate {\n    <D extends null | TimestampTzString>(d: D, tzInterpretation?: undefined): D extends null ? null : Date;\n    <D extends null | TimestampString | DateString>(d: D, tzInterpretation: TzLocalOrUTC): D extends null ? null : Date;\n}\n/**\n * Convert a `TimestampTzString`, `TimestampString` or `DateString` to a\n * JavaScript `Date`. For `TimestampString` and `DateString`, you must specify\n * whether the input is to be interpreted in the JavaScript environment's local\n * time or as UTC.\n *\n * Nullability is preserved (e.g. `TimestampTzString | null` input gives\n * `Date | null` output).\n *\n * _Note:_ Postgres date-time types default to microsecond precision, but must be\n * truncated to the millisecond precision of a JavaScript `Date` here.\n *\n * @param d A `TimestampTzString`, `TimestampString` or `DateString` (or\n * `null`) for conversion.\n * @param tzInterpretation For `TimestampString` or `DateString` input only,\n * `\"UTC\"` if the input is to be interpreted as UTC or `\"local\"` if it is to be\n * interpreted in the JavaScript environment's local time\n */\nexport declare const toDate: ToDate;\ninterface ToString {\n    <D extends Date | null, T extends 'timestamptz' | `${'timestamp' | 'date'}:${TzLocalOrUTC}`>(d: D, stringTypeTz: T): D extends null ? null : {\n        'timestamptz': TimestampTzString;\n        'timestamp:UTC': TimestampString;\n        'timestamp:local': TimestampString;\n        'date:UTC': DateString;\n        'date:local': DateString;\n    }[T];\n}\n/**\n * Convert a JavaScript `Date` to a `TimestampTzString`, `TimestampString` or\n * `DateString`.\n *\n * For `TimestampString` and `DateString`, you must specify whether the input\n * is to be expressed in the JavaScript environment's local time or as UTC.\n *\n * Nullability is preserved (e.g. `Date | null` maps to something extending\n * `string | null`).\n *\n * @param d A `Date` (or `null`) for conversion.\n * @param stringTypeTz The pg type corresponding to the desired string format\n * and (except for `timestamptz`) whether to express in UTC or local time. For\n * example: `\"timestamptz\"`, `\"timestamp:local\"` or `\"date:UTC\"`.\n */\nexport declare const toString: ToString;\nexport {};\n","node_modules/@types/zapatos/db/index.d.ts":"export * from './canary';\nexport * from './config';\nexport * from './core';\nexport * from './date';\nexport * from './pgErrors';\nexport * from './shortcuts';\nexport * from './transaction';\nexport { mapWithSeparator } from './utils';\nexport * from './customJSON';\nexport * as conditions from './conditions';\n","node_modules/@types/zapatos/db/pgErrors.d.ts":"interface Error {\n    code?: string;\n}\n/**\n * Check whether an error object matches any of a set of Postgres error types.\n * @param err The error to check\n * @param types The Postgres error types to check against\n */\nexport declare function isDatabaseError(err: Error, ...types: (keyof typeof pgErrors)[]): boolean;\ndeclare const pgErrors: {\n    SuccessfulCompletion: string;\n    Warning: string;\n    NoData: string;\n    SqlStatementNotYetComplete: string;\n    ConnectionException: string;\n    TriggeredActionException: string;\n    FeatureNotSupported: string;\n    InvalidTransactionInitiation: string;\n    LocatorException: string;\n    InvalidGrantor: string;\n    InvalidRoleSpecification: string;\n    DiagnosticsException: string;\n    CaseNotFound: string;\n    CardinalityViolation: string;\n    DataException: string;\n    IntegrityConstraintViolation: string;\n    InvalidCursorState: string;\n    InvalidTransactionState: string;\n    InvalidSqlStatementName: string;\n    TriggeredDataChangeViolation: string;\n    InvalidAuthorizationSpecification: string;\n    DependentPrivilegeDescriptorsStillExist: string;\n    InvalidTransactionTermination: string;\n    SqlRoutineException: string;\n    InvalidCursorName: string;\n    ExternalRoutineException: string;\n    ExternalRoutineInvocationException: string;\n    SavepointException: string;\n    InvalidCatalogName: string;\n    InvalidSchemaName: string;\n    TransactionRollback: string;\n    SyntaxErrorOrAccessRuleViolation: string;\n    WithCheckOptionViolation: string;\n    InsufficientResources: string;\n    DiskFull: string;\n    OutOfMemory: string;\n    TooManyConnections: string;\n    ConfigurationLimitExceeded: string;\n    ProgramLimitExceeded: string;\n    ObjectNotInPrerequisiteState: string;\n    OperatorIntervention: string;\n    SystemError: string;\n    SnapshotTooOld: string;\n    ConfigFileError: string;\n    FdwError: string;\n    PlpgsqlError: string;\n    InternalError: string;\n    SuccessfulCompletion_SuccessfulCompletion: string;\n    Warning_Warning: string;\n    Warning_NullValueEliminatedInSetFunction: string;\n    Warning_StringDataRightTruncation: string;\n    Warning_PrivilegeNotRevoked: string;\n    Warning_PrivilegeNotGranted: string;\n    Warning_ImplicitZeroBitPadding: string;\n    Warning_DynamicResultSetsReturned: string;\n    Warning_DeprecatedFeature: string;\n    NoData_NoData: string;\n    NoData_NoAdditionalDynamicResultSetsReturned: string;\n    SqlStatementNotYetComplete_SqlStatementNotYetComplete: string;\n    ConnectionException_ConnectionException: string;\n    ConnectionException_SqlclientUnableToEstablishSqlconnection: string;\n    ConnectionException_ConnectionDoesNotExist: string;\n    ConnectionException_SqlserverRejectedEstablishmentOfSqlconnection: string;\n    ConnectionException_ConnectionFailure: string;\n    ConnectionException_TransactionResolutionUnknown: string;\n    ConnectionException_ProtocolViolation: string;\n    TriggeredActionException_TriggeredActionException: string;\n    FeatureNotSupported_FeatureNotSupported: string;\n    InvalidTransactionInitiation_InvalidTransactionInitiation: string;\n    LocatorException_LocatorException: string;\n    LocatorException_InvalidLocatorSpecification: string;\n    InvalidGrantor_InvalidGrantor: string;\n    InvalidGrantor_InvalidGrantOperation: string;\n    InvalidRoleSpecification_InvalidRoleSpecification: string;\n    DiagnosticsException_DiagnosticsException: string;\n    DiagnosticsException_StackedDiagnosticsAccessedWithoutActiveHandler: string;\n    CaseNotFound_CaseNotFound: string;\n    CardinalityViolation_CardinalityViolation: string;\n    DataException_DataException: string;\n    DataException_StringDataRightTruncation: string;\n    DataException_NullValueNoIndicatorParameter: string;\n    DataException_NumericValueOutOfRange: string;\n    DataException_NullValueNotAllowed: string;\n    DataException_ErrorInAssignment: string;\n    DataException_InvalidDatetimeFormat: string;\n    DataException_DatetimeFieldOverflow: string;\n    DataException_InvalidTimeZoneDisplacementValue: string;\n    DataException_EscapeCharacterConflict: string;\n    DataException_InvalidUseOfEscapeCharacter: string;\n    DataException_InvalidEscapeOctet: string;\n    DataException_ZeroLengthCharacterString: string;\n    DataException_MostSpecificTypeMismatch: string;\n    DataException_SequenceGeneratorLimitExceeded: string;\n    DataException_NotAnXmlDocument: string;\n    DataException_InvalidXmlDocument: string;\n    DataException_InvalidXmlContent: string;\n    DataException_InvalidXmlComment: string;\n    DataException_InvalidXmlProcessingInstruction: string;\n    DataException_InvalidIndicatorParameterValue: string;\n    DataException_SubstringError: string;\n    DataException_DivisionByZero: string;\n    DataException_InvalidPrecedingOrFollowingSize: string;\n    DataException_InvalidArgumentForNtileFunction: string;\n    DataException_IntervalFieldOverflow: string;\n    DataException_InvalidArgumentForNthValueFunction: string;\n    DataException_InvalidCharacterValueForCast: string;\n    DataException_InvalidEscapeCharacter: string;\n    DataException_InvalidRegularExpression: string;\n    DataException_InvalidArgumentForLogarithm: string;\n    DataException_InvalidArgumentForPowerFunction: string;\n    DataException_InvalidArgumentForWidthBucketFunction: string;\n    DataException_InvalidRowCountInLimitClause: string;\n    DataException_InvalidRowCountInResultOffsetClause: string;\n    DataException_CharacterNotInRepertoire: string;\n    DataException_IndicatorOverflow: string;\n    DataException_InvalidParameterValue: string;\n    DataException_UnterminatedCString: string;\n    DataException_InvalidEscapeSequence: string;\n    DataException_StringDataLengthMismatch: string;\n    DataException_TrimError: string;\n    DataException_ArraySubscriptError: string;\n    DataException_InvalidTablesampleRepeat: string;\n    DataException_InvalidTablesampleArgument: string;\n    DataException_FloatingPointException: string;\n    DataException_InvalidTextRepresentation: string;\n    DataException_InvalidBinaryRepresentation: string;\n    DataException_BadCopyFileFormat: string;\n    DataException_UntranslatableCharacter: string;\n    DataException_NonstandardUseOfEscapeCharacter: string;\n    IntegrityConstraintViolation_IntegrityConstraintViolation: string;\n    IntegrityConstraintViolation_RestrictViolation: string;\n    IntegrityConstraintViolation_NotNullViolation: string;\n    IntegrityConstraintViolation_ForeignKeyViolation: string;\n    IntegrityConstraintViolation_UniqueViolation: string;\n    IntegrityConstraintViolation_CheckViolation: string;\n    IntegrityConstraintViolation_ExclusionViolation: string;\n    InvalidCursorState_InvalidCursorState: string;\n    InvalidTransactionState_InvalidTransactionState: string;\n    InvalidTransactionState_ActiveSqlTransaction: string;\n    InvalidTransactionState_BranchTransactionAlreadyActive: string;\n    InvalidTransactionState_InappropriateAccessModeForBranchTransaction: string;\n    InvalidTransactionState_InappropriateIsolationLevelForBranchTransaction: string;\n    InvalidTransactionState_NoActiveSqlTransactionForBranchTransaction: string;\n    InvalidTransactionState_ReadOnlySqlTransaction: string;\n    InvalidTransactionState_SchemaAndDataStatementMixingNotSupported: string;\n    InvalidTransactionState_HeldCursorRequiresSameIsolationLevel: string;\n    InvalidTransactionState_NoActiveSqlTransaction: string;\n    InvalidTransactionState_InFailedSqlTransaction: string;\n    InvalidTransactionState_IdleInTransactionSessionTimeout: string;\n    InvalidSqlStatementName_InvalidSqlStatementName: string;\n    TriggeredDataChangeViolation_TriggeredDataChangeViolation: string;\n    InvalidAuthorizationSpecification_InvalidAuthorizationSpecification: string;\n    InvalidAuthorizationSpecification_InvalidPassword: string;\n    DependentPrivilegeDescriptorsStillExist_DependentPrivilegeDescriptorsStillExist: string;\n    DependentPrivilegeDescriptorsStillExist_DependentObjectsStillExist: string;\n    InvalidTransactionTermination_InvalidTransactionTermination: string;\n    SqlRoutineException_SqlRoutineException: string;\n    SqlRoutineException_ModifyingSqlDataNotPermitted: string;\n    SqlRoutineException_ProhibitedSqlStatementAttempted: string;\n    SqlRoutineException_ReadingSqlDataNotPermitted: string;\n    SqlRoutineException_FunctionExecutedNoReturnStatement: string;\n    InvalidCursorName_InvalidCursorName: string;\n    ExternalRoutineException_ExternalRoutineException: string;\n    ExternalRoutineException_ContainingSqlNotPermitted: string;\n    ExternalRoutineException_ModifyingSqlDataNotPermitted: string;\n    ExternalRoutineException_ProhibitedSqlStatementAttempted: string;\n    ExternalRoutineException_ReadingSqlDataNotPermitted: string;\n    ExternalRoutineInvocationException_ExternalRoutineInvocationException: string;\n    ExternalRoutineInvocationException_InvalidSqlstateReturned: string;\n    ExternalRoutineInvocationException_NullValueNotAllowed: string;\n    ExternalRoutineInvocationException_TriggerProtocolViolated: string;\n    ExternalRoutineInvocationException_SrfProtocolViolated: string;\n    ExternalRoutineInvocationException_EventTriggerProtocolViolated: string;\n    SavepointException_SavepointException: string;\n    SavepointException_InvalidSavepointSpecification: string;\n    InvalidCatalogName_InvalidCatalogName: string;\n    InvalidSchemaName_InvalidSchemaName: string;\n    TransactionRollback_TransactionRollback: string;\n    TransactionRollback_SerializationFailure: string;\n    TransactionRollback_TransactionIntegrityConstraintViolation: string;\n    TransactionRollback_StatementCompletionUnknown: string;\n    TransactionRollback_DeadlockDetected: string;\n    SyntaxErrorOrAccessRuleViolation_SyntaxErrorOrAccessRuleViolation: string;\n    SyntaxErrorOrAccessRuleViolation_InsufficientPrivilege: string;\n    SyntaxErrorOrAccessRuleViolation_SyntaxError: string;\n    SyntaxErrorOrAccessRuleViolation_InvalidName: string;\n    SyntaxErrorOrAccessRuleViolation_InvalidColumnDefinition: string;\n    SyntaxErrorOrAccessRuleViolation_NameTooLong: string;\n    SyntaxErrorOrAccessRuleViolation_DuplicateColumn: string;\n    SyntaxErrorOrAccessRuleViolation_AmbiguousColumn: string;\n    SyntaxErrorOrAccessRuleViolation_UndefinedColumn: string;\n    SyntaxErrorOrAccessRuleViolation_UndefinedObject: string;\n    SyntaxErrorOrAccessRuleViolation_DuplicateObject: string;\n    SyntaxErrorOrAccessRuleViolation_DuplicateAlias: string;\n    SyntaxErrorOrAccessRuleViolation_DuplicateFunction: string;\n    SyntaxErrorOrAccessRuleViolation_AmbiguousFunction: string;\n    SyntaxErrorOrAccessRuleViolation_GroupingError: string;\n    SyntaxErrorOrAccessRuleViolation_DatatypeMismatch: string;\n    SyntaxErrorOrAccessRuleViolation_WrongObjectType: string;\n    SyntaxErrorOrAccessRuleViolation_InvalidForeignKey: string;\n    SyntaxErrorOrAccessRuleViolation_CannotCoerce: string;\n    SyntaxErrorOrAccessRuleViolation_UndefinedFunction: string;\n    SyntaxErrorOrAccessRuleViolation_GeneratedAlways: string;\n    SyntaxErrorOrAccessRuleViolation_ReservedName: string;\n    SyntaxErrorOrAccessRuleViolation_UndefinedTable: string;\n    SyntaxErrorOrAccessRuleViolation_UndefinedParameter: string;\n    SyntaxErrorOrAccessRuleViolation_DuplicateCursor: string;\n    SyntaxErrorOrAccessRuleViolation_DuplicateDatabase: string;\n    SyntaxErrorOrAccessRuleViolation_DuplicatePreparedStatement: string;\n    SyntaxErrorOrAccessRuleViolation_DuplicateSchema: string;\n    SyntaxErrorOrAccessRuleViolation_DuplicateTable: string;\n    SyntaxErrorOrAccessRuleViolation_AmbiguousParameter: string;\n    SyntaxErrorOrAccessRuleViolation_AmbiguousAlias: string;\n    SyntaxErrorOrAccessRuleViolation_InvalidColumnReference: string;\n    SyntaxErrorOrAccessRuleViolation_InvalidCursorDefinition: string;\n    SyntaxErrorOrAccessRuleViolation_InvalidDatabaseDefinition: string;\n    SyntaxErrorOrAccessRuleViolation_InvalidFunctionDefinition: string;\n    SyntaxErrorOrAccessRuleViolation_InvalidPreparedStatementDefinition: string;\n    SyntaxErrorOrAccessRuleViolation_InvalidSchemaDefinition: string;\n    SyntaxErrorOrAccessRuleViolation_InvalidTableDefinition: string;\n    SyntaxErrorOrAccessRuleViolation_InvalidObjectDefinition: string;\n    SyntaxErrorOrAccessRuleViolation_IndeterminateDatatype: string;\n    SyntaxErrorOrAccessRuleViolation_InvalidRecursion: string;\n    SyntaxErrorOrAccessRuleViolation_WindowingError: string;\n    SyntaxErrorOrAccessRuleViolation_CollationMismatch: string;\n    SyntaxErrorOrAccessRuleViolation_IndeterminateCollation: string;\n    WithCheckOptionViolation_WithCheckOptionViolation: string;\n    InsufficientResources_InsufficientResources: string;\n    InsufficientResources_DiskFull: string;\n    InsufficientResources_OutOfMemory: string;\n    InsufficientResources_TooManyConnections: string;\n    InsufficientResources_ConfigurationLimitExceeded: string;\n    ProgramLimitExceeded_ProgramLimitExceeded: string;\n    ProgramLimitExceeded_StatementTooComplex: string;\n    ProgramLimitExceeded_TooManyColumns: string;\n    ProgramLimitExceeded_TooManyArguments: string;\n    ObjectNotInPrerequisiteState_ObjectNotInPrerequisiteState: string;\n    ObjectNotInPrerequisiteState_ObjectInUse: string;\n    ObjectNotInPrerequisiteState_CantChangeRuntimeParam: string;\n    ObjectNotInPrerequisiteState_LockNotAvailable: string;\n    OperatorIntervention_OperatorIntervention: string;\n    OperatorIntervention_QueryCanceled: string;\n    OperatorIntervention_AdminShutdown: string;\n    OperatorIntervention_CrashShutdown: string;\n    OperatorIntervention_CannotConnectNow: string;\n    OperatorIntervention_DatabaseDropped: string;\n    SystemError_SystemError: string;\n    SystemError_IoError: string;\n    SystemError_UndefinedFile: string;\n    SystemError_DuplicateFile: string;\n    SnapshotTooOld_SnapshotTooOld: string;\n    ConfigFileError_ConfigFileError: string;\n    ConfigFileError_LockFileExists: string;\n    FdwError_FdwError: string;\n    FdwError_FdwOutOfMemory: string;\n    FdwError_FdwDynamicParameterValueNeeded: string;\n    FdwError_FdwInvalidDataType: string;\n    FdwError_FdwColumnNameNotFound: string;\n    FdwError_FdwInvalidDataTypeDescriptors: string;\n    FdwError_FdwInvalidColumnName: string;\n    FdwError_FdwInvalidColumnNumber: string;\n    FdwError_FdwInvalidUseOfNullPointer: string;\n    FdwError_FdwInvalidStringFormat: string;\n    FdwError_FdwInvalidHandle: string;\n    FdwError_FdwInvalidOptionIndex: string;\n    FdwError_FdwInvalidOptionName: string;\n    FdwError_FdwOptionNameNotFound: string;\n    FdwError_FdwReplyHandle: string;\n    FdwError_FdwUnableToCreateExecution: string;\n    FdwError_FdwUnableToCreateReply: string;\n    FdwError_FdwUnableToEstablishConnection: string;\n    FdwError_FdwNoSchemas: string;\n    FdwError_FdwSchemaNotFound: string;\n    FdwError_FdwTableNotFound: string;\n    FdwError_FdwFunctionSequenceError: string;\n    FdwError_FdwTooManyHandles: string;\n    FdwError_FdwInconsistentDescriptorInformation: string;\n    FdwError_FdwInvalidAttributeValue: string;\n    FdwError_FdwInvalidStringLengthOrBufferLength: string;\n    FdwError_FdwInvalidDescriptorFieldIdentifier: string;\n    PlpgsqlError_PlpgsqlError: string;\n    PlpgsqlError_RaiseException: string;\n    PlpgsqlError_NoDataFound: string;\n    PlpgsqlError_TooManyRows: string;\n    PlpgsqlError_AssertFailure: string;\n    InternalError_InternalError: string;\n    InternalError_DataCorrupted: string;\n    InternalError_IndexCorrupted: string;\n};\nexport {};\n","node_modules/@types/zapatos/db/shortcuts.d.ts":"import type { JSONSelectableForTable, WhereableForTable, InsertableForTable, UpdatableForTable, ColumnForTable, UniqueIndexForTable, SQLForTable, Table } from 'zapatos/schema';\nimport { AllType, SQLFragment } from './core';\nimport { NoInfer } from './utils';\nexport type JSONOnlyColsForTable<T extends Table, C extends any[]> = Pick<JSONSelectableForTable<T>, C[number]>;\nexport interface SQLFragmentMap {\n    [k: string]: SQLFragment<any>;\n}\nexport interface SQLFragmentOrColumnMap<T extends Table> {\n    [k: string]: SQLFragment<any> | ColumnForTable<T>;\n}\nexport type RunResultForSQLFragment<T extends SQLFragment<any, any>> = T extends SQLFragment<infer RunResult, any> ? (undefined extends RunResult ? NonNullable<RunResult> | null : RunResult) : never;\nexport type LateralResult<L extends SQLFragmentMap> = {\n    [K in keyof L]: RunResultForSQLFragment<L[K]>;\n};\nexport type ExtrasResult<T extends Table, E extends SQLFragmentOrColumnMap<T>> = {\n    [K in keyof E]: E[K] extends SQLFragment<any> ? RunResultForSQLFragment<E[K]> : E[K] extends keyof JSONSelectableForTable<T> ? JSONSelectableForTable<T>[E[K]] : never;\n};\ntype ExtrasOption<T extends Table> = SQLFragmentOrColumnMap<T> | undefined;\ntype ColumnsOption<T extends Table> = readonly ColumnForTable<T>[] | undefined;\ntype LimitedLateralOption = SQLFragmentMap | undefined;\ntype FullLateralOption = LimitedLateralOption | SQLFragment<any>;\ntype LateralOption<C extends ColumnsOption<Table>, E extends ExtrasOption<Table>> = undefined extends C ? undefined extends E ? FullLateralOption : LimitedLateralOption : LimitedLateralOption;\nexport interface ReturningOptionsForTable<T extends Table, C extends ColumnsOption<T>, E extends ExtrasOption<T>> {\n    returning?: C;\n    extras?: E;\n}\ntype ReturningTypeForTable<T extends Table, C extends ColumnsOption<T>, E extends ExtrasOption<T>> = (undefined extends C ? JSONSelectableForTable<T> : C extends ColumnForTable<T>[] ? JSONOnlyColsForTable<T, C> : never) & (undefined extends E ? {} : E extends SQLFragmentOrColumnMap<T> ? ExtrasResult<T, E> : never);\ninterface InsertSignatures {\n    <T extends Table, C extends ColumnsOption<T>, E extends ExtrasOption<T>>(table: T, values: InsertableForTable<T>, options?: ReturningOptionsForTable<T, C, E>): SQLFragment<ReturningTypeForTable<T, C, E>>;\n    <T extends Table, C extends ColumnsOption<T>, E extends ExtrasOption<T>>(table: T, values: InsertableForTable<T>[], options?: ReturningOptionsForTable<T, C, E>): SQLFragment<ReturningTypeForTable<T, C, E>[]>;\n}\n/**\n * Generate an `INSERT` query `SQLFragment`.\n * @param table The table into which to insert\n * @param values The `Insertable` values (or array thereof) to be inserted\n */\nexport declare const insert: InsertSignatures;\n/**\n * Wraps a unique index of the target table for use as the arbiter constraint\n * of an `upsert` shortcut query.\n */\nexport declare class Constraint<T extends Table> {\n    value: UniqueIndexForTable<T>;\n    constructor(value: UniqueIndexForTable<T>);\n}\n/**\n * Returns a `Constraint` instance, wrapping a unique index of the target table\n * for use as the arbiter constraint of an `upsert` shortcut query.\n */\nexport declare function constraint<T extends Table>(x: UniqueIndexForTable<T>): Constraint<T>;\nexport interface UpsertAction {\n    $action: 'INSERT' | 'UPDATE';\n}\ntype UpsertReportAction = 'suppress';\ntype UpsertReturnableForTable<T extends Table, C extends ColumnsOption<T>, E extends ExtrasOption<T>, RA extends UpsertReportAction | undefined> = ReturningTypeForTable<T, C, E> & (undefined extends RA ? UpsertAction : {});\ntype UpsertConflictTargetForTable<T extends Table> = Constraint<T> | ColumnForTable<T> | ColumnForTable<T>[];\ntype UpdateColumns<T extends Table> = ColumnForTable<T> | ColumnForTable<T>[];\ninterface UpsertOptions<T extends Table, C extends ColumnsOption<T>, E extends ExtrasOption<T>, UC extends UpdateColumns<T> | undefined, RA extends UpsertReportAction | undefined> extends ReturningOptionsForTable<T, C, E> {\n    updateValues?: UpdatableForTable<T>;\n    updateColumns?: UC;\n    noNullUpdateColumns?: ColumnForTable<T> | ColumnForTable<T>[];\n    reportAction?: RA;\n}\ninterface UpsertSignatures {\n    <T extends Table, C extends ColumnsOption<T>, E extends ExtrasOption<T>, UC extends UpdateColumns<T> | undefined, RA extends UpsertReportAction | undefined>(table: T, values: InsertableForTable<T>, conflictTarget: UpsertConflictTargetForTable<T>, options?: UpsertOptions<T, C, E, UC, RA>): SQLFragment<UpsertReturnableForTable<T, C, E, RA> | (UC extends never[] ? undefined : never)>;\n    <T extends Table, C extends ColumnsOption<T>, E extends ExtrasOption<T>, UC extends UpdateColumns<T> | undefined, RA extends UpsertReportAction | undefined>(table: T, values: InsertableForTable<T>[], conflictTarget: UpsertConflictTargetForTable<T>, options?: UpsertOptions<T, C, E, UC, RA>): SQLFragment<UpsertReturnableForTable<T, C, E, RA>[]>;\n}\nexport declare const doNothing: never[];\n/**\n * Generate an 'upsert' (`INSERT ... ON CONFLICT ...`) query `SQLFragment`.\n * @param table The table to update or insert into\n * @param values An `Insertable` of values (or an array thereof) to be inserted\n * or updated\n * @param conflictTarget A `UNIQUE`-indexed column (or array thereof) or a\n * `UNIQUE` index (wrapped in `db.constraint(...)`) that determines whether we\n * get an `UPDATE` (when there's a matching existing value) or an `INSERT`\n * (when there isn't)\n * @param options Optionally, an object with any of the keys `updateColumns`,\n * `noNullUpdateColumns` and `updateValues` (see documentation).\n */\nexport declare const upsert: UpsertSignatures;\ninterface UpdateSignatures {\n    <T extends Table, C extends ColumnsOption<T>, E extends ExtrasOption<T>>(table: T, values: UpdatableForTable<T>, where: WhereableForTable<T> | SQLFragment<any>, options?: ReturningOptionsForTable<T, C, E>): SQLFragment<ReturningTypeForTable<T, C, E>[]>;\n}\n/**\n * Generate an `UPDATE` query `SQLFragment`.\n * @param table The table to update\n * @param values An `Updatable` of the new values with which to update the table\n * @param where A `Whereable` (or `SQLFragment`) defining which rows to update\n */\nexport declare const update: UpdateSignatures;\nexport interface DeleteSignatures {\n    <T extends Table, C extends ColumnsOption<T>, E extends ExtrasOption<T>>(table: T, where: WhereableForTable<T> | SQLFragment<any>, options?: ReturningOptionsForTable<T, C, E>): SQLFragment<ReturningTypeForTable<T, C, E>[]>;\n}\n/**\n * Generate an `DELETE` query `SQLFragment` (plain 'delete' is a reserved word)\n * @param table The table to delete from\n * @param where A `Whereable` (or `SQLFragment`) defining which rows to delete\n */\nexport declare const deletes: DeleteSignatures;\ntype TruncateIdentityOpts = 'CONTINUE IDENTITY' | 'RESTART IDENTITY';\ntype TruncateForeignKeyOpts = 'RESTRICT' | 'CASCADE';\ninterface TruncateSignatures {\n    (table: Table | Table[]): SQLFragment<undefined>;\n    (table: Table | Table[], optId: TruncateIdentityOpts): SQLFragment<undefined>;\n    (table: Table | Table[], optFK: TruncateForeignKeyOpts): SQLFragment<undefined>;\n    (table: Table | Table[], optId: TruncateIdentityOpts, optFK: TruncateForeignKeyOpts): SQLFragment<undefined>;\n}\n/**\n * Generate a `TRUNCATE` query `SQLFragment`.\n * @param table The table (or array thereof) to truncate\n * @param opts Options: 'CONTINUE IDENTITY'/'RESTART IDENTITY' and/or\n * 'RESTRICT'/'CASCADE'\n */\nexport declare const truncate: TruncateSignatures;\ninterface OrderSpecForTable<T extends Table> {\n    by: SQLForTable<T>;\n    direction: 'ASC' | 'DESC';\n    nulls?: 'FIRST' | 'LAST';\n}\ntype Unprefixed<S extends string> = S extends `${infer _}.${infer Rest}` ? Rest : S;\nexport interface SelectLockingOptions<A extends string> {\n    for: 'UPDATE' | 'NO KEY UPDATE' | 'SHARE' | 'KEY SHARE';\n    of?: Unprefixed<Table> | A | (Unprefixed<Table> | A)[];\n    wait?: 'NOWAIT' | 'SKIP LOCKED';\n}\nexport interface SelectOptionsForTable<T extends Table, C extends ColumnsOption<T>, L extends LateralOption<C, E>, E extends ExtrasOption<T>, A extends string> {\n    distinct?: boolean | ColumnForTable<T> | ColumnForTable<T>[] | SQLFragment<any>;\n    order?: OrderSpecForTable<T> | OrderSpecForTable<T>[];\n    limit?: number;\n    offset?: number;\n    withTies?: boolean;\n    columns?: C;\n    extras?: E;\n    groupBy?: ColumnForTable<T> | ColumnForTable<T>[] | SQLFragment<any>;\n    having?: WhereableForTable<T> | SQLFragment<any>;\n    lateral?: L;\n    alias?: A;\n    lock?: SelectLockingOptions<NoInfer<A>> | SelectLockingOptions<NoInfer<A>>[];\n}\ntype SelectReturnTypeForTable<T extends Table, C extends ColumnsOption<T>, L extends LateralOption<C, E>, E extends ExtrasOption<T>> = (undefined extends L ? ReturningTypeForTable<T, C, E> : L extends SQLFragmentMap ? ReturningTypeForTable<T, C, E> & LateralResult<L> : L extends SQLFragment<any> ? RunResultForSQLFragment<L> : never);\nexport declare enum SelectResultMode {\n    Many = 0,\n    One = 1,\n    ExactlyOne = 2,\n    Numeric = 3\n}\nexport type FullSelectReturnTypeForTable<T extends Table, C extends ColumnsOption<T>, L extends LateralOption<C, E>, E extends ExtrasOption<T>, M extends SelectResultMode> = {\n    [SelectResultMode.Many]: SelectReturnTypeForTable<T, C, L, E>[];\n    [SelectResultMode.ExactlyOne]: SelectReturnTypeForTable<T, C, L, E>;\n    [SelectResultMode.One]: SelectReturnTypeForTable<T, C, L, E> | undefined;\n    [SelectResultMode.Numeric]: number;\n}[M];\nexport interface SelectSignatures {\n    <T extends Table, C extends ColumnsOption<T>, L extends LateralOption<C, E>, E extends ExtrasOption<T>, A extends string = never, M extends SelectResultMode = SelectResultMode.Many>(table: T, where: WhereableForTable<T> | SQLFragment<any> | AllType, options?: SelectOptionsForTable<T, C, L, E, A>, mode?: M, aggregate?: string): SQLFragment<FullSelectReturnTypeForTable<T, C, L, E, M>>;\n}\nexport declare class NotExactlyOneError extends Error {\n    query: SQLFragment;\n    constructor(query: SQLFragment, ...params: any[]);\n}\n/**\n * Generate a `SELECT` query `SQLFragment`. This can be nested with other\n * `select`/`selectOne`/`count` queries using the `lateral` option.\n * @param table The table to select from\n * @param where A `Whereable` or `SQLFragment` defining the rows to be selected,\n * or `all`\n * @param options Options object. Keys (all optional) are:\n * * `columns` — an array of column names: only these columns will be returned\n * * `order` – an array of `OrderSpec` objects, such as\n * `{ by: 'column', direction: 'ASC' }`\n * * `limit` and `offset` – numbers: apply this limit and offset to the query\n * * `lateral` — either an object mapping keys to nested `select`/`selectOne`/\n * `count` queries to be `LATERAL JOIN`ed, or a single `select`/`selectOne`/\n * `count` query whose result will be passed through directly as the result of\n * the containing query\n * * `alias` — table alias (string): required if using `lateral` to join a table\n * to itself\n * * `extras` — an object mapping key(s) to `SQLFragment`s, so that derived\n * quantities can be included in the JSON result\n * @param mode (Used internally by `selectOne` and `count`)\n */\nexport declare const select: SelectSignatures;\nexport interface SelectOneSignatures {\n    <T extends Table, C extends ColumnsOption<T>, L extends LateralOption<C, E>, E extends ExtrasOption<T>, A extends string>(table: T, where: WhereableForTable<T> | SQLFragment<any> | AllType, options?: SelectOptionsForTable<T, C, L, E, A>): SQLFragment<FullSelectReturnTypeForTable<T, C, L, E, SelectResultMode.One>>;\n}\n/**\n * Generate a `SELECT` query `SQLFragment` that returns only a single result (or\n * undefined). A `LIMIT 1` clause is added automatically. This can be nested with\n * other `select`/`selectOne`/`count` queries using the `lateral` option.\n * @param table The table to select from\n * @param where A `Whereable` or `SQLFragment` defining the rows to be selected,\n * or `all`\n * @param options Options object. See documentation for `select` for details.\n */\nexport declare const selectOne: SelectOneSignatures;\nexport interface SelectExactlyOneSignatures {\n    <T extends Table, C extends ColumnsOption<T>, L extends LateralOption<C, E>, E extends ExtrasOption<T>, A extends string>(table: T, where: WhereableForTable<T> | SQLFragment<any> | AllType, options?: SelectOptionsForTable<T, C, L, E, A>): SQLFragment<FullSelectReturnTypeForTable<T, C, L, E, SelectResultMode.ExactlyOne>>;\n}\n/**\n * Generate a `SELECT` query `SQLFragment` that returns a single result or\n * throws an error. A `LIMIT 1` clause is added automatically. This can be\n * nested with other `select`/`selectOne`/`count` queries using the `lateral`\n * option.\n * @param table The table to select from\n * @param where A `Whereable` or `SQLFragment` defining the rows to be selected,\n * or `all`\n * @param options Options object. See documentation for `select` for details.\n */\nexport declare const selectExactlyOne: SelectExactlyOneSignatures;\nexport interface NumericAggregateSignatures {\n    <T extends Table, C extends ColumnsOption<T>, L extends LateralOption<C, E>, E extends ExtrasOption<T>, A extends string>(table: T, where: WhereableForTable<T> | SQLFragment<any> | AllType, options?: SelectOptionsForTable<T, C, L, E, A>): SQLFragment<number>;\n}\n/**\n * Generate a `SELECT` query `SQLFragment` that returns a count. This can be\n * nested in other `select`/`selectOne` queries using their `lateral` option.\n * @param table The table to count from\n * @param where A `Whereable` or `SQLFragment` defining the rows to be counted,\n * or `all`\n * @param options Options object. Useful keys may be: `columns`, `alias`.\n */\nexport declare const count: NumericAggregateSignatures;\n/**\n * Generate a `SELECT` query `SQLFragment` that returns a sum. This can be\n * nested in other `select`/`selectOne` queries using their `lateral` option.\n * @param table The table to aggregate from\n * @param where A `Whereable` or `SQLFragment` defining the rows to be\n * aggregated, or `all`\n * @param options Options object. Useful keys may be: `columns`, `alias`.\n */\nexport declare const sum: NumericAggregateSignatures;\n/**\n * Generate a `SELECT` query `SQLFragment` that returns an arithmetic mean via\n * the `avg` aggregate function. This can be nested in other `select`/\n * `selectOne` queries using their `lateral` option.\n * @param table The table to aggregate from\n * @param where A `Whereable` or `SQLFragment` defining the rows to be\n * aggregated, or `all`\n * @param options Options object. Useful keys may be: `columns`, `alias`.\n */\nexport declare const avg: NumericAggregateSignatures;\n/**\n * Generate a `SELECT` query `SQLFragment` that returns a minimum via the `min`\n * aggregate function. This can be nested in other `select`/`selectOne` queries\n * using their `lateral` option.\n * @param table The table to aggregate from\n * @param where A `Whereable` or `SQLFragment` defining the rows to be\n * aggregated, or `all`\n * @param options Options object. Useful keys may be: `columns`, `alias`.\n */\nexport declare const min: NumericAggregateSignatures;\n/**\n * Generate a `SELECT` query `SQLFragment` that returns a maximum via the `max`\n * aggregate function. This can be nested in other `select`/`selectOne` queries\n * using their `lateral` option.\n * @param table The table to aggregate from\n * @param where A `Whereable` or `SQLFragment` defining the rows to be\n * aggregated, or `all`\n * @param options Options object. Useful keys may be: `columns`, `alias`.\n */\nexport declare const max: NumericAggregateSignatures;\nexport {};\n","node_modules/@types/zapatos/db/transaction.d.ts":"import * as pg from 'pg';\nimport type { Queryable } from './core';\nexport declare enum IsolationLevel {\n    Serializable = \"SERIALIZABLE\",\n    RepeatableRead = \"REPEATABLE READ\",\n    ReadCommitted = \"READ COMMITTED\",\n    SerializableRO = \"SERIALIZABLE, READ ONLY\",\n    RepeatableReadRO = \"REPEATABLE READ, READ ONLY\",\n    ReadCommittedRO = \"READ COMMITTED, READ ONLY\",\n    SerializableRODeferrable = \"SERIALIZABLE, READ ONLY, DEFERRABLE\"\n}\nexport type IsolationSatisfying<T extends IsolationLevel> = {\n    [IsolationLevel.Serializable]: IsolationLevel.Serializable;\n    [IsolationLevel.RepeatableRead]: IsolationSatisfying<IsolationLevel.Serializable> | IsolationLevel.RepeatableRead;\n    [IsolationLevel.ReadCommitted]: IsolationSatisfying<IsolationLevel.RepeatableRead> | IsolationLevel.ReadCommitted;\n    [IsolationLevel.SerializableRO]: IsolationSatisfying<IsolationLevel.Serializable> | IsolationLevel.SerializableRO;\n    [IsolationLevel.RepeatableReadRO]: IsolationSatisfying<IsolationLevel.SerializableRO> | IsolationSatisfying<IsolationLevel.RepeatableRead> | IsolationLevel.RepeatableReadRO;\n    [IsolationLevel.ReadCommittedRO]: IsolationSatisfying<IsolationLevel.RepeatableReadRO> | IsolationSatisfying<IsolationLevel.ReadCommitted> | IsolationLevel.ReadCommittedRO;\n    [IsolationLevel.SerializableRODeferrable]: IsolationSatisfying<IsolationLevel.SerializableRO> | IsolationLevel.SerializableRODeferrable;\n}[T];\nexport interface TxnClient<T extends IsolationLevel> extends pg.PoolClient {\n    _zapatos?: {\n        isolationLevel: T;\n        txnId: number;\n    };\n}\nexport type TxnClientForSerializable = TxnClient<IsolationSatisfying<IsolationLevel.Serializable>>;\nexport type TxnClientForRepeatableRead = TxnClient<IsolationSatisfying<IsolationLevel.RepeatableRead>>;\nexport type TxnClientForReadCommitted = TxnClient<IsolationSatisfying<IsolationLevel.ReadCommitted>>;\nexport type TxnClientForSerializableRO = TxnClient<IsolationSatisfying<IsolationLevel.SerializableRO>>;\nexport type TxnClientForRepeatableReadRO = TxnClient<IsolationSatisfying<IsolationLevel.RepeatableReadRO>>;\nexport type TxnClientForReadCommittedRO = TxnClient<IsolationSatisfying<IsolationLevel.ReadCommittedRO>>;\nexport type TxnClientForSerializableRODeferrable = TxnClient<IsolationSatisfying<IsolationLevel.SerializableRODeferrable>>;\n/**\n * Provide a database client to the callback, whose queries are then wrapped in\n * a database transaction. The transaction is committed, retried, or rolled back\n * as appropriate.\n * @param txnClientOrQueryable The `pg.Pool` from which to check out a client,\n * a plain client, or an existing transaction client to be passed through\n * @param isolationLevel The desired isolation level (e.g.\n * `IsolationLevel.Serializable`)\n * @param callback A callback function that runs queries on the client provided\n * to it\n */\nexport declare function transaction<T, M extends IsolationLevel>(txnClientOrQueryable: Queryable | TxnClient<IsolationSatisfying<M>>, isolationLevel: M, callback: (client: TxnClient<IsolationSatisfying<M>>) => Promise<T>): Promise<T>;\n/**\n * Shortcut for `transaction` with isolation level `Serializable`.\n * @param txnClientOrQueryable The `pg.Pool` from which to check out a client,\n * a plain client, or an existing transaction client to be passed through\n * @param callback A callback function that runs queries on the client provided\n * to it\n */\nexport declare function serializable<T>(txnClientOrQueryable: Queryable | TxnClientForSerializable, callback: (client: TxnClientForSerializable) => Promise<T>): Promise<T>;\n/**\n * Shortcut for `transaction` with isolation level `RepeatableRead`.\n * @param txnClientOrQueryable The `pg.Pool` from which to check out a client,\n * a plain client, or an existing transaction client to be passed through\n * @param callback A callback function that runs queries on the client provided\n * to it\n */\nexport declare function repeatableRead<T>(txnClientOrQueryable: Queryable | TxnClientForRepeatableRead, callback: (client: TxnClientForRepeatableRead) => Promise<T>): Promise<T>;\n/**\n * Shortcut for `transaction` with isolation level `ReadCommitted`.\n * @param txnClientOrQueryable The `pg.Pool` from which to check out a client,\n * a plain client, or an existing transaction client to be passed through\n * @param callback A callback function that runs queries on the client provided\n * to it\n */\nexport declare function readCommitted<T>(txnClientOrQueryable: Queryable | TxnClientForReadCommitted, callback: (client: TxnClientForReadCommitted) => Promise<T>): Promise<T>;\n/**\n * Shortcut for `transaction` with isolation level `SerializableRO`.\n * @param txnClientOrQueryable The `pg.Pool` from which to check out a client,\n * a plain client, or an existing transaction client to be passed through\n * @param callback A callback function that runs queries on the client provided\n * to it\n */\nexport declare function serializableRO<T>(txnClientOrQueryable: Queryable | TxnClientForSerializableRO, callback: (client: TxnClientForSerializableRO) => Promise<T>): Promise<T>;\n/**\n * Shortcut for `transaction` with isolation level `RepeatableReadRO`.\n * @param txnClientOrQueryable The `pg.Pool` from which to check out a client,\n * a plain client, or an existing transaction client to be passed through\n * @param callback A callback function that runs queries on the client provided\n * to it\n */\nexport declare function repeatableReadRO<T>(txnClientOrQueryable: Queryable | TxnClientForRepeatableReadRO, callback: (client: TxnClientForRepeatableReadRO) => Promise<T>): Promise<T>;\n/**\n * Shortcut for `transaction` with isolation level `ReadCommittedRO`.\n * @param txnClientOrQueryable The `pg.Pool` from which to check out a client,\n * a plain client, or an existing transaction client to be passed through\n * @param callback A callback function that runs queries on the client provided\n * to it\n */\nexport declare function readCommittedRO<T>(txnClientOrQueryable: Queryable | TxnClientForReadCommittedRO, callback: (client: TxnClientForReadCommittedRO) => Promise<T>): Promise<T>;\n/**\n * Shortcut for `transaction` with isolation level `SerializableRODeferrable`.\n * @param txnClientOrQueryable The `pg.Pool` from which to check out a client,\n * a plain client, or an existing transaction client to be passed through\n * @param callback A callback function that runs queries on the client provided\n * to it\n */\nexport declare function serializableRODeferrable<T>(txnClientOrQueryable: Queryable | TxnClientForSerializableRODeferrable, callback: (client: TxnClientForSerializableRODeferrable) => Promise<T>): Promise<T>;\n","node_modules/@types/zapatos/db/utils.d.ts":"export type NoInfer<T> = [T][T extends any ? 0 : never];\n/**\n * Basic zero-padding for small, positive integers\n * @param n The integer to pad\n * @param pad The minimum desired output string length: 2, 3 or 4\n */\nexport declare const pad: (n: number, pad?: 2 | 3 | 4) => string;\n/**\n * Simple promisification of setTimeout.\n * @param delayMs Time to wait, in milliseconds\n */\nexport declare const wait: (delayMs: number) => Promise<unknown>;\n/**\n * Map an input array to an output array, interspersing a constant separator value\n * between the mapped values.\n * @param arr Input array\n * @param separator Separator value\n * @param cb Mapping function\n */\nexport declare const mapWithSeparator: <TIn, TSep, TOut>(arr: readonly TIn[], separator: TSep, cb: (x: TIn, i: number, a: readonly TIn[]) => TOut) => (TSep | TOut)[];\n/**\n * Map an array of objects to an output array by taking the union of all objects' keys\n * and ensuring that any key not present on any object gets a default value.\n *\n * `e.g. [{ x: 1 }, { y: 2 }] => [{ x: 1, y: defaultValue }, { x: defaultValue, y: 2}]`\n * @param objs The array of objects\n * @param defaultValue The default value to assign to missing keys for each object\n */\nexport declare const completeKeysWithDefaultValue: <T extends object>(objs: T[], defaultValue: any) => T[];\n/**\n * Test that a value is a Plain Old JavaScript Object (such as one created by an object\n * literal, e.g. `{x: 1, y: 2}`)\n * @param x The value to test\n */\nexport declare const isPOJO: (x: any) => boolean;\n","node_modules/@types/zapatos/generate/cli.d.ts":"#!/usr/bin/env node\nexport {};\n","node_modules/@types/zapatos/generate/config.d.ts":"import type * as pg from 'pg';\nexport interface RequiredConfig {\n}\nexport interface OptionalConfig {\n    db: pg.ClientConfig;\n    outDir: string;\n    outExt: string;\n    schemas: SchemaRules;\n    debugListener: boolean | ((s: string) => void);\n    progressListener: boolean | ((s: string) => void);\n    warningListener: boolean | ((s: string) => void);\n    customTypesTransform: 'PgMy_type' | 'my_type' | 'PgMyType' | ((s: string) => string);\n    columnOptions: ColumnOptions;\n    schemaJSDoc: boolean;\n    unprefixedSchema: string | null;\n    customJSONParsingForLargeNumbers: boolean;\n}\ninterface SchemaRules {\n    [schema: string]: {\n        include: '*' | string[];\n        exclude: '*' | string[];\n    };\n}\ninterface ColumnOptions {\n    [k: string]: {\n        [k: string]: {\n            insert?: 'auto' | 'excluded' | 'optional';\n            update?: 'auto' | 'excluded';\n        };\n    };\n}\nexport type Config = RequiredConfig & Partial<OptionalConfig>;\nexport type CompleteConfig = RequiredConfig & OptionalConfig;\nexport declare const moduleRoot: () => string;\nexport declare const finaliseConfig: (config: Config) => CompleteConfig;\nexport {};\n","node_modules/@types/zapatos/generate/enums.d.ts":"import * as pg from 'pg';\nexport type EnumData = {\n    [k: string]: string[];\n};\nexport declare const enumDataForSchema: (schemaName: string, queryFn: (q: pg.QueryConfig) => Promise<pg.QueryResult<any>>) => Promise<EnumData>;\nexport declare const enumTypesForEnumData: (enums: EnumData) => string;\n","node_modules/@types/zapatos/generate/header.d.ts":"export declare const header: () => string;\n","node_modules/@types/zapatos/generate/index.d.ts":"export * from './config';\nexport * from './enums';\nexport * from './pgTypes';\nexport * from './tables';\nexport * from './tsOutput';\nexport * from './write';\n","node_modules/@types/zapatos/generate/legacy.d.ts":"import { CompleteConfig } from \"./config\";\nexport declare function srcWarning(config: CompleteConfig): void;\n","node_modules/@types/zapatos/generate/pgTypes.d.ts":"import type { CompleteConfig } from './config';\nimport type { EnumData } from './enums';\ntype TypeContext = 'JSONSelectable' | 'Selectable' | 'Insertable' | 'Updatable' | 'Whereable';\nexport declare const tsTypeForPgType: (pgType: string, enums: EnumData, context: TypeContext, config: CompleteConfig) => string;\nexport {};\n","node_modules/@types/zapatos/generate/tables.d.ts":"import * as pg from 'pg';\nimport type { EnumData } from './enums';\nimport type { CustomTypes } from './tsOutput';\nimport { CompleteConfig } from './config';\nexport interface Relation {\n    schema: string;\n    name: string;\n    type: 'table' | 'view' | 'fdw' | 'mview';\n    insertable: boolean;\n}\nexport declare const relationsInSchema: (schemaName: string, queryFn: (q: pg.QueryConfig) => Promise<pg.QueryResult<any>>) => Promise<Relation[]>;\nexport declare const definitionForRelationInSchema: (rel: Relation, schemaName: string, enums: EnumData, customTypes: CustomTypes, config: CompleteConfig, queryFn: (q: pg.QueryConfig) => Promise<pg.QueryResult<any>>) => Promise<string>;\nexport declare const crossTableTypesForTables: (tables: Relation[]) => string;\nexport declare const crossSchemaTypesForAllTables: (allTables: Relation[], unprefixedSchema: string | null) => string;\nexport declare const crossSchemaTypesForSchemas: (schemas: string[]) => string;\n","node_modules/@types/zapatos/generate/tsOutput.d.ts":"import type { CompleteConfig } from './config';\nexport interface CustomTypes {\n    [name: string]: string;\n}\nexport declare const tsForConfig: (config: CompleteConfig, debug: (s: string) => void) => Promise<{\n    ts: string;\n    customTypeSourceFiles: {\n        [k: string]: string;\n    };\n}>;\n","node_modules/@types/zapatos/generate/write.d.ts":"import { Config } from './config';\n/**\n * Generate a schema and supporting files and folders given a configuration.\n * @param suppliedConfig An object approximately matching `zapatosconfig.json`.\n */\nexport declare const generate: (suppliedConfig: Config) => Promise<void>;\n","node_modules/@types/pg/index.d.ts":"/// <reference types=\"node\" />\n\nimport events = require(\"events\");\nimport stream = require(\"stream\");\nimport pgTypes = require(\"pg-types\");\nimport { NoticeMessage } from \"pg-protocol/dist/messages\";\n\nimport { ConnectionOptions } from \"tls\";\n\nexport interface ClientConfig {\n    user?: string | undefined;\n    database?: string | undefined;\n    password?: string | (() => string | Promise<string>) | undefined;\n    port?: number | undefined;\n    host?: string | undefined;\n    connectionString?: string | undefined;\n    keepAlive?: boolean | undefined;\n    stream?: () => stream.Duplex | stream.Duplex | undefined;\n    statement_timeout?: false | number | undefined;\n    ssl?: boolean | ConnectionOptions | undefined;\n    query_timeout?: number | undefined;\n    keepAliveInitialDelayMillis?: number | undefined;\n    idle_in_transaction_session_timeout?: number | undefined;\n    application_name?: string | undefined;\n    connectionTimeoutMillis?: number | undefined;\n    types?: CustomTypesConfig | undefined;\n    options?: string | undefined;\n}\n\nexport type ConnectionConfig = ClientConfig;\n\nexport interface Defaults extends ClientConfig {\n    poolSize?: number | undefined;\n    poolIdleTimeout?: number | undefined;\n    reapIntervalMillis?: number | undefined;\n    binary?: boolean | undefined;\n    parseInt8?: boolean | undefined;\n    parseInputDatesAsUTC?: boolean | undefined;\n}\n\nexport interface PoolConfig extends ClientConfig {\n    // properties from module 'node-pool'\n    max?: number | undefined;\n    min?: number | undefined;\n    idleTimeoutMillis?: number | undefined;\n    log?: ((...messages: any[]) => void) | undefined;\n    Promise?: PromiseConstructorLike | undefined;\n    allowExitOnIdle?: boolean | undefined;\n    maxUses?: number | undefined;\n}\n\nexport interface QueryConfig<I extends any[] = any[]> {\n    name?: string | undefined;\n    text: string;\n    values?: I | undefined;\n    types?: CustomTypesConfig | undefined;\n}\n\nexport interface CustomTypesConfig {\n    getTypeParser: typeof pgTypes.getTypeParser;\n}\n\nexport interface Submittable {\n    submit: (connection: Connection) => void;\n}\n\nexport interface QueryArrayConfig<I extends any[] = any[]> extends QueryConfig<I> {\n    rowMode: \"array\";\n}\n\nexport interface FieldDef {\n    name: string;\n    tableID: number;\n    columnID: number;\n    dataTypeID: number;\n    dataTypeSize: number;\n    dataTypeModifier: number;\n    format: string;\n}\n\nexport interface QueryResultBase {\n    command: string;\n    rowCount: number | null;\n    oid: number;\n    fields: FieldDef[];\n}\n\nexport interface QueryResultRow {\n    [column: string]: any;\n}\n\nexport interface QueryResult<R extends QueryResultRow = any> extends QueryResultBase {\n    rows: R[];\n}\n\nexport interface QueryArrayResult<R extends any[] = any[]> extends QueryResultBase {\n    rows: R[];\n}\n\nexport interface Notification {\n    processId: number;\n    channel: string;\n    payload?: string | undefined;\n}\n\nexport interface ResultBuilder<R extends QueryResultRow = any> extends QueryResult<R> {\n    addRow(row: R): void;\n}\n\nexport interface QueryParse {\n    name: string;\n    text: string;\n    types: string[];\n}\n\ntype ValueMapper = (param: any, index: number) => any;\n\nexport interface BindConfig {\n    portal?: string | undefined;\n    statement?: string | undefined;\n    binary?: string | undefined;\n    values?: Array<Buffer | null | undefined | string> | undefined;\n    valueMapper?: ValueMapper | undefined;\n}\n\nexport interface ExecuteConfig {\n    portal?: string | undefined;\n    rows?: string | undefined;\n}\n\nexport interface MessageConfig {\n    type: string;\n    name?: string | undefined;\n}\n\nexport class Connection extends events.EventEmitter {\n    readonly stream: stream.Duplex;\n\n    constructor(config?: ConnectionConfig);\n\n    bind(config: BindConfig | null, more: boolean): void;\n    execute(config: ExecuteConfig | null, more: boolean): void;\n    parse(query: QueryParse, more: boolean): void;\n\n    query(text: string): void;\n\n    describe(msg: MessageConfig, more: boolean): void;\n    close(msg: MessageConfig, more: boolean): void;\n\n    flush(): void;\n    sync(): void;\n    end(): void;\n}\n\n/**\n * {@link https://node-postgres.com/api/pool}\n */\nexport class Pool extends events.EventEmitter {\n    /**\n     * Every field of the config object is entirely optional.\n     * The config passed to the pool is also passed to every client\n     * instance within the pool when the pool creates that client.\n     */\n    constructor(config?: PoolConfig);\n\n    readonly totalCount: number;\n    readonly idleCount: number;\n    readonly waitingCount: number;\n\n    connect(): Promise<PoolClient>;\n    connect(\n        callback: (err: Error | undefined, client: PoolClient | undefined, done: (release?: any) => void) => void,\n    ): void;\n\n    end(): Promise<void>;\n    end(callback: () => void): void;\n\n    query<T extends Submittable>(queryStream: T): T;\n    // tslint:disable:no-unnecessary-generics\n    query<R extends any[] = any[], I extends any[] = any[]>(\n        queryConfig: QueryArrayConfig<I>,\n        values?: I,\n    ): Promise<QueryArrayResult<R>>;\n    query<R extends QueryResultRow = any, I extends any[] = any[]>(\n        queryConfig: QueryConfig<I>,\n    ): Promise<QueryResult<R>>;\n    query<R extends QueryResultRow = any, I extends any[] = any[]>(\n        queryTextOrConfig: string | QueryConfig<I>,\n        values?: I,\n    ): Promise<QueryResult<R>>;\n    query<R extends any[] = any[], I extends any[] = any[]>(\n        queryConfig: QueryArrayConfig<I>,\n        callback: (err: Error, result: QueryArrayResult<R>) => void,\n    ): void;\n    query<R extends QueryResultRow = any, I extends any[] = any[]>(\n        queryTextOrConfig: string | QueryConfig<I>,\n        callback: (err: Error, result: QueryResult<R>) => void,\n    ): void;\n    query<R extends QueryResultRow = any, I extends any[] = any[]>(\n        queryText: string,\n        values: I,\n        callback: (err: Error, result: QueryResult<R>) => void,\n    ): void;\n    // tslint:enable:no-unnecessary-generics\n\n    on(event: \"release\" | \"error\", listener: (err: Error, client: PoolClient) => void): this;\n    on(event: \"connect\" | \"acquire\" | \"remove\", listener: (client: PoolClient) => void): this;\n}\n\nexport class ClientBase extends events.EventEmitter {\n    constructor(config?: string | ClientConfig);\n\n    connect(): Promise<void>;\n    connect(callback: (err: Error) => void): void;\n\n    query<T extends Submittable>(queryStream: T): T;\n    // tslint:disable:no-unnecessary-generics\n    query<R extends any[] = any[], I extends any[] = any[]>(\n        queryConfig: QueryArrayConfig<I>,\n        values?: I,\n    ): Promise<QueryArrayResult<R>>;\n    query<R extends QueryResultRow = any, I extends any[] = any[]>(\n        queryConfig: QueryConfig<I>,\n    ): Promise<QueryResult<R>>;\n    query<R extends QueryResultRow = any, I extends any[] = any[]>(\n        queryTextOrConfig: string | QueryConfig<I>,\n        values?: I,\n    ): Promise<QueryResult<R>>;\n    query<R extends any[] = any[], I extends any[] = any[]>(\n        queryConfig: QueryArrayConfig<I>,\n        callback: (err: Error, result: QueryArrayResult<R>) => void,\n    ): void;\n    query<R extends QueryResultRow = any, I extends any[] = any[]>(\n        queryTextOrConfig: string | QueryConfig<I>,\n        callback: (err: Error, result: QueryResult<R>) => void,\n    ): void;\n    query<R extends QueryResultRow = any, I extends any[] = any[]>(\n        queryText: string,\n        values: any[],\n        callback: (err: Error, result: QueryResult<R>) => void,\n    ): void;\n    // tslint:enable:no-unnecessary-generics\n\n    copyFrom(queryText: string): stream.Writable;\n    copyTo(queryText: string): stream.Readable;\n\n    pauseDrain(): void;\n    resumeDrain(): void;\n\n    escapeIdentifier(str: string): string;\n    escapeLiteral(str: string): string;\n\n    on(event: \"drain\", listener: () => void): this;\n    on(event: \"error\", listener: (err: Error) => void): this;\n    on(event: \"notice\", listener: (notice: NoticeMessage) => void): this;\n    on(event: \"notification\", listener: (message: Notification) => void): this;\n    // tslint:disable-next-line unified-signatures\n    on(event: \"end\", listener: () => void): this;\n}\n\nexport class Client extends ClientBase {\n    user?: string | undefined;\n    database?: string | undefined;\n    port: number;\n    host: string;\n    password?: string | undefined;\n    ssl: boolean;\n\n    constructor(config?: string | ClientConfig);\n\n    end(): Promise<void>;\n    end(callback: (err: Error) => void): void;\n}\n\nexport interface PoolClient extends ClientBase {\n    release(err?: Error | boolean): void;\n}\n\nexport class Query<R extends QueryResultRow = any, I extends any[] = any> extends events.EventEmitter\n    implements Submittable\n{\n    constructor(queryTextOrConfig?: string | QueryConfig<I>, values?: I);\n    submit: (connection: Connection) => void;\n    on(event: \"row\", listener: (row: R, result?: ResultBuilder<R>) => void): this;\n    on(event: \"error\", listener: (err: Error) => void): this;\n    on(event: \"end\", listener: (result: ResultBuilder<R>) => void): this;\n}\n\nexport class Events extends events.EventEmitter {\n    on(event: \"error\", listener: (err: Error, client: Client) => void): this;\n}\n\nexport const types: typeof pgTypes;\n\nexport const defaults: Defaults & ClientConfig;\n\nimport * as Pg from \".\";\n\nexport const native: typeof Pg | null;\n\nexport { DatabaseError } from \"pg-protocol\";\n","node_modules/@types/pg/lib/type-overrides.d.ts":"import { CustomTypesConfig } from \"..\";\n\ndeclare enum builtins {\n    BOOL = 16,\n    BYTEA = 17,\n    CHAR = 18,\n    INT8 = 20,\n    INT2 = 21,\n    INT4 = 23,\n    REGPROC = 24,\n    TEXT = 25,\n    OID = 26,\n    TID = 27,\n    XID = 28,\n    CID = 29,\n    JSON = 114,\n    XML = 142,\n    PG_NODE_TREE = 194,\n    SMGR = 210,\n    PATH = 602,\n    POLYGON = 604,\n    CIDR = 650,\n    FLOAT4 = 700,\n    FLOAT8 = 701,\n    ABSTIME = 702,\n    RELTIME = 703,\n    TINTERVAL = 704,\n    CIRCLE = 718,\n    MACADDR8 = 774,\n    MONEY = 790,\n    MACADDR = 829,\n    INET = 869,\n    ACLITEM = 1033,\n    BPCHAR = 1042,\n    VARCHAR = 1043,\n    DATE = 1082,\n    TIME = 1083,\n    TIMESTAMP = 1114,\n    TIMESTAMPTZ = 1184,\n    INTERVAL = 1186,\n    TIMETZ = 1266,\n    BIT = 1560,\n    VARBIT = 1562,\n    NUMERIC = 1700,\n    REFCURSOR = 1790,\n    REGPROCEDURE = 2202,\n    REGOPER = 2203,\n    REGOPERATOR = 2204,\n    REGCLASS = 2205,\n    REGTYPE = 2206,\n    UUID = 2950,\n    TXID_SNAPSHOT = 2970,\n    PG_LSN = 3220,\n    PG_NDISTINCT = 3361,\n    PG_DEPENDENCIES = 3402,\n    TSVECTOR = 3614,\n    TSQUERY = 3615,\n    GTSVECTOR = 3642,\n    REGCONFIG = 3734,\n    REGDICTIONARY = 3769,\n    JSONB = 3802,\n    REGNAMESPACE = 4089,\n    REGROLE = 4096,\n}\ntype TypeId = builtins;\ntype TypeParser<I extends (string | Buffer), T> = (value: I) => T;\n\nexport = TypeOverrides;\ndeclare class TypeOverrides implements CustomTypesConfig {\n    constructor(types?: CustomTypesConfig);\n    setTypeParser<T>(oid: number | TypeId, parseFn: TypeParser<string, T>): void;\n    setTypeParser<T>(oid: number | TypeId, format: \"text\", parseFn: TypeParser<string, T>): void;\n    setTypeParser<T>(oid: number | TypeId, format: \"binary\", parseFn: TypeParser<Buffer, T>): void;\n\n    getTypeParser<T>(oid: number | TypeId, format?: \"text\"): TypeParser<string, T | string>;\n    getTypeParser<T>(oid: number | TypeId, format: \"binary\"): TypeParser<Buffer, T | string>;\n}\n","node_modules/@types/luxon/index.d.ts":"// Type definitions for luxon 2.4\n// Project: https://github.com/moment/luxon#readme\n// Definitions by: Colby DeHart <https://github.com/colbydehart>\n//                 Hyeonseok Yang <https://github.com/FourwingsY>\n//                 Jonathan Siebern <https://github.com/jsiebern>\n//                 Matt R. Wilson <https://github.com/mastermatt>\n//                 Pietro Vismara <https://github.com/pietrovismara>\n//                 Janeene Beeforth <https://github.com/dawnmist>\n//                 Jason Yu <https://github.com/ycmjason>\n//                 Aitor Pérez Rodal <https://github.com/Aitor1995>\n//                 Piotr Błażejewicz <https://github.com/peterblazejewicz>\n//                 Carson Full <https://github.com/carsonf>\n//                 Hugo Silva <https://github.com/hugofpsilva>\n//                 Martin Badin <https://github.com/martin-badin>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n\nexport * from './src/luxon';\n\nexport as namespace luxon;\n","node_modules/@types/luxon/src/datetime.d.ts":"import {\n    CalendarSystem,\n    DateTimeFormatOptions,\n    NumberingSystem,\n    StringUnitLength,\n    ToISOFormat,\n    ToISOTimeDurationOptions,\n    ZoneOptions,\n} from '../index';\nimport { Zone } from './zone';\nimport { Duration, DurationLike, DurationUnits } from './duration';\nimport { Interval } from './interval';\n\nexport type DateTimeUnit = 'year' | 'quarter' | 'month' | 'week' | 'day' | 'hour' | 'minute' | 'second' | 'millisecond';\nexport type ToRelativeUnit = 'years' | 'quarters' | 'months' | 'weeks' | 'days' | 'hours' | 'minutes' | 'seconds';\n\nexport type MonthNumbers = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12;\nexport type WeekdayNumbers = 1 | 2 | 3 | 4 | 5 | 6 | 7;\n\nexport type DayNumbers =\n    | 1\n    | 2\n    | 3\n    | 4\n    | 5\n    | 6\n    | 7\n    | 8\n    | 9\n    | 10\n    | 11\n    | 12\n    | 13\n    | 14\n    | 15\n    | 16\n    | 17\n    | 18\n    | 19\n    | 20\n    | 21\n    | 22\n    | 23\n    | 24\n    | 25\n    | 26\n    | 27\n    | 28\n    | 29\n    | 30\n    | 31;\n\nexport type SecondNumbers =\n    | 0\n    | 1\n    | 2\n    | 3\n    | 4\n    | 5\n    | 6\n    | 7\n    | 8\n    | 9\n    | 10\n    | 11\n    | 12\n    | 13\n    | 14\n    | 15\n    | 16\n    | 17\n    | 18\n    | 19\n    | 20\n    | 21\n    | 22\n    | 23\n    | 24\n    | 25\n    | 26\n    | 27\n    | 28\n    | 29\n    | 30\n    | 31\n    | 32\n    | 33\n    | 34\n    | 35\n    | 36\n    | 37\n    | 38\n    | 39\n    | 40\n    | 41\n    | 42\n    | 43\n    | 44\n    | 45\n    | 46\n    | 47\n    | 48\n    | 49\n    | 50\n    | 51\n    | 52\n    | 53\n    | 54\n    | 55\n    | 56\n    | 57\n    | 58\n    | 59;\n\nexport type MinuteNumbers = SecondNumbers;\n\nexport type HourNumbers =\n    | 0\n    | 1\n    | 2\n    | 3\n    | 4\n    | 5\n    | 6\n    | 7\n    | 8\n    | 9\n    | 10\n    | 11\n    | 12\n    | 13\n    | 14\n    | 15\n    | 16\n    | 17\n    | 18\n    | 19\n    | 20\n    | 21\n    | 22\n    | 23;\n\nexport type WeekNumbers =\n    | 1\n    | 2\n    | 3\n    | 4\n    | 5\n    | 6\n    | 7\n    | 8\n    | 9\n    | 10\n    | 11\n    | 12\n    | 13\n    | 14\n    | 15\n    | 16\n    | 17\n    | 18\n    | 19\n    | 20\n    | 21\n    | 22\n    | 23\n    | 24\n    | 25\n    | 26\n    | 27\n    | 28\n    | 29\n    | 30\n    | 31\n    | 32\n    | 33\n    | 34\n    | 35\n    | 36\n    | 37\n    | 38\n    | 39\n    | 40\n    | 41\n    | 42\n    | 43\n    | 44\n    | 45\n    | 46\n    | 47\n    | 48\n    | 49\n    | 50\n    | 51\n    | 52\n    | 53;\n\nexport type QuarterNumbers = 1 | 2 | 3 | 4;\n\nexport type PossibleDaysInMonth = 28 | 29 | 30 | 31;\nexport type PossibleDaysInYear = 365 | 366;\nexport type PossibleWeeksInYear = 52 | 53;\n\nexport interface ToObjectOutput extends DateTimeJSOptions {\n    year: number;\n    month: number;\n    day: number;\n    hour: number;\n    minute: number;\n    second: number;\n    millisecond: number;\n}\n\nexport interface ToRelativeOptions extends Omit<ToRelativeCalendarOptions, 'unit'> {\n    /**\n     * @default long\n     */\n    style?: StringUnitLength | undefined;\n    /** @default true */\n    round?: boolean | undefined;\n    /**\n     * Padding in milliseconds. This allows you to round up the result if it fits inside the threshold.\n     * Don't use in combination with {round: false} because the decimal output will include the padding.\n     * @default 0\n     */\n    padding?: number | undefined;\n    /**\n     * A single unit or an array of units. If an array is supplied, the method will pick the best one\n     * to use from the array. If omitted, the method will pick the unit from a default set.\n     */\n    unit?: ToRelativeUnit | ToRelativeUnit[] | undefined;\n}\n\nexport interface ToRelativeCalendarOptions {\n    /**\n     * The DateTime to use as the basis to which this time is compared\n     * @default now\n     */\n    base?: DateTime | undefined;\n    /**\n     * Override the locale of this DateTime\n     */\n    locale?: string | undefined;\n    /** If omitted, the method will pick the unit. */\n    unit?: ToRelativeUnit | undefined;\n    /**\n     * Override the numberingSystem of this DateTime.\n     * The Intl system may choose not to honor this.\n     */\n    numberingSystem?: NumberingSystem | undefined;\n}\n\nexport interface ToSQLOptions {\n    /**\n     * Include the offset, such as 'Z' or '-04:00'\n     * @default true\n     */\n    includeOffset?: boolean | undefined;\n    /**\n     * Include the zone, such as 'America/New_York'. Overrides includeOffset.\n     * @default false\n     */\n    includeZone?: boolean | undefined;\n    /**\n     * include the space between the time and the offset, such as '05:15:16.345 -04:00'\n     * @default true\n     */\n    includeOffsetSpace?: boolean;\n}\n\nexport interface ToISODateOptions {\n    /**\n     * Choose between the basic and extended format\n     * @default 'extended'\n     */\n    format?: ToISOFormat | undefined;\n}\n\nexport interface ToISOTimeOptions extends ToISOTimeDurationOptions {\n    /**\n     * Include the offset, such as 'Z' or '-04:00'\n     * @default true\n     */\n    includeOffset?: boolean | undefined;\n\n    /**\n     * add the time zone format extension\n     * @default false\n     */\n    extendedZone?: boolean | undefined;\n}\n\n/** @deprecated alias for backwards compatibility */\nexport type ISOTimeOptions = ToISOTimeOptions;\n\nexport interface LocaleOptions {\n    /**\n     * @default system's locale\n     */\n    locale?: string | undefined;\n    outputCalendar?: CalendarSystem | undefined;\n    numberingSystem?: NumberingSystem | undefined;\n}\n\nexport type ResolvedLocaleOptions = Required<LocaleOptions>;\n\nexport interface DateTimeOptions extends LocaleOptions {\n    /**\n     * Use this zone if no offset is specified in the input string itself. Will also convert the time to this zone.\n     * @default local\n     */\n    zone?: string | Zone | undefined;\n    /**\n     * Override the zone with a fixed-offset zone specified in the string itself, if it specifies one.\n     * @default false\n     */\n    setZone?: boolean | undefined;\n}\n\nexport type DateTimeJSOptions = Omit<DateTimeOptions, 'setZone'>;\n\nexport interface DateObjectUnits {\n    // a year, such as 1987\n    year?: number | undefined;\n    // a month, 1-12\n    month?: number | undefined;\n    // a day of the month, 1-31, depending on the month\n    day?: number | undefined;\n    // day of the year, 1-365 or 366\n    ordinal?: number | undefined;\n    // an ISO week year\n    weekYear?: number | undefined;\n    // an ISO week number, between 1 and 52 or 53, depending on the year\n    weekNumber?: number | undefined;\n    // an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday\n    weekday?: number | undefined;\n    // hour of the day, 0-23\n    hour?: number | undefined;\n    // minute of the hour, 0-59\n    minute?: number | undefined;\n    // second of the minute, 0-59\n    second?: number | undefined;\n    // millisecond of the second, 0-999\n    millisecond?: number | undefined;\n}\n\nexport type ConversionAccuracy = 'casual' | 'longterm';\n\n/**\n * @deprecated You should use Intl.DateTimeFormatOptions' fields and values instead.\n */\nexport type DateTimeFormatPresetValue = 'numeric' | 'short' | 'long';\n/**\n * @deprecated Use Intl.DateTimeFormatOptions instead.\n */\nexport type DateTimeFormatPreset = Intl.DateTimeFormatOptions;\n\nexport interface DiffOptions {\n    conversionAccuracy?: ConversionAccuracy | undefined;\n}\n\nexport interface ExplainedFormat {\n    input: string;\n    tokens: Array<{ literal: boolean; val: string }>;\n    regex?: RegExp | undefined;\n    rawMatches?: RegExpMatchArray | null | undefined;\n    matches?: { [k: string]: any } | undefined;\n    result?: { [k: string]: any } | null | undefined;\n    zone?: Zone | null | undefined;\n    invalidReason?: string | undefined;\n}\n\n/**\n * A DateTime is an immutable data structure representing a specific date and time and accompanying methods.\n * It contains class and instance methods for creating, parsing, interrogating, transforming, and formatting them.\n *\n * A DateTime comprises of:\n * * A timestamp. Each DateTime instance refers to a specific millisecond of the Unix epoch.\n * * A time zone. Each instance is considered in the context of a specific zone (by default the local system's zone).\n * * Configuration properties that effect how output strings are formatted, such as `locale`, `numberingSystem`, and `outputCalendar`.\n *\n * Here is a brief overview of the most commonly used functionality it provides:\n *\n * * **Creation**: To create a DateTime from its components, use one of its factory class methods: {@link DateTime.local}, {@link DateTime.utc}, and (most flexibly) {@link DateTime.fromObject}.\n * To create one from a standard string format, use {@link DateTime.fromISO}, {@link DateTime.fromHTTP}, and {@link DateTime.fromRFC2822}.\n * To create one from a custom string format, use {@link DateTime.fromFormat}. To create one from a native JS date, use {@link DateTime.fromJSDate}.\n * * **Gregorian calendar and time**: To examine the Gregorian properties of a DateTime individually (i.e as opposed to collectively through {@link DateTime#toObject}), use the {@link DateTime#year},\n * {@link DateTime#month}, {@link DateTime#day}, {@link DateTime#hour}, {@link DateTime#minute}, {@link DateTime#second}, {@link DateTime#millisecond} accessors.\n * * **Week calendar**: For ISO week calendar attributes, see the {@link DateTime#weekYear}, {@link DateTime#weekNumber}, and {@link DateTime#weekday} accessors.\n * * **Configuration** See the {@link DateTime#locale} and {@link DateTime#numberingSystem} accessors.\n * * **Transformation**: To transform the DateTime into other DateTimes, use {@link DateTime#set}, {@link DateTime#reconfigure}, {@link DateTime#setZone}, {@link DateTime#setLocale},\n * {@link DateTime.plus}, {@link DateTime#minus}, {@link DateTime#endOf}, {@link DateTime#startOf}, {@link DateTime#toUTC}, and {@link DateTime#toLocal}.\n * * **Output**: To convert the DateTime to other representations, use the {@link DateTime#toRelative}, {@link DateTime#toRelativeCalendar}, {@link DateTime#toJSON}, {@link DateTime#toISO},\n * {@link DateTime#toHTTP}, {@link DateTime#toObject}, {@link DateTime#toRFC2822}, {@link DateTime#toString}, {@link DateTime#toLocaleString}, {@link DateTime#toFormat},\n * {@link DateTime#toMillis} and {@link DateTime#toJSDate}.\n *\n * There's plenty others documented below. In addition, for more information on subtler topics\n * like internationalization, time zones, alternative calendars, validity, and so on, see the external documentation.\n */\nexport class DateTime {\n    /**\n     * Create a DateTime for the current instant, in the system's time zone.\n     *\n     * Use Settings to override these default values if needed.\n     * @example\n     * DateTime.now().toISO() //~> now in the ISO format\n     */\n    static now(): DateTime;\n\n    /**\n     * Create a local DateTime\n     *\n     * @param year - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used\n     * @param month - The month, 1-indexed\n     * @param day - The day of the month, 1-indexed\n     * @param hour - The hour of the day, in 24-hour time\n     * @param minute - The minute of the hour, meaning a number between 0 and 59\n     * @param second - The second of the minute, meaning a number between 0 and 59\n     * @param millisecond - The millisecond of the second, meaning a number between 0 and 999\n     *\n     * @example\n     * DateTime.local()                                  //~> now\n     * @example\n     * DateTime.local({ zone: \"America/New_York\" })      //~> now, in US east coast time\n     * @example\n     * DateTime.local(2017)                              //~> 2017-01-01T00:00:00\n     * @example\n     * DateTime.local(2017, 3)                           //~> 2017-03-01T00:00:00\n     * @example\n     * DateTime.local(2017, 3, 12, { locale: \"fr\")       //~> 2017-03-12T00:00:00, with a French locale\n     * @example\n     * DateTime.local(2017, 3, 12, 5)                    //~> 2017-03-12T05:00:00\n     * @example\n     * DateTime.local(2017, 3, 12, 5, { zone: \"utc\" })   //~> 2017-03-12T05:00:00, in UTC\n     * @example\n     * DateTime.local(2017, 3, 12, 5, 45)                //~> 2017-03-12T05:45:00\n     * @example\n     * DateTime.local(2017, 3, 12, 5, 45, 10)            //~> 2017-03-12T05:45:10\n     * @example\n     * DateTime.local(2017, 3, 12, 5, 45, 10, 765)       //~> 2017-03-12T05:45:10.765\n     */\n    static local(\n        year: number,\n        month: number,\n        day: number,\n        hour: number,\n        minute: number,\n        second: number,\n        millisecond: number,\n        opts?: DateTimeJSOptions,\n    ): DateTime;\n    static local(\n        year: number,\n        month: number,\n        day: number,\n        hour: number,\n        minute: number,\n        second: number,\n        opts?: DateTimeJSOptions,\n    ): DateTime;\n    static local(\n        year: number,\n        month: number,\n        day: number,\n        hour: number,\n        minute: number,\n        opts?: DateTimeJSOptions,\n    ): DateTime;\n    static local(year: number, month: number, day: number, hour: number, opts?: DateTimeJSOptions): DateTime;\n    static local(year: number, month: number, day: number, opts?: DateTimeJSOptions): DateTime;\n    static local(year: number, month: number, opts?: DateTimeJSOptions): DateTime;\n    static local(year: number, opts?: DateTimeJSOptions): DateTime;\n    static local(opts?: DateTimeJSOptions): DateTime;\n\n    /**\n     * Create a DateTime in UTC\n     *\n     * @param year - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used\n     * @param month - The month, 1-indexed\n     * @param day - The day of the month\n     * @param hour - The hour of the day, in 24-hour time\n     * @param minute - The minute of the hour, meaning a number between 0 and 59\n     * @param second - The second of the minute, meaning a number between 0 and 59\n     * @param millisecond - The millisecond of the second, meaning a number between 0 and 999\n     * @param options - configuration options for the DateTime\n     * @param options.locale - a locale to set on the resulting DateTime instance\n     * @param options.outputCalendar - the output calendar to set on the resulting DateTime instance\n     * @param options.numberingSystem - the numbering system to set on the resulting DateTime instance\n     *\n     * @example\n     * DateTime.utc()                                            //~> now\n     * @example\n     * DateTime.utc(2017)                                        //~> 2017-01-01T00:00:00Z\n     * @example\n     * DateTime.utc(2017, 3)                                     //~> 2017-03-01T00:00:00Z\n     * @example\n     * DateTime.utc(2017, 3, 12)                                 //~> 2017-03-12T00:00:00Z\n     * @example\n     * DateTime.utc(2017, 3, 12, 5)                              //~> 2017-03-12T05:00:00Z\n     * @example\n     * DateTime.utc(2017, 3, 12, 5, 45)                          //~> 2017-03-12T05:45:00Z\n     * @example\n     * DateTime.utc(2017, 3, 12, 5, 45, { locale: \"fr\" } )       //~> 2017-03-12T05:45:00Z with a French locale\n     * @example\n     * DateTime.utc(2017, 3, 12, 5, 45, 10)                      //~> 2017-03-12T05:45:10Z\n     * @example\n     * DateTime.utc(2017, 3, 12, 5, 45, 10, 765, { locale: \"fr\") //~> 2017-03-12T05:45:10.765Z with a French locale\n     */\n    static utc(\n        year: number,\n        month: number,\n        day: number,\n        hour: number,\n        minute: number,\n        second: number,\n        millisecond: number,\n        options?: LocaleOptions,\n    ): DateTime;\n    static utc(\n        year: number,\n        month: number,\n        day: number,\n        hour: number,\n        minute: number,\n        second: number,\n        options?: LocaleOptions,\n    ): DateTime;\n    static utc(\n        year: number,\n        month: number,\n        day: number,\n        hour: number,\n        minute: number,\n        options?: LocaleOptions,\n    ): DateTime;\n    static utc(year: number, month: number, day: number, hour: number, options?: LocaleOptions): DateTime;\n    static utc(year: number, month: number, day: number, options?: LocaleOptions): DateTime;\n    static utc(year: number, month: number, options?: LocaleOptions): DateTime;\n    static utc(year: number, options?: LocaleOptions): DateTime;\n    static utc(options?: LocaleOptions): DateTime;\n\n    /**\n     * Create a DateTime from a JavaScript Date object. Uses the default zone.\n     *\n     * @param date - a JavaScript Date object\n     * @param options - configuration options for the DateTime\n     * @param options.zone - the zone to place the DateTime into\n     */\n    static fromJSDate(date: Date, options?: { zone?: string | Zone }): DateTime;\n\n    /**\n     * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.\n     *\n     * @param milliseconds - a number of milliseconds since 1970 UTC\n     * @param options - configuration options for the DateTime\n     * @param options.zone - the zone to place the DateTime into. Defaults to 'local'.\n     * @param options.locale - a locale to set on the resulting DateTime instance\n     * @param options.outputCalendar - the output calendar to set on the resulting DateTime instance\n     * @param options.numberingSystem - the numbering system to set on the resulting DateTime instance\n     */\n    static fromMillis(milliseconds: number, options?: DateTimeJSOptions): DateTime;\n\n    /**\n     * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.\n     *\n     * @param seconds - a number of seconds since 1970 UTC\n     * @param options - configuration options for the DateTime\n     * @param options.zone - the zone to place the DateTime into. Defaults to 'local'.\n     * @param options.locale - a locale to set on the resulting DateTime instance\n     * @param options.outputCalendar - the output calendar to set on the resulting DateTime instance\n     * @param options.numberingSystem - the numbering system to set on the resulting DateTime instance\n     */\n    static fromSeconds(seconds: number, options?: DateTimeJSOptions): DateTime;\n\n    /**\n     * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.\n     *\n     * @param obj - the object to create the DateTime from\n     * @param obj.year - a year, such as 1987\n     * @param obj.month - a month, 1-12\n     * @param obj.day - a day of the month, 1-31, depending on the month\n     * @param obj.ordinal - day of the year, 1-365 or 366\n     * @param obj.weekYear - an ISO week year\n     * @param obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year\n     * @param obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday\n     * @param obj.hour - hour of the day, 0-23\n     * @param obj.minute - minute of the hour, 0-59\n     * @param obj.second - second of the minute, 0-59\n     * @param obj.millisecond - millisecond of the second, 0-999\n     * @param opts - options for creating this DateTime\n     * @param opts.zone - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone(). Defaults to 'local'.\n     * @param opts.locale - a locale to set on the resulting DateTime instance. Defaults to 'system's locale'.\n     * @param opts.outputCalendar - the output calendar to set on the resulting DateTime instance\n     * @param opts.numberingSystem - the numbering system to set on the resulting DateTime instance\n     *\n     * @example\n     * DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'\n     * @example\n     * DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'\n     * @example\n     * DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06\n     * @example\n     * DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),\n     * @example\n     * DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })\n     * @example\n     * DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { }zone: 'America/New_York' })\n     * @example\n     * DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'\n     */\n    static fromObject(obj: DateObjectUnits, opts?: DateTimeJSOptions): DateTime;\n\n    /**\n     * Create a DateTime from an ISO 8601 string\n     *\n     * @param text - the ISO string\n     * @param opts - options to affect the creation\n     * @param opts.zone - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone. Defaults to 'local'.\n     * @param opts.setZone - override the zone with a fixed-offset zone specified in the string itself, if it specifies one. Defaults to false.\n     * @param opts.locale - a locale to set on the resulting DateTime instance. Defaults to 'system's locale'.\n     * @param opts.outputCalendar - the output calendar to set on the resulting DateTime instance\n     * @param opts.numberingSystem - the numbering system to set on the resulting DateTime instance\n     *\n     * @example\n     * DateTime.fromISO('2016-05-25T09:08:34.123')\n     * @example\n     * DateTime.fromISO('2016-05-25T09:08:34.123+06:00')\n     * @example\n     * DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})\n     * @example\n     * DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})\n     * @example\n     * DateTime.fromISO('2016-W05-4')\n     */\n    static fromISO(text: string, opts?: DateTimeOptions): DateTime;\n\n    /**\n     * Create a DateTime from an RFC 2822 string\n     *\n     * @param text - the RFC 2822 string\n     * @param opts - options to affect the creation\n     * @param opts.zone - convert the time to this zone. Since the offset is always specified in the string itself,\n     * this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in. Defaults to 'local'\n     * @param opts.setZone - override the zone with a fixed-offset zone specified in the string itself, if it specifies one. Defaults to false.\n     * @param opts.locale - a locale to set on the resulting DateTime instance. Defaults to 'system's locale'.\n     * @param opts.outputCalendar - the output calendar to set on the resulting DateTime instance\n     * @param opts.numberingSystem - the numbering system to set on the resulting DateTime instance\n     *\n     * @example\n     * DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')\n     * @example\n     * DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')\n     * @example\n     * DateTime.fromRFC2822('25 Nov 2016 13:23 Z')\n     */\n    static fromRFC2822(text: string, opts?: DateTimeOptions): DateTime;\n\n    /**\n     * Create a DateTime from an HTTP header date\n     *\n     * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1\n     *\n     * @param text - the HTTP header date\n     * @param opts - options to affect the creation\n     * @param opts.zone - convert the time to this zone. Since HTTP dates are always in UTC,\n     * this has no effect on the interpretation of string,merely the zone the resulting DateTime is expressed in. Defaults to 'local'.\n     * @param opts.setZone - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC,\n     * so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods. Defaults to false.\n     * @param opts.locale - a locale to set on the resulting DateTime instance. Defaults to 'system's locale'.\n     * @param opts.outputCalendar - the output calendar to set on the resulting DateTime instance\n     * @param opts.numberingSystem - the numbering system to set on the resulting DateTime instance\n     *\n     * @example\n     * DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')\n     * @example\n     * DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')\n     * @example\n     * DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')\n     */\n    static fromHTTP(text: string, opts?: DateTimeOptions): DateTime;\n\n    /**\n     * Create a DateTime from an input string and format string.\n     * Defaults to en-US if no locale has been specified, regardless of the system's locale. For a table of tokens and their interpretations,\n     * see [here](https://moment.github.io/luxon/#/parsing?id=table-of-tokens).\n     *\n     * @param text - the string to parse\n     * @param fmt - the format the string is expected to be in (see the link below for the formats)\n     * @param opts - options to affect the creation\n     * @param opts.zone - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone. Defaults to 'local'.\n     * @param opts.setZone - override the zone with a zone specified in the string itself, if it specifies one. Defaults to false.\n     * @param opts.locale - a locale string to use when parsing. Will also set the DateTime to this locale. Defaults to 'en-US'.\n     * @param opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system\n     * @param opts.outputCalendar - the output calendar to set on the resulting DateTime instance\n     */\n    static fromFormat(text: string, fmt: string, opts?: DateTimeOptions): DateTime;\n\n    /**\n     * @deprecated use fromFormat instead\n     */\n    static fromString(text: string, format: string, options?: DateTimeOptions): DateTime;\n\n    /**\n     * Create a DateTime from a SQL date, time, or datetime\n     * Defaults to en-US if no locale has been specified, regardless of the system's locale\n     *\n     * @param text - the string to parse\n     * @param opts - options to affect the creation\n     * @param opts.zone - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone. Defaults to 'local'.\n     * @param opts.setZone - override the zone with a zone specified in the string itself, if it specifies one. Defaults to false.\n     * @param opts.locale - a locale string to use when parsing. Will also set the DateTime to this locale. Defaults to 'en-US'.\n     * @param opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system\n     * @param opts.outputCalendar - the output calendar to set on the resulting DateTime instance\n     *\n     * @example\n     * DateTime.fromSQL('2017-05-15')\n     * @example\n     * DateTime.fromSQL('2017-05-15 09:12:34')\n     * @example\n     * DateTime.fromSQL('2017-05-15 09:12:34.342')\n     * @example\n     * DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')\n     * @example\n     * DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')\n     * @example\n     * DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })\n     * @example\n     * DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })\n     * @example\n     * DateTime.fromSQL('09:12:34.342')\n     */\n    static fromSQL(text: string, opts?: DateTimeOptions): DateTime;\n\n    /**\n     * Create an invalid DateTime.\n     *\n     * @param reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent\n     * @param explanation - longer explanation, may include parameters and other useful debugging information. Defaults to null.\n     */\n    static invalid(reason: string, explanation?: string): DateTime;\n\n    /**\n     * Check if an object is a DateTime. Works across context boundaries\n     *\n     * @param o\n     */\n    static isDateTime(o: unknown): o is DateTime;\n\n    private constructor(config: unknown);\n\n    // INFO\n\n    /**\n     * Get the value of unit.\n     *\n     * @param unit - a unit such as 'minute' or 'day'\n     *\n     * @example\n     * DateTime.local(2017, 7, 4).get('month'); //=> 7\n     * @example\n     * DateTime.local(2017, 7, 4).get('day'); //=> 4\n     */\n    get(unit: keyof DateTime): number;\n\n    /**\n     * Returns whether the DateTime is valid. Invalid DateTimes occur when:\n     * * The DateTime was created from invalid calendar information, such as the 13th month or February 30\n     * * The DateTime was created by an operation on another invalid date\n     */\n    get isValid(): boolean;\n\n    /**\n     * Returns an error code if this DateTime is invalid, or null if the DateTime is valid\n     */\n    get invalidReason(): string | null;\n\n    /**\n     * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid\n     */\n    get invalidExplanation(): string | null;\n\n    /**\n     * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime\n     */\n    get locale(): string;\n\n    /**\n     * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime\n     */\n    get numberingSystem(): string;\n\n    /**\n     * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime\n     */\n    get outputCalendar(): string;\n\n    /**\n     * Get the time zone associated with this DateTime.\n     */\n    get zone(): Zone;\n\n    /**\n     * Get the name of the time zone.\n     */\n    get zoneName(): string;\n\n    /**\n     * Get the year\n     *\n     * @example DateTime.local(2017, 5, 25).year //=> 2017\n     */\n    get year(): number;\n\n    /**\n     * Get the quarter\n     *\n     * @example DateTime.local(2017, 5, 25).quarter //=> 2\n     */\n    get quarter(): QuarterNumbers;\n\n    /**\n     * Get the month (1-12).\n     *\n     * @example DateTime.local(2017, 5, 25).month //=> 5\n     */\n    get month(): MonthNumbers;\n\n    /**\n     * Get the day of the month (1-30ish).\n     *\n     * @example DateTime.local(2017, 5, 25).day //=> 25\n     */\n    get day(): DayNumbers;\n\n    /**\n     * Get the hour of the day (0-23).\n     *\n     * @example DateTime.local(2017, 5, 25, 9).hour //=> 9\n     */\n    get hour(): HourNumbers;\n\n    /**\n     * Get the minute of the hour (0-59).\n     *\n     * @example\n     * DateTime.local(2017, 5, 25, 9, 30).minute //=> 30\n     */\n    get minute(): MinuteNumbers;\n\n    /**\n     * Get the second of the minute (0-59).\n     *\n     * @example\n     * DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52\n     */\n    get second(): SecondNumbers;\n\n    /**\n     * Get the millisecond of the second (0-999).\n     *\n     * @example\n     * DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654\n     */\n    get millisecond(): number;\n\n    /**\n     * Get the week year\n     * @see https://en.wikipedia.org/wiki/ISO_week_date\n     *\n     * @example\n     * DateTime.local(2014, 12, 31).weekYear //=> 2015\n     */\n    get weekYear(): number;\n\n    /**\n     * Get the week number of the week year (1-52ish).\n     * @see https://en.wikipedia.org/wiki/ISO_week_date\n     *\n     * @example\n     * DateTime.local(2017, 5, 25).weekNumber //=> 21\n     */\n    get weekNumber(): WeekNumbers;\n\n    /**\n     * Get the day of the week.\n     * 1 is Monday and 7 is Sunday\n     * @see https://en.wikipedia.org/wiki/ISO_week_date\n     *\n     * @example\n     * DateTime.local(2014, 11, 31).weekday //=> 4\n     */\n    get weekday(): WeekdayNumbers;\n\n    /**\n     * Get the ordinal (meaning the day of the year)\n     *\n     * @example\n     * DateTime.local(2017, 5, 25).ordinal //=> 145\n     */\n    get ordinal(): number;\n\n    /**\n     * Get the human readable short month name, such as 'Oct'.\n     * Defaults to the system's locale if no locale has been specified\n     *\n     * @example\n     * DateTime.local(2017, 10, 30).monthShort //=> Oct\n     */\n    get monthShort(): string;\n\n    /**\n     * Get the human readable long month name, such as 'October'.\n     * Defaults to the system's locale if no locale has been specified\n     *\n     * @example\n     * DateTime.local(2017, 10, 30).monthLong //=> October\n     */\n    get monthLong(): string;\n\n    /**\n     * Get the human readable short weekday, such as 'Mon'.\n     * Defaults to the system's locale if no locale has been specified\n     *\n     * @example\n     * DateTime.local(2017, 10, 30).weekdayShort //=> Mon\n     */\n    get weekdayShort(): string;\n\n    /**\n     * Get the human readable long weekday, such as 'Monday'.\n     * Defaults to the system's locale if no locale has been specified\n     *\n     * @example\n     * DateTime.local(2017, 10, 30).weekdayLong //=> Monday\n     */\n    get weekdayLong(): string;\n\n    /**\n     * Get the UTC offset of this DateTime in minutes\n     *\n     * @example\n     * DateTime.now().offset //=> -240\n     * @example\n     * DateTime.utc().offset //=> 0\n     */\n    get offset(): number;\n\n    /**\n     * Get the short human name for the zone's current offset, for example \"EST\" or \"EDT\".\n     * Defaults to the system's locale if no locale has been specified\n     */\n    get offsetNameShort(): string;\n\n    /**\n     * Get the long human name for the zone's current offset, for example \"Eastern Standard Time\" or \"Eastern Daylight Time\".\n     * Defaults to the system's locale if no locale has been specified\n     */\n    get offsetNameLong(): string;\n\n    /**\n     * Get whether this zone's offset ever changes, as in a DST.\n     */\n    get isOffsetFixed(): boolean;\n\n    /**\n     * Get whether the DateTime is in a DST.\n     */\n    get isInDST(): boolean;\n\n    /**\n     * Returns true if this DateTime is in a leap year, false otherwise\n     *\n     * @example\n     * DateTime.local(2016).isInLeapYear //=> true\n     * @example\n     * DateTime.local(2013).isInLeapYear //=> false\n     */\n    get isInLeapYear(): boolean;\n\n    /**\n     * Returns the number of days in this DateTime's month\n     *\n     * @example\n     * DateTime.local(2016, 2).daysInMonth //=> 29\n     * @example\n     * DateTime.local(2016, 3).daysInMonth //=> 31\n     */\n    get daysInMonth(): PossibleDaysInMonth;\n\n    /**\n     * Returns the number of days in this DateTime's year\n     *\n     * @example\n     * DateTime.local(2016).daysInYear //=> 366\n     * @example\n     * DateTime.local(2013).daysInYear //=> 365\n     */\n    get daysInYear(): PossibleDaysInYear;\n\n    /**\n     * Returns the number of weeks in this DateTime's year\n     * @see https://en.wikipedia.org/wiki/ISO_week_date\n     *\n     * @example\n     * DateTime.local(2004).weeksInWeekYear //=> 53\n     * @example\n     * DateTime.local(2013).weeksInWeekYear //=> 52\n     */\n    get weeksInWeekYear(): PossibleWeeksInYear;\n\n    /**\n     * Returns the resolved Intl options for this DateTime.\n     * This is useful in understanding the behavior of formatting methods\n     *\n     * @param opts - the same options as toLocaleString\n     */\n    resolvedLocaleOptions(opts?: LocaleOptions | DateTimeFormatOptions): ResolvedLocaleOptions;\n\n    // TRANSFORM\n\n    /**\n     * \"Set\" the DateTime's zone to UTC. Returns a newly-constructed DateTime.\n     *\n     * Equivalent to {@link DateTime.setZone}('utc')\n     *\n     * @param offset - optionally, an offset from UTC in minutes. Defaults to 0.\n     * @param opts - options to pass to `setZone()`. Defaults to {}.\n     */\n    toUTC(offset?: number, opts?: ZoneOptions): DateTime;\n\n    /**\n     * \"Set\" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.\n     *\n     * Equivalent to `setZone('local')`\n     */\n    toLocal(): DateTime;\n\n    /**\n     * \"Set\" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.\n     *\n     * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations,\n     * as with {@link DateTime.plus}. You may wish to use {@link DateTime.toLocal} and {@link DateTime.toUTC} which provide simple convenience wrappers for commonly used zones.\n     *\n     * @param zone - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'.\n     * You may also supply an instance of a {@link DateTime.Zone} class. Defaults to 'local'.\n     * @param opts - options\n     * @param opts.keepLocalTime - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this. Defaults to false.\n     */\n    setZone(zone?: string | Zone, opts?: ZoneOptions): DateTime;\n\n    /**\n     * \"Set\" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.\n     *\n     * @param properties - the properties to set\n     *\n     * @example\n     * DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })\n     */\n    reconfigure(properties: LocaleOptions): DateTime;\n\n    /**\n     * \"Set\" the locale. Returns a newly-constructed DateTime.\n     * Just a convenient alias for reconfigure({ locale })\n     *\n     * @example\n     * DateTime.local(2017, 5, 25).setLocale('en-GB')\n     */\n    setLocale(locale: string): DateTime;\n\n    /**\n     * \"Set\" the values of specified units. Returns a newly-constructed DateTime.\n     * You can only set units with this method; for \"setting\" metadata, see {@link DateTime.reconfigure} and {@link DateTime.setZone}.\n     *\n     * @param values - a mapping of units to numbers\n     *\n     * @example\n     * dt.set({ year: 2017 })\n     * @example\n     * dt.set({ hour: 8, minute: 30 })\n     * @example\n     * dt.set({ weekday: 5 })\n     * @example\n     * dt.set({ year: 2005, ordinal: 234 })\n     */\n    set(values: DateObjectUnits): DateTime;\n\n    /**\n     * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar,\n     * accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.\n     *\n     * @param duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()\n     *\n     * @example\n     * DateTime.now().plus(123) //~> in 123 milliseconds\n     * @example\n     * DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes\n     * @example\n     * DateTime.now().plus({ days: 1 }) //~> this time tomorrow\n     * @example\n     * DateTime.now().plus({ days: -1 }) //~> this time yesterday\n     * @example\n     * DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min\n     * @example\n     * DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min\n     */\n    plus(duration: DurationLike): DateTime;\n\n    /**\n     * See {@link DateTime.plus}\n     *\n     * @param duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()\n     */\n    minus(duration: DurationLike): DateTime;\n\n    /**\n     * \"Set\" this DateTime to the beginning of a unit of time.\n     *\n     * @param unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.\n     *\n     * @example\n     * DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'\n     * @example\n     * DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'\n     * @example\n     * DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays\n     * @example\n     * DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'\n     * @example\n     * DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'\n     */\n    startOf(unit: DateTimeUnit): DateTime;\n\n    /**\n     * \"Set\" this DateTime to the end (meaning the last millisecond) of a unit of time\n     *\n     * @param unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.\n     *\n     * @example\n     * DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'\n     * @example\n     * DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'\n     * @example\n     * DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays\n     * @example\n     * DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'\n     * @example\n     * DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'\n     */\n    endOf(unit: DateTimeUnit): DateTime;\n\n    // OUTPUT\n\n    /**\n     * Returns a string representation of this DateTime formatted according to the specified format string.\n     * **You may not want this.** See {@link DateTime.toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations,\n     * see [here](https://moment.github.io/luxon/#/formatting?id=table-of-tokens).\n     * Defaults to en-US if no locale has been specified, regardless of the system's locale.\n     *\n     * @param fmt - the format string\n     * @param opts - opts to override the configuration options on this DateTime\n     *\n     * @example\n     * DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'\n     * @example\n     * DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'\n     * @example\n     * DateTime.now().toFormat('yyyy LLL dd', { locale: \"fr\" }) //=> '2017 avr. 22'\n     * @example\n     * DateTime.now().toFormat(\"HH 'hours and' mm 'minutes'\") //=> '20 hours and 55 minutes'\n     */\n    toFormat(fmt: string, opts?: LocaleOptions): string;\n\n    /**\n     * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon,\n     * such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE` of the DateTime in the assigned locale.\n     * Defaults to the system's locale if no locale has been specified\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat\n     *\n     * @param formatOpts - Intl.DateTimeFormat constructor options and configuration options\n     * @param opts - opts to override the configuration options on this DateTime\n     *\n     * @example\n     * DateTime.now().toLocaleString(); //=> 4/20/2017\n     * @example\n     * DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'\n     * @example\n     * DateTime.now().toLocaleString({ locale: 'en-gb' }); //=> '20/04/2017'\n     * @example\n     * DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'\n     * @example\n     * DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'\n     * @example\n     * DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'\n     * @example\n     * DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'\n     * @example\n     * DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'\n     * @example\n     * DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hourCycle: 'h23' }); //=> '11:32'\n     */\n    toLocaleString(formatOpts?: DateTimeFormatOptions, opts?: LocaleOptions): string;\n\n    /**\n     * Returns an array of format \"parts\", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.\n     * Defaults to the system's locale if no locale has been specified\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts\n     *\n     * @param opts - Intl.DateTimeFormat constructor options, same as `toLocaleString`.\n     *\n     * @example\n     * DateTime.now().toLocaleParts(); //=> [\n     *                                 //=>   { type: 'day', value: '25' },\n     *                                 //=>   { type: 'literal', value: '/' },\n     *                                 //=>   { type: 'month', value: '05' },\n     *                                 //=>   { type: 'literal', value: '/' },\n     *                                 //=>   { type: 'year', value: '1982' }\n     *                                 //=> ]\n     */\n    toLocaleParts(opts?: DateTimeFormatOptions): Intl.DateTimeFormatPart[];\n\n    /**\n     * Returns an ISO 8601-compliant string representation of this DateTime\n     *\n     * @param opts - options\n     * @param opts.suppressMilliseconds - exclude milliseconds from the format if they're 0. Defaults to false.\n     * @param opts.suppressSeconds - exclude seconds from the format if they're 0. Defaults to false.\n     * @param opts.includeOffset - include the offset, such as 'Z' or '-04:00'. Defaults to true.\n     * @param opts.format - choose between the basic and extended format. Defaults to 'extended'.\n     *\n     * @example\n     * DateTime.utc(1982, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'\n     * @example\n     * DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'\n     * @example\n     * DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'\n     * @example\n     * DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'\n     */\n    toISO(opts?: ToISOTimeOptions): string;\n\n    /**\n     * Returns an ISO 8601-compliant string representation of this DateTime's date component\n     *\n     * @param opts - options\n     * @param opts.format - choose between the basic and extended format. Defaults to 'extended'.\n     *\n     * @example\n     * DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'\n     * @example\n     * DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'\n     */\n    toISODate(opts?: ToISODateOptions): string;\n\n    /**\n     * Returns an ISO 8601-compliant string representation of this DateTime's week date\n     *\n     * @example\n     * DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'\n     */\n    toISOWeekDate(): string;\n\n    /**\n     * Returns an ISO 8601-compliant string representation of this DateTime's time component\n     *\n     * @param opts - options\n     * @param opts.suppressMilliseconds - exclude milliseconds from the format if they're 0. Defaults to false.\n     * @param opts.suppressSeconds - exclude seconds from the format if they're 0. Defaults to false.\n     * @param opts.includeOffset - include the offset, such as 'Z' or '-04:00'. Defaults to true.\n     * @param opts.includePrefix - include the `T` prefix. Defaults to false.\n     * @param opts.format - choose between the basic and extended format. Defaults to 'extended'.\n     *\n     * @example\n     * DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'\n     * @example\n     * DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'\n     * @example\n     * DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'\n     * @example\n     * DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'\n     */\n    toISOTime(ops?: ToISOTimeOptions): string;\n\n    /**\n     * Returns an RFC 2822-compatible string representation of this DateTime, always in UTC\n     *\n     * @example\n     * DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'\n     * @example\n     * DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'\n     */\n    toRFC2822(): string;\n\n    /**\n     * Returns a string representation of this DateTime appropriate for use in HTTP headers.\n     * Specifically, the string conforms to RFC 1123.\n     * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1\n     *\n     * @example\n     * DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'\n     * @example\n     * DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'\n     */\n    toHTTP(): string;\n\n    /**\n     * Returns a string representation of this DateTime appropriate for use in SQL Date\n     *\n     * @example\n     * DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'\n     */\n    toSQLDate(): string;\n\n    /**\n     * Returns a string representation of this DateTime appropriate for use in SQL Time\n     *\n     * @param opts - options\n     * @param opts.includeZone - include the zone, such as 'America/New_York'. Overrides includeOffset. Defaults to false.\n     * @param opts.includeOffset - include the offset, such as 'Z' or '-04:00'. Defaults to true.\n     *\n     * @example\n     * DateTime.utc().toSQL() //=> '05:15:16.345'\n     * @example\n     * DateTime.now().toSQL() //=> '05:15:16.345 -04:00'\n     * @example\n     * DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'\n     * @example\n     * DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'\n     */\n    toSQLTime(opts?: ToSQLOptions): string;\n\n    /**\n     * Returns a string representation of this DateTime appropriate for use in SQL DateTime\n     *\n     * @param opts - options\n     * @param opts.includeZone - include the zone, such as 'America/New_York'. Overrides includeOffset. Defaults to false.\n     * @param opts.includeOffset - include the offset, such as 'Z' or '-04:00'. Defaults to true.\n     *\n     * @example\n     * DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'\n     * @example\n     * DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'\n     * @example\n     * DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'\n     * @example\n     * DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'\n     */\n    toSQL(opts?: ToSQLOptions): string;\n\n    /**\n     * Returns a string representation of this DateTime appropriate for debugging\n     */\n    toString(): string;\n\n    /**\n     * Returns the epoch milliseconds of this DateTime. Alias of {@link DateTime.toMillis}\n     */\n    valueOf(): number;\n\n    /**\n     * Returns the epoch milliseconds of this DateTime.\n     */\n    toMillis(): number;\n\n    /**\n     * Returns the epoch seconds of this DateTime.\n     */\n    toSeconds(): number;\n\n    /**\n     * Returns the epoch seconds (as a whole number) of this DateTime.\n     */\n    toUnixInteger(): number;\n\n    /**\n     * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.\n     */\n    toJSON(): string;\n\n    /**\n     * Returns a BSON serializable equivalent to this DateTime.\n     */\n    toBSON(): Date;\n\n    /**\n     * Returns a JavaScript object with this DateTime's year, month, day, and so on.\n     *\n     * @param opts - options for generating the object\n     * @param opts.includeConfig - include configuration attributes in the output. Defaults to false.\n     *\n     * @example\n     * DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }\n     */\n    toObject(opts?: {\n        /**\n         * Include configuration attributes in the output\n         * @defaultValue false\n         */\n        includeConfig?: boolean | undefined;\n    }): ToObjectOutput;\n\n    /**\n     * Returns a JavaScript Date equivalent to this DateTime.\n     */\n    toJSDate(): Date;\n\n    // COMPARE\n\n    /**\n     * Return the difference between two DateTimes as a Duration.\n     *\n     * @param otherDateTime - the DateTime to compare this one to\n     * @param unit- the unit or array of units (such as 'hours' or 'days') to include in the duration. Defaults to ['milliseconds'].\n     * @param opts - options that affect the creation of the Duration\n     * @param opts.conversionAccuracy - the conversion system to use. Defaults to 'casual'.\n     *\n     * @example\n     * var i1 = DateTime.fromISO('1982-05-25T09:45'),\n     *     i2 = DateTime.fromISO('1983-10-14T10:30');\n     * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }\n     * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }\n     * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }\n     * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }\n     */\n    diff(otherDateTime: DateTime, unit?: DurationUnits, opts?: DiffOptions): Duration;\n\n    /**\n     * Return the difference between this DateTime and right now.\n     * See {@link DateTime.diff}\n     *\n     * @param unit - the unit or units units (such as 'hours' or 'days') to include in the duration. Defaults to ['milliseconds'].\n     * @param opts - options that affect the creation of the Duration\n     * @param opts.conversionAccuracy - the conversion system to use. Defaults to 'casual'.\n     */\n    diffNow(unit?: DurationUnits, opts?: DiffOptions): Duration;\n\n    /**\n     * Return an Interval spanning between this DateTime and another DateTime\n     *\n     * @param otherDateTime - the other end point of the Interval\n     */\n    until(otherDateTime: DateTime): Interval;\n\n    /**\n     * Return whether this DateTime is in the same unit of time as another DateTime.\n     * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link DateTime.setZone} to convert one of the dates if needed.\n     *\n     * @param otherDateTime - the other DateTime\n     * @param unit - the unit of time to check sameness on\n     *\n     * @example\n     * DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day\n     */\n    hasSame(otherDateTime: DateTime, unit: DateTimeUnit): boolean;\n\n    /**\n     * Equality check\n     * Two DateTimes are equal iff they represent the same millisecond, have the same zone and location, and are both valid.\n     * To compare just the millisecond values, use `+dt1 === +dt2`.\n     *\n     * @param other - the other DateTime\n     */\n    equals(other: DateTime): boolean;\n\n    /**\n     * Returns a string representation of a this time relative to now, such as \"in two days\". Can only internationalize if your\n     * platform supports Intl.RelativeTimeFormat. Rounds down by default.\n     *\n     * @param options - options that affect the output\n     * @param options.base - the DateTime to use as the basis to which this time is compared. Defaults to now.\n     * @param options.style - the style of units, must be \"long\", \"short\", or \"narrow\". Defaults to long.\n     * @param options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit.\n     * Use an array or one of \"years\", \"quarters\", \"months\", \"weeks\", \"days\", \"hours\", \"minutes\", or \"seconds\"\n     * @param options.round - whether to round the numbers in the output. Defaults to true.\n     * @param options.padding - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false}\n     * because the decimal output will include the padding. Defaults to 0.\n     * @param options.locale - override the locale of this DateTime\n     * @param options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this\n     *\n     * @example\n     * DateTime.now().plus({ days: 1 }).toRelative() //=> \"in 1 day\"\n     * @example\n     * DateTime.now().setLocale(\"es\").toRelative({ days: 1 }) //=> \"dentro de 1 día\"\n     * @example\n     * DateTime.now().plus({ days: 1 }).toRelative({ locale: \"fr\" }) //=> \"dans 23 heures\"\n     * @example\n     * DateTime.now().minus({ days: 2 }).toRelative() //=> \"2 days ago\"\n     * @example\n     * DateTime.now().minus({ days: 2 }).toRelative({ unit: \"hours\" }) //=> \"48 hours ago\"\n     * @example\n     * DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> \"1.5 days ago\"\n     */\n    toRelative(options?: ToRelativeOptions): string | null;\n\n    /**\n     * Returns a string representation of this date relative to today, such as \"yesterday\" or \"next month\".\n     * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.\n     *\n     * @param options - options that affect the output\n     * @param options.base - the DateTime to use as the basis to which this time is compared. Defaults to now.\n     * @param options.locale - override the locale of this DateTime\n     * @param options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of \"years\", \"quarters\", \"months\", \"weeks\", or \"days\"\n     * @param options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this\n     *\n     * @example\n     * DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> \"tomorrow\"\n     * @example\n     * DateTime.now().setLocale(\"es\").plus({ days: 1 }).toRelative() //=> \"\"mañana\"\n     * @example\n     * DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: \"fr\" }) //=> \"demain\"\n     * @example\n     * DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> \"2 days ago\"\n     */\n    toRelativeCalendar(options?: ToRelativeCalendarOptions): string | null;\n\n    /**\n     * Return the min of several date times\n     *\n     * @param dateTimes - the DateTimes from which to choose the minimum\n     */\n    static min(...dateTimes: DateTime[]): DateTime;\n\n    /**\n     * Return the max of several date times\n     *\n     * @param dateTimes - the DateTimes from which to choose the maximum\n     */\n    static max(...dateTimes: DateTime[]): DateTime;\n\n    // MISC\n\n    /**\n     * Explain how a string would be parsed by fromFormat()\n     *\n     * @param text - the string to parse\n     * @param fmt - the format the string is expected to be in (see description)\n     * @param options - options taken by fromFormat()\n     */\n    static fromFormatExplain(text: string, fmt: string, options?: DateTimeOptions): ExplainedFormat;\n\n    /**\n     * @deprecated use fromFormatExplain instead\n     */\n    static fromStringExplain(text: string, fmt: string, options?: DateTimeOptions): ExplainedFormat;\n\n    // FORMAT PRESETS\n\n    /**\n     * {@link DateTime.toLocaleString} format like 10/14/1983\n     */\n    static get DATE_SHORT(): Intl.DateTimeFormatOptions;\n\n    /**\n     * {@link DateTime.toLocaleString} format like 'Oct 14, 1983'\n     */\n    static get DATE_MED(): Intl.DateTimeFormatOptions;\n\n    /**\n     * {@link DateTime.toLocaleString} format like 'Fri, Oct 14, 1983'\n     */\n    static get DATE_MED_WITH_WEEKDAY(): Intl.DateTimeFormatOptions;\n\n    /**\n     * {@link DateTime.toLocaleString} format like 'October 14, 1983'\n     */\n    static get DATE_FULL(): Intl.DateTimeFormatOptions;\n\n    /**\n     * {@link DateTime.toLocaleString} format like 'Tuesday, October 14, 1983'\n     */\n    static get DATE_HUGE(): Intl.DateTimeFormatOptions;\n\n    /**\n     * {@link DateTime.toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.\n     */\n    static get TIME_SIMPLE(): Intl.DateTimeFormatOptions;\n\n    /**\n     * {@link DateTime.toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.\n     */\n    static get TIME_WITH_SECONDS(): Intl.DateTimeFormatOptions;\n\n    /**\n     * {@link DateTime.toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.\n     */\n    static get TIME_WITH_SHORT_OFFSET(): Intl.DateTimeFormatOptions;\n\n    /**\n     * {@link DateTime.toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.\n     */\n    static get TIME_WITH_LONG_OFFSET(): Intl.DateTimeFormatOptions;\n\n    /**\n     * {@link DateTime.toLocaleString} format like '09:30', always 24-hour.\n     */\n    static get TIME_24_SIMPLE(): Intl.DateTimeFormatOptions;\n\n    /**\n     * {@link DateTime.toLocaleString} format like '09:30:23', always 24-hour.\n     */\n    static get TIME_24_WITH_SECONDS(): Intl.DateTimeFormatOptions;\n\n    /**\n     * {@link DateTime.toLocaleString} format like '09:30:23 EDT', always 24-hour.\n     */\n    static get TIME_24_WITH_SHORT_OFFSET(): Intl.DateTimeFormatOptions;\n\n    /**\n     * {@link DateTime.toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.\n     */\n    static get TIME_24_WITH_LONG_OFFSET(): Intl.DateTimeFormatOptions;\n\n    /**\n     * {@link DateTime.toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.\n     */\n    static get DATETIME_SHORT(): Intl.DateTimeFormatOptions;\n\n    /**\n     * {@link DateTime.toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.\n     */\n    static get DATETIME_SHORT_WITH_SECONDS(): Intl.DateTimeFormatOptions;\n\n    /**\n     * {@link DateTime.toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.\n     */\n    static get DATETIME_MED(): Intl.DateTimeFormatOptions;\n\n    /**\n     * {@link DateTime.toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.\n     */\n    static get DATETIME_MED_WITH_SECONDS(): Intl.DateTimeFormatOptions;\n\n    /**\n     * {@link DateTime.toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.\n     */\n    static get DATETIME_MED_WITH_WEEKDAY(): Intl.DateTimeFormatOptions;\n\n    /**\n     * {@link DateTime.toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.\n     */\n    static get DATETIME_FULL(): Intl.DateTimeFormatOptions;\n\n    /**\n     * {@link DateTime.toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.\n     */\n    static get DATETIME_FULL_WITH_SECONDS(): Intl.DateTimeFormatOptions;\n\n    /**\n     * {@link DateTime.toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.\n     */\n    static get DATETIME_HUGE(): Intl.DateTimeFormatOptions;\n\n    /**\n     * {@link DateTime.toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.\n     */\n    static get DATETIME_HUGE_WITH_SECONDS(): Intl.DateTimeFormatOptions;\n}\n","node_modules/@types/luxon/src/duration.d.ts":"import { NumberingSystem } from './misc';\nimport { ConversionAccuracy } from './datetime';\n\nexport interface DurationOptions {\n    locale?: string | undefined;\n    numberingSystem?: NumberingSystem | undefined;\n    conversionAccuracy?: ConversionAccuracy | undefined;\n}\n\nexport interface DurationObjectUnits {\n    years?: number | undefined;\n    quarters?: number | undefined;\n    months?: number | undefined;\n    weeks?: number | undefined;\n    days?: number | undefined;\n    hours?: number | undefined;\n    minutes?: number | undefined;\n    seconds?: number | undefined;\n    milliseconds?: number | undefined;\n}\n\nexport interface DurationLikeObject extends DurationObjectUnits {\n    year?: number | undefined;\n    quarter?: number | undefined;\n    month?: number | undefined;\n    week?: number | undefined;\n    day?: number | undefined;\n    hour?: number | undefined;\n    minute?: number | undefined;\n    second?: number | undefined;\n    millisecond?: number | undefined;\n}\n\nexport type DurationUnit = keyof DurationLikeObject;\nexport type DurationUnits = DurationUnit | DurationUnit[];\n\nexport type ToISOFormat = 'basic' | 'extended';\n\nexport interface ToISOTimeDurationOptions {\n    /**\n     * Include the `T` prefix\n     * @default false\n     */\n    includePrefix?: boolean | undefined;\n    /**\n     * Exclude milliseconds from the format if they're 0\n     * @default false\n     */\n    suppressMilliseconds?: boolean | undefined;\n    /**\n     * Exclude seconds from the format if they're 0\n     * @default false\n     */\n    suppressSeconds?: boolean | undefined;\n    /**\n     * Choose between the basic and extended format\n     * @default 'extended'\n     */\n    format?: ToISOFormat | undefined;\n}\n\nexport interface ToHumanDurationOptions extends Intl.NumberFormatOptions {\n    listStyle?: 'long' | 'short' | 'narrow' | undefined;\n}\n\n/**\n * Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()\n *\n * @deprecated Use DurationLike instead.\n */\nexport type DurationInput = Duration | number | DurationLikeObject;\n\n/**\n * Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()\n */\nexport type DurationLike = Duration | DurationLikeObject | number;\n\n/**\n * A Duration object represents a period of time, like \"2 months\" or \"1 day, 1 hour\".\n * Conceptually, it's just a map of units to their quantities, accompanied by some additional configuration and methods for creating, parsing, interrogating, transforming, and formatting them.\n * They can be used on their own or in conjunction with other Luxon types; for example, you can use {@link DateTime.plus} to add a Duration object to a DateTime, producing another DateTime.\n *\n * Here is a brief overview of commonly used methods and getters in Duration:\n *\n * * **Creation** To create a Duration, use {@link Duration.fromMillis}, {@link Duration.fromObject}, or {@link Duration.fromISO}.\n * * **Unit values** See the {@link Duration#years}, {@link Duration.months}, {@link Duration#weeks}, {@link Duration#days}, {@link Duration#hours}, {@link Duration#minutes},\n * * {@link Duration#seconds}, {@link Duration#milliseconds} accessors.\n * * **Configuration** See  {@link Duration#locale} and {@link Duration#numberingSystem} accessors.\n * * **Transformation** To create new Durations out of old ones use {@link Duration#plus}, {@link Duration#minus}, {@link Duration#normalize}, {@link Duration#set}, {@link Duration#reconfigure},\n * * {@link Duration#shiftTo}, and {@link Duration#negate}.\n * * **Output** To convert the Duration into other representations, see {@link Duration#as}, {@link Duration#toISO}, {@link Duration#toFormat}, and {@link Duration#toJSON}\n *\n * There's are more methods documented below. In addition, for more information on subtler topics like internationalization and validity, see the external documentation.\n */\nexport class Duration {\n    /**\n     * Create Duration from a number of milliseconds.\n     *\n     * @param count - of milliseconds\n     * @param opts - options for parsing\n     * @param opts.locale - the locale to use\n     * @param opts.numberingSystem - the numbering system to use\n     * @param opts.conversionAccuracy - the conversion system to use\n     */\n    static fromMillis(count: number, opts?: DurationOptions): Duration;\n\n    /**\n     * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.\n     * If this object is empty then a zero milliseconds duration is returned.\n     *\n     * @param obj - the object to create the DateTime from\n     * @param obj.years\n     * @param obj.quarters\n     * @param obj.months\n     * @param obj.weeks\n     * @param obj.days\n     * @param obj.hours\n     * @param obj.minutes\n     * @param obj.seconds\n     * @param obj.milliseconds\n     * @param opts - options for creating this Duration. Defaults to {}.\n     * @param opts.locale - the locale to use. Defaults to 'en-US'.\n     * @param opts.numberingSystem - the numbering system to use\n     * @param opts.conversionAccuracy - the conversion system to use. Defaults to 'casual'.\n     */\n    static fromObject(obj: DurationLikeObject, opts?: DurationOptions): Duration;\n\n    /**\n     * Create a Duration from DurationLike.\n     *\n     * @param durationLike\n     * Either a Luxon Duration, a number of milliseconds, or the object argument to Duration.fromObject()\n     */\n    static fromDurationLike(durationLike: DurationLike): Duration;\n\n    /**\n     * Create a Duration from an ISO 8601 duration string.\n     * @see https://en.wikipedia.org/wiki/ISO_8601#Durations\n     *\n     * @param text - text to parse\n     * @param opts - options for parsing\n     * @param opts.locale - the locale to use. Defaults to 'en-US'.\n     * @param opts.numberingSystem - the numbering system to use\n     * @param opts.conversionAccuracy - the conversion system to use. Defaults to 'casual'.\n     *\n     * @example\n     * Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }\n     * @example\n     * Duration.fromISO('PT23H').toObject() //=> { hours: 23 }\n     * @example\n     * Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }\n     */\n    static fromISO(text: string, opts?: DurationOptions): Duration;\n\n    /**\n     * Create a Duration from an ISO 8601 time string.\n     * @see https://en.wikipedia.org/wiki/ISO_8601#Times\n     *\n     * @param text - text to parse\n     * @param opts - options for parsing\n     * @param opts.locale - the locale to use. Defaults to 'en-US'.\n     * @param opts.numberingSystem - the numbering system to use\n     * @param opts.conversionAccuracy - the conversion system to use. Defaults to 'casual'.\n     *\n     * @example\n     * Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }\n     * @example\n     * Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }\n     * @example\n     * Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }\n     * @example\n     * Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }\n     * @example\n     * Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }\n     */\n    static fromISOTime(text: string, opts?: DurationOptions): Duration;\n\n    /**\n     * Create an invalid Duration.\n     *\n     * @param reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent\n     * @param explanation - longer explanation, may include parameters and other useful debugging information. Defaults to null.\n     */\n    static invalid(reason: string, explanation?: string): Duration;\n\n    /**\n     * Check if an object is a Duration. Works across context boundaries\n     *\n     * @param o\n     */\n    static isDuration(o: unknown): o is Duration;\n\n    private constructor(config: unknown);\n\n    /**\n     * Get  the locale of a Duration, such 'en-GB'\n     */\n    get locale(): string;\n\n    /**\n     * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration\n     */\n    get numberingSystem(): string;\n\n    /**\n     * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:\n     * * `S` for milliseconds\n     * * `s` for seconds\n     * * `m` for minutes\n     * * `h` for hours\n     * * `d` for days\n     * * `M` for months\n     * * `y` for years\n     * Notes:\n     * * Add padding by repeating the token, e.g. \"yy\" pads the years to two digits, \"hhhh\" pads the hours out to four digits\n     * * The duration will be converted to the set of units in the format string using {@link Duration.shiftTo} and the Durations's conversion accuracy setting.\n     *\n     * @param fmt - the format string\n     * @param opts - options\n     * @param opts.floor - floor numerical values. Defaults to true.\n     *\n     * @example\n     * Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat(\"y d s\") //=> \"1 6 2\"\n     * @example\n     * Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat(\"yy dd sss\") //=> \"01 06 002\"\n     * @example\n     * Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat(\"M S\") //=> \"12 518402000\"\n     */\n    toFormat(fmt: string, opts?: { floor?: boolean | undefined }): string;\n\n    /**\n     * Returns a string representation of a Duration with all units included\n     * To modify its behavior use the `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant. See {@link Intl.NumberFormat}.\n     * @param opts - On option object to override the formatting. Accepts the same keys as the options parameter of the native `Int.NumberFormat` constructor, as well as `listStyle`.\n     * @example\n     * ```js\n     * var dur = Duration.fromObject({ days: 1, hours: 5, minutes: 6 })\n     * dur.toHuman() //=> '1 day, 5 hours, 6 minutes'\n     * dur.toHuman({ listStyle: \"long\" }) //=> '1 day, 5 hours, and 6 minutes'\n     * dur.toHuman({ unitDisplay: \"short\" }) //=> '1 day, 5 hr, 6 min'\n     * ```\n     */\n    toHuman(opts?: ToHumanDurationOptions): string;\n\n    /**\n     * Returns a JavaScript object with this Duration's values.\n     *\n     * @example\n     * Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }\n     */\n    toObject(): DurationObjectUnits;\n\n    /**\n     * Returns an ISO 8601-compliant string representation of this Duration.\n     * @see https://en.wikipedia.org/wiki/ISO_8601#Durations\n     *\n     * @example\n     * Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'\n     * @example\n     * Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'\n     * @example\n     * Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'\n     * @example\n     * Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'\n     * @example\n     * Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'\n     */\n    toISO(): string;\n\n    /**\n     * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.\n     * @see https://en.wikipedia.org/wiki/ISO_8601#Times\n     *\n     * @param opts - options\n     * @param opts.suppressMilliseconds - exclude milliseconds from the format if they're 0. Defaults to false.\n     * @param opts.suppressSeconds - exclude seconds from the format if they're 0. Defaults to false.\n     * @param opts.includePrefix - include the `T` prefix. Defaults to false.\n     * @param opts.format - choose between the basic and extended format. Defaults to 'extended'.\n     *\n     * @example\n     * Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'\n     * @example\n     * Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'\n     * @example\n     * Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'\n     * @example\n     * Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'\n     * @example\n     * Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'\n     */\n    toISOTime(opts?: ToISOTimeDurationOptions): string;\n\n    /**\n     * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.\n     */\n    toJSON(): string;\n\n    /**\n     * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.\n     */\n    toString(): string;\n\n    /**\n     * Returns an milliseconds value of this Duration.\n     */\n    toMillis(): number;\n\n    /**\n     * Returns an milliseconds value of this Duration. Alias of {@link toMillis}\n     */\n    valueOf(): number;\n\n    /**\n     * Make this Duration longer by the specified amount. Return a newly-constructed Duration.\n     *\n     * @param duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()\n     */\n    plus(duration: DurationLike): Duration;\n\n    /**\n     * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.\n     *\n     * @param duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()\n     */\n    minus(duration: DurationLike): Duration;\n\n    /**\n     * Scale this Duration by the specified amount. Return a newly-constructed Duration.\n     *\n     * @example\n     * Duration.fromObject({ hours: 1, minutes: 30 }).mapUnit(x => x * 2) //=> { hours: 2, minutes: 60 }\n     * @example\n     * Duration.fromObject({ hours: 1, minutes: 30 }).mapUnit((x, u) => u === \"hour\" ? x * 2 : x) //=> { hours: 2, minutes: 30 }\n     */\n    mapUnits(fn: (x: number, u?: DurationUnit) => number): Duration;\n\n    /**\n     * Get the value of unit.\n     *\n     * @param unit - a unit such as 'minute' or 'day'\n     *\n     * @example\n     * Duration.fromObject({years: 2, days: 3}).get('years') //=> 2\n     * @example\n     * Duration.fromObject({years: 2, days: 3}).get('months') //=> 0\n     * @example\n     * Duration.fromObject({years: 2, days: 3}).get('days') //=> 3\n     */\n    get(unit: DurationUnit): number;\n\n    /**\n     * \"Set\" the values of specified units. Return a newly-constructed Duration.\n     *\n     * @param values - a mapping of units to numbers\n     *\n     * @example\n     * dur.set({ years: 2017 })\n     * @example\n     * dur.set({ hours: 8, minutes: 30 })\n     */\n    set(values: DurationLikeObject): Duration;\n\n    /**\n     * \"Set\" the locale and/or numberingSystem.  Returns a newly-constructed Duration.\n     *\n     * @example\n     * dur.reconfigure({ locale: 'en-GB' })\n     */\n    reconfigure(opts?: DurationOptions): Duration;\n\n    /**\n     * Return the length of the duration in the specified unit.\n     *\n     * @param unit - a unit such as 'minutes' or 'days'\n     *\n     * @example\n     * Duration.fromObject({years: 1}).as('days') //=> 365\n     * @example\n     * Duration.fromObject({years: 1}).as('months') //=> 12\n     * @example\n     * Duration.fromObject({hours: 60}).as('days') //=> 2.5\n     */\n    as(unit: DurationUnit): number;\n\n    /**\n     * Reduce this Duration to its canonical representation in its current units.\n     *\n     * @example\n     * Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }\n     * @example\n     * Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }\n     */\n    normalize(): Duration;\n\n    /**\n     * Convert this Duration into its representation in a different set of units.\n     *\n     * @example\n     * Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }\n     */\n    shiftTo(...units: DurationUnit[]): Duration;\n\n    /**\n     * Return the negative of this Duration.\n     *\n     * @example\n     * Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }\n     */\n    negate(): Duration;\n\n    /**\n     * Get the years.\n     */\n    get years(): number;\n\n    /**\n     * Get the quarters.\n     */\n    get quarters(): number;\n\n    /**\n     * Get the months.\n     */\n    get months(): number;\n\n    /**\n     * Get the weeks\n     */\n    get weeks(): number;\n\n    /**\n     * Get the days.\n     */\n    get days(): number;\n\n    /**\n     * Get the hours.\n     */\n    get hours(): number;\n\n    /**\n     * Get the minutes.\n     */\n    get minutes(): number;\n\n    /**\n     * Get the seconds.\n     */\n    get seconds(): number;\n\n    /**\n     * Get the milliseconds.\n     */\n    get milliseconds(): number;\n\n    /**\n     * Returns whether the Duration is invalid. Invalid durations are returned by diff operations\n     * on invalid DateTimes or Intervals.\n     */\n    get isValid(): boolean;\n\n    /**\n     * Returns an error code if this Duration became invalid, or null if the Duration is valid\n     */\n    get invalidReason(): string;\n\n    /**\n     * Returns an explanation of why this Duration became invalid, or null if the Duration is valid\n     */\n    get invalidExplanation(): string;\n\n    /**\n     * Equality check\n     * Two Durations are equal iff they have the same units and the same values for each unit.\n     *\n     * @param other\n     */\n    equals(other: Duration): boolean;\n}\n","node_modules/@types/luxon/src/info.d.ts":"import { CalendarSystem, NumberingSystem, StringUnitLength, UnitLength } from './misc';\nimport { Zone } from './zone';\n\nexport interface InfoOptions {\n    locale?: string | undefined;\n}\n\nexport interface InfoUnitOptions extends InfoOptions {\n    numberingSystem?: NumberingSystem | undefined;\n}\n\n/** @deprecated */\nexport type UnitOptions = InfoUnitOptions;\n\nexport interface InfoCalendarOptions extends InfoUnitOptions {\n    outputCalendar?: CalendarSystem | undefined;\n}\n\n/**\n * The set of available features in this environment. Some features of Luxon are not available in all environments.\n */\nexport interface Features {\n    /**\n     * Whether this environment supports relative time formatting\n     */\n    relative: boolean;\n}\n\n/**\n * The Info class contains static methods for retrieving general time and date related data. For example, it has methods for finding out if a time zone has a DST, for listing the months in any\n * supported locale, and for discovering which of Luxon features are available in the current environment.\n */\nexport namespace Info {\n    /**\n     * Return whether the specified zone contains a DST.\n     *\n     * @param zone - Zone to check. Defaults to the environment's local zone. Defaults to 'local'.\n     */\n    function hasDST(zone?: string | Zone): boolean;\n\n    /**\n     * Return whether the specified zone is a valid IANA specifier.\n     *\n     * @param zone - Zone to check\n     */\n    function isValidIANAZone(zone: string): boolean;\n\n    /**\n     * Converts the input into a {@link Zone} instance.\n     *\n     * * If `input` is already a Zone instance, it is returned unchanged.\n     * * If `input` is a string containing a valid time zone name, a Zone instance\n     *   with that name is returned.\n     * * If `input` is a string that doesn't refer to a known time zone, a Zone\n     *   instance with {@link Zone.isValid} == false is returned.\n     * * If `input is a number, a Zone instance with the specified fixed offset\n     *   in minutes is returned.\n     * * If `input` is `null` or `undefined`, the default zone is returned.\n     *\n     * @param input - the value to be converted\n     */\n    function normalizeZone(input?: string | Zone | number): Zone;\n\n    /**\n     * Return an array of standalone month names.\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat\n     *\n     * @param length - the length of the month representation, such as \"numeric\", \"2-digit\", \"narrow\", \"short\", \"long\". Defaults to 'long'.\n     * @param opts - options\n     * @param opts.locale - the locale code\n     * @param opts.numberingSystem - the numbering system. Defaults to null.\n     * @param opts.locObj - an existing locale object to use. Defaults to null.\n     * @param opts.outputCalendar - the calendar. Defaults to 'gregory'.\n     *\n     * @example\n     * Info.months()[0] //=> 'January'\n     * @example\n     * Info.months('short')[0] //=> 'Jan'\n     * @example\n     * Info.months('numeric')[0] //=> '1'\n     * @example\n     * Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'\n     * @example\n     * Info.months('numeric', { locale: 'ar' })[0] //=> '١'\n     * @example\n     * Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabiʻ I'\n     */\n    function months(length?: UnitLength, opts?: InfoCalendarOptions): string[];\n\n    /**\n     * Return an array of format month names.\n     * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that\n     * changes the string.\n     * See {@link Info#months}\n     *\n     * @param length - the length of the month representation, such as \"numeric\", \"2-digit\", \"narrow\", \"short\", \"long\". Defaults to 'long'.\n     * @param opts - options\n     * @param opts.locale - the locale code\n     * @param opts.numberingSystem - the numbering system. Defaults to null.\n     * @param opts.locObj - an existing locale object to use. Defaults to null.\n     * @param opts.outputCalendar - the calendar. Defaults to 'gregory'.\n     */\n    function monthsFormat(length?: UnitLength, options?: InfoCalendarOptions): string[];\n\n    /**\n     * Return an array of standalone week names.\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat\n     *\n     * @param length - the length of the weekday representation, such as \"narrow\", \"short\", \"long\". Defaults to 'long'.\n     * @param opts - options\n     * @param opts.locale - the locale code\n     * @param opts.numberingSystem - the numbering system. Defaults to null.\n     * @param opts.locObj - an existing locale object to use. Defaults to null.\n     *\n     * @example\n     * Info.weekdays()[0] //=> 'Monday'\n     * @example\n     * Info.weekdays('short')[0] //=> 'Mon'\n     * @example\n     * Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'\n     * @example\n     * Info.weekdays('short', { locale: 'ar' })[0] //=> 'الاثنين'\n     */\n    function weekdays(length?: StringUnitLength, options?: InfoUnitOptions): string[];\n\n    /**\n     * Return an array of format week names.\n     * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that\n     * changes the string.\n     * See {@link Info#weekdays}\n     *\n     * @param length - the length of the month representation, such as \"narrow\", \"short\", \"long\". Defaults to 'long'.\n     * @param opts - options\n     * @param opts.locale - the locale code. Defaults to null.\n     * @param opts.numberingSystem - the numbering system. Defaults to null.\n     * @param opts.locObj - an existing locale object to use. Defaults to null.\n     */\n    function weekdaysFormat(length?: StringUnitLength, options?: InfoUnitOptions): string[];\n\n    /**\n     * Return an array of meridiems.\n     *\n     * @param opts - options\n     * @param opts.locale - the locale code\n     *\n     * @example\n     * Info.meridiems() //=> [ 'AM', 'PM' ]\n     * @example\n     * Info.meridiems({ locale: 'my' }) //=> [ 'နံနက်', 'ညနေ' ]\n     */\n    function meridiems(options?: InfoOptions): string[];\n\n    /**\n     * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.\n     *\n     * @param length - the length of the era representation, such as \"short\" or \"long\". Defaults to 'short'.\n     * @param opts - options\n     * @param opts.locale - the locale code\n     *\n     * @example\n     * Info.eras() //=> [ 'BC', 'AD' ]\n     * @example\n     * Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]\n     * @example\n     * Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jésus-Christ', 'après Jésus-Christ' ]\n     */\n    function eras(length?: StringUnitLength, options?: InfoOptions): string[];\n\n    /**\n     * Return the set of available features in this environment.\n     * Some features of Luxon are not available in all environments. For example, on older browsers, timezone support is not available. Use this function to figure out if that's the case.\n     * Keys:\n     * * `relative`: whether this environment supports relative time formatting\n     *\n     * @example\n     * Info.features() //=> { intl: true, intlTokens: false, zones: true, relative: false }\n     */\n    function features(): Features;\n}\n","node_modules/@types/luxon/src/interval.d.ts":"import { DateTime, DateObjectUnits, DateTimeOptions, DiffOptions, ToISOTimeOptions } from './datetime';\nimport { Duration, DurationLike, DurationUnit } from './duration';\n\nexport interface IntervalObject {\n    start?: DateTime | undefined;\n    end?: DateTime | undefined;\n}\n\nexport type DateInput = DateTime | DateObjectUnits | Date;\n\n/**\n * An Interval object represents a half-open interval of time, where each endpoint is a {@link DateTime}. Conceptually, it's a container for those two endpoints, accompanied by methods for\n * creating, parsing, interrogating, comparing, transforming, and formatting them.\n *\n * Here is a brief overview of the most commonly used methods and getters in Interval:\n *\n * * **Creation** To create an Interval, use {@link Interval.fromDateTimes}, {@link Interval.after}, {@link Interval.before}, or {@link Interval.fromISO}.\n * * **Accessors** Use {@link Interval#start} and {@link Interval#end} to get the start and end.\n * * **Interrogation** To analyze the Interval, use {@link Interval#count}, {@link Interval#length}, {@link Interval#hasSame},\n * * {@link Interval#contains}, {@link Interval#isAfter}, or {@link Interval#isBefore}.\n * * **Transformation** To create other Intervals out of this one, use {@link Interval#set}, {@link Interval#splitAt}, {@link Interval#splitBy}, {@link Interval#divideEqually},\n * * {@link Interval#merge}, {@link Interval#xor}, {@link Interval#union}, {@link Interval#intersection}, or {@link Interval#difference}.\n * * **Comparison** To compare this Interval to another one, use {@link Interval#equals}, {@link Interval#overlaps}, {@link Interval#abutsStart}, {@link Interval#abutsEnd}, {@link Interval#engulfs}\n * * **Output** To convert the Interval into other representations, see {@link Interval#toString}, {@link Interval#toISO}, {@link Interval#toISODate}, {@link Interval#toISOTime},\n * * {@link Interval#toFormat}, and {@link Interval#toDuration}.\n */\nexport class Interval {\n    /**\n     * Create an invalid Interval.\n     *\n     * @param reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent\n     * @param explanation - longer explanation, may include parameters and other useful debugging information. Defaults to null.\n     */\n    static invalid(reason: string, explanation?: string): Interval;\n\n    /**\n     * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.\n     *\n     * @param start\n     * @param end\n     */\n    static fromDateTimes(start: DateInput, end: DateInput): Interval;\n\n    /**\n     * Create an Interval from a start DateTime and a Duration to extend to.\n     *\n     * @param start\n     * @param duration - the length of the Interval.\n     */\n    static after(start: DateInput, duration: DurationLike): Interval;\n\n    /**\n     * Create an Interval from an end DateTime and a Duration to extend backwards to.\n     *\n     * @param end\n     * @param duration - the length of the Interval.\n     */\n    static before(end: DateInput, duration: DurationLike): Interval;\n\n    /**\n     * Create an Interval from an ISO 8601 string.\n     * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.\n     * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals\n     *\n     * @param text - the ISO string to parse\n     * @param opts - options to pass {@link DateTime.fromISO} and optionally {@link Duration.fromISO}\n     */\n    static fromISO(text: string, opts?: DateTimeOptions): Interval;\n\n    /**\n     * Check if an object is an Interval. Works across context boundaries\n     *\n     * @param o\n     */\n    static isInterval(o: unknown): o is Interval;\n\n    private constructor(config: unknown);\n\n    /**\n     * Returns the start of the Interval\n     */\n    get start(): DateTime;\n\n    /**\n     * Returns the end of the Interval\n     */\n    get end(): DateTime;\n\n    /**\n     * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.\n     */\n    get isValid(): boolean;\n\n    /**\n     * Returns an error code if this Interval is invalid, or null if the Interval is valid\n     */\n    get invalidReason(): string;\n\n    /**\n     * Returns an explanation of why this Interval became invalid, or null if the Interval is valid\n     */\n    get invalidExplanation(): string;\n\n    /**\n     * Returns the length of the Interval in the specified unit.\n     *\n     * @param unit - the unit (such as 'hours' or 'days') to return the length in.\n     */\n    length(unit?: DurationUnit): number;\n\n    /**\n     * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.\n     * Unlike {@link Interval#length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'\n     * asks 'what dates are included in this interval?', not 'how many days long is this interval?'\n     *\n     * @param unit - the unit of time to count. Defaults to 'milliseconds'.\n     */\n    count(unit?: DurationUnit): number;\n\n    /**\n     * Returns whether this Interval's start and end are both in the same unit of time\n     *\n     * @param unit - the unit of time to check sameness on\n     */\n    hasSame(unit: DurationUnit): boolean;\n\n    /**\n     * Return whether this Interval has the same start and end DateTimes.\n     */\n    isEmpty(): boolean;\n\n    /**\n     * Return whether this Interval's start is after the specified DateTime.\n     *\n     * @param dateTime\n     */\n    isAfter(dateTime: DateTime): boolean;\n\n    /**\n     * Return whether this Interval's end is before the specified DateTime.\n     *\n     * @param dateTime\n     */\n    isBefore(dateTime: DateTime): boolean;\n\n    /**\n     * Return whether this Interval contains the specified DateTime.\n     *\n     * @param dateTime\n     */\n    contains(dateTime: DateTime): boolean;\n\n    /**\n     * \"Sets\" the start and/or end dates. Returns a newly-constructed Interval.\n     *\n     * @param values - the values to set\n     * @param values.start - the starting DateTime\n     * @param values.end - the ending DateTime\n     */\n    set(values?: IntervalObject): Interval;\n\n    /**\n     * Split this Interval at each of the specified DateTimes\n     *\n     * @param dateTimes - the unit of time to count.\n     */\n    splitAt(...dateTimes: DateTime[]): Interval[];\n\n    /**\n     * Split this Interval into smaller Intervals, each of the specified length.\n     * Left over time is grouped into a smaller interval\n     *\n     * @param duration - The length of each resulting interval.\n     */\n    splitBy(duration: DurationLike): Interval[];\n\n    /**\n     * Split this Interval into the specified number of smaller intervals.\n     *\n     * @param numberOfParts - The number of Intervals to divide the Interval into.\n     */\n    divideEqually(numberOfParts: number): Interval[];\n\n    /**\n     * Return whether this Interval overlaps with the specified Interval\n     *\n     * @param other\n     */\n    overlaps(other: Interval): boolean;\n\n    /**\n     * Return whether this Interval's end is adjacent to the specified Interval's start.\n     *\n     * @param other\n     */\n    abutsStart(other: Interval): boolean;\n\n    /**\n     * Return whether this Interval's start is adjacent to the specified Interval's end.\n     *\n     * @param other\n     */\n    abutsEnd(other: Interval): boolean;\n\n    /**\n     * Return whether this Interval engulfs the start and end of the specified Interval.\n     *\n     * @param other\n     */\n    engulfs(other: Interval): boolean;\n\n    /**\n     * Return whether this Interval has the same start and end as the specified Interval.\n     *\n     * @param other\n     */\n    equals(other: Interval): boolean;\n\n    /**\n     * Return an Interval representing the intersection of this Interval and the specified Interval.\n     * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.\n     * Returns null if the intersection is empty, meaning, the intervals don't intersect.\n     *\n     * @param other\n     */\n    intersection(other: Interval): Interval | null;\n\n    /**\n     * Return an Interval representing the union of this Interval and the specified Interval.\n     * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.\n     *\n     * @param other\n     */\n    union(other: Interval): Interval;\n\n    /**\n     * Merge an array of Intervals into a equivalent minimal set of Intervals.\n     * Combines overlapping and adjacent Intervals.\n     *\n     * @param intervals\n     */\n    static merge(intervals: Interval[]): Interval[];\n\n    /**\n     * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.\n     *\n     *  @param intervals\n     */\n    static xor(intervals: Interval[]): Interval[];\n\n    /**\n     * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.\n     *\n     * @param intervals\n     */\n    difference(...intervals: Interval[]): Interval[];\n\n    /**\n     * Returns a string representation of this Interval appropriate for debugging.\n     */\n    toString(): string;\n\n    /**\n     * Returns an ISO 8601-compliant string representation of this Interval.\n     * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals\n     *\n     * @param opts - The same options as {@link DateTime#toISO}\n     */\n    toISO(opts?: ToISOTimeOptions): string;\n\n    /**\n     * Returns an ISO 8601-compliant string representation of date of this Interval.\n     * The time components are ignored.\n     * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals\n     */\n    toISODate(): string;\n\n    /**\n     * Returns an ISO 8601-compliant string representation of time of this Interval.\n     * The date components are ignored.\n     * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals\n     *\n     * @param opts - The same options as {@link DateTime.toISO}\n     */\n    toISOTime(opts?: ToISOTimeOptions): string;\n\n    /**\n     * Returns a string representation of this Interval formatted according to the specified format string.\n     *\n     * @param dateFormat - the format string. This string formats the start and end time. See {@link DateTime.toFormat} for details.\n     * @param opts - options\n     * @param opts.separator - a separator to place between the start and end representations. Defaults to ' - '.\n     */\n    toFormat(\n        dateFormat: string,\n        opts?: {\n            separator?: string | undefined;\n        },\n    ): string;\n\n    /**\n     * Return a Duration representing the time spanned by this interval.\n     *\n     * @param unit - the unit or units (such as 'hours' or 'days') to include in the duration. Defaults to ['milliseconds'].\n     * @param opts - options that affect the creation of the Duration\n     * @param opts.conversionAccuracy - the conversion system to use. Defaults to 'casual'.\n     *\n     * @example\n     * Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }\n     * @example\n     * Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }\n     * @example\n     * Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }\n     * @example\n     * Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }\n     * @example\n     * Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }\n     */\n    toDuration(unit?: DurationUnit | DurationUnit[], opts?: DiffOptions): Duration;\n\n    /**\n     * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes\n     *\n     * @param mapFn\n     *\n     * @example\n     * Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())\n     * @example\n     * Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))\n     */\n    mapEndpoints(mapFn: (d: DateTime) => DateTime): Interval;\n}\n","node_modules/@types/luxon/src/luxon.d.ts":"export const VERSION: string;\n\nexport * from './datetime';\nexport * from './duration';\nexport * from './info';\nexport * from './interval';\nexport * from './settings';\nexport * from './zone';\nexport * from './misc';\n","node_modules/@types/luxon/src/misc.d.ts":"export type DateTimeFormatOptions = Intl.DateTimeFormatOptions;\n\nexport interface ZoneOptions {\n    /**\n     * If true, adjust the underlying time so that the local time stays the same, but in the target zone.\n     * You should rarely need this.\n     * Defaults to false.\n     */\n    keepLocalTime?: boolean | undefined;\n    /**\n     * @deprecated since 0.2.12. Use keepLocalTime instead\n     */\n    keepCalendarTime?: boolean | undefined;\n}\n\n/** @deprecated */\nexport type EraLength = StringUnitLength;\n\nexport type NumberingSystem = Intl.DateTimeFormatOptions extends { numberingSystem?: infer T }\n    ? T\n    :\n          | 'arab'\n          | 'arabext'\n          | 'bali'\n          | 'beng'\n          | 'deva'\n          | 'fullwide'\n          | 'gujr'\n          | 'guru'\n          | 'hanidec'\n          | 'khmr'\n          | 'knda'\n          | 'laoo'\n          | 'latn'\n          | 'limb'\n          | 'mlym'\n          | 'mong'\n          | 'mymr'\n          | 'orya'\n          | 'tamldec'\n          | 'telu'\n          | 'thai'\n          | 'tibt';\n\nexport type CalendarSystem = Intl.DateTimeFormatOptions extends { calendar?: infer T }\n    ? T\n    :\n          | 'buddhist'\n          | 'chinese'\n          | 'coptic'\n          | 'ethioaa'\n          | 'ethiopic'\n          | 'gregory'\n          | 'hebrew'\n          | 'indian'\n          | 'islamic'\n          | 'islamicc'\n          | 'iso8601'\n          | 'japanese'\n          | 'persian'\n          | 'roc';\n\nexport type HourCycle = 'h11' | 'h12' | 'h23' | 'h24';\n\nexport type StringUnitLength = 'narrow' | 'short' | 'long';\nexport type NumberUnitLength = 'numeric' | '2-digit';\nexport type UnitLength = StringUnitLength | NumberUnitLength;\n","node_modules/@types/luxon/src/settings.d.ts":"import { Zone } from './zone';\n\n/**\n * Settings contains static getters and setters that control Luxon's overall behavior.\n * Luxon is a simple library with few options, but the ones it does have live here.\n */\n// tslint:disable-next-line:no-unnecessary-class\nexport class Settings {\n    /**\n     * Get the callback for returning the current timestamp.\n     */\n    static get now(): () => number;\n\n    /**\n     * Set the callback for returning the current timestamp.\n     * The function should return a number, which will be interpreted as an Epoch millisecond count\n     *\n     * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future\n     * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time\n     */\n    static set now(now: () => number);\n\n    /**\n     * The default time zone object currently used to create DateTimes. Does not affect existing instances.\n     * The default value is the system's time zone (the one set on the machine that runs this code).\n     * Getting this property always returns a Zone object.\n     */\n    static defaultZone: Zone | string;\n\n    /**\n     * Get the default locale to create DateTimes with. Does not affect existing instances.\n     */\n    static get defaultLocale(): string;\n\n    /**\n     * Set the default locale to create DateTimes with. Does not affect existing instances.\n     */\n    static set defaultLocale(locale: string);\n\n    /**\n     * Get the default numbering system to create DateTimes with. Does not affect existing instances.\n     */\n    static get defaultNumberingSystem(): string;\n\n    /**\n     * Set the default numbering system to create DateTimes with. Does not affect existing instances.\n     */\n    static set defaultNumberingSystem(numberingSystem: string);\n\n    /**\n     * Get the default output calendar to create DateTimes with. Does not affect existing instances.\n     */\n    static get defaultOutputCalendar(): string;\n\n    /**\n     * Set the default output calendar to create DateTimes with. Does not affect existing instances.\n     */\n    static set defaultOutputCalendar(outputCalendar: string);\n\n    /**\n     * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals\n     */\n    static get throwOnInvalid(): boolean;\n\n    /**\n     * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals\n     */\n    static set throwOnInvalid(t: boolean);\n\n    /**\n     * Reset Luxon's global caches. Should only be necessary in testing scenarios.\n     */\n    static resetCaches(): void;\n}\n","node_modules/@types/luxon/src/zone.d.ts":"export interface ZoneOffsetOptions {\n    /**\n     * What style of offset to return.\n     */\n    format?: 'short' | 'long' | undefined;\n    /**\n     * What locale to return the offset name in.\n     */\n    locale?: string | undefined;\n}\n\n/**\n * What style of offset to return.\n * Returning '+6', '+06:00', or '+0600' respectively\n */\nexport type ZoneOffsetFormat = 'narrow' | 'short' | 'techie';\n\nexport abstract class Zone {\n    /**\n     * The type of zone\n     */\n    get type(): string;\n\n    /**\n     * The name of this zone.\n     */\n    get name(): string;\n\n    /**\n     * Returns whether the offset is known to be fixed for the whole year.\n     */\n    get isUniversal(): boolean;\n\n    /**\n     * Returns the offset's common name (such as EST) at the specified timestamp\n     *\n     * @param ts - Epoch milliseconds for which to get the name\n     * @param options - Options to affect the format\n     * @param options.format - What style of offset to return.\n     * @param options.locale - What locale to return the offset name in.\n     */\n    offsetName(ts: number, options: ZoneOffsetOptions): string;\n\n    /**\n     * Returns the offset's value as a string\n     *\n     * @param ts - Epoch milliseconds for which to get the offset\n     * @param format - What style of offset to return.\n     *                 Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively\n     */\n    formatOffset(ts: number, format: ZoneOffsetFormat): string;\n\n    /**\n     * Return the offset in minutes for this zone at the specified timestamp.\n     *\n     * @param ts - Epoch milliseconds for which to compute the offset\n     */\n    offset(ts: number): number;\n\n    /**\n     * Return whether this Zone is equal to another zone\n     *\n     * @param other - the zone to compare\n     */\n    equals(other: Zone): boolean;\n\n    /**\n     * Return whether this Zone is valid.\n     */\n    get isValid(): boolean;\n}\n\n/**\n * A zone identified by an IANA identifier, like America/New_York\n */\nexport class IANAZone extends Zone {\n    /**\n     * Same as constructor but has caching.\n     */\n    static create(name: string): IANAZone;\n\n    /**\n     * Reset local caches. Should only be necessary in testing scenarios.\n     */\n    static resetCache(): void;\n\n    /**\n     * Returns whether the provided string is a valid specifier.\n     * This only checks the string's format, not that the specifier\n     * identifies a known zone; see {@link isValidZone} for that.\n     *\n     * @param s - The string to check validity on\n     *\n     * @example\n     * IANAZone.isValidSpecifier(\"America/New_York\") //=> true\n     * @example\n     * IANAZone.isValidSpecifier(\"Fantasia/Castle\") //=> true\n     * @example\n     * IANAZone.isValidSpecifier(\"Sport~~blorp\") //=> false\n     */\n    static isValidSpecifier(s: string): boolean;\n\n    /**\n     * Returns whether the provided string identifies a real zone\n     *\n     * @param zone - The string to check\n     *\n     * @example\n     * IANAZone.isValidZone(\"America/New_York\") //=> true\n     * @example\n     * IANAZone.isValidZone(\"Fantasia/Castle\") //=> false\n     * @example\n     * IANAZone.isValidZone(\"Sport~~blorp\") //=> false\n     */\n    static isValidZone(zone: string): boolean;\n\n    constructor(name: string);\n}\n\n/**\n * A zone with a fixed offset (meaning no DST)\n */\nexport class FixedOffsetZone extends Zone {\n    /**\n     * Get a singleton instance of UTC\n     */\n    static get utcInstance(): FixedOffsetZone;\n\n    /**\n     * Get an instance with a specified offset\n     *\n     * @param offset - The offset in minutes\n     */\n    static instance(offset: number): FixedOffsetZone;\n\n    /**\n     * Get an instance of FixedOffsetZone from a UTC offset string, like \"UTC+6\"\n     *\n     * @param s - The offset string to parse\n     *\n     * @example\n     * FixedOffsetZone.parseSpecifier(\"UTC+6\")\n     * @example\n     * FixedOffsetZone.parseSpecifier(\"UTC+06\")\n     * @example\n     * FixedOffsetZone.parseSpecifier(\"UTC-6:00\")\n     */\n    static parseSpecifier(s: string): FixedOffsetZone;\n}\n\n/**\n * A zone that failed to parse. You should never need to instantiate this.\n */\nexport class InvalidZone extends Zone {}\n\n/**\n * Represents the system zone for this JavaScript environment.\n */\nexport class SystemZone extends Zone {\n    /**\n     * Get a singleton instance of the system zone\n     */\n    static get instance(): SystemZone;\n}\n","node_modules/@types/big.js/index.d.ts":"declare namespace Big {\n    type BigSource = number | string | Big;\n\n    /**\n     * GT = 1, EQ = 0, LT = -1\n     */\n    type Comparison = -1 | 0 | 1;\n\n    /**\n     * RoundDown = 0, RoundHalfUp = 1, RoundHalfEven = 2, RoundUp = 3\n     */\n    type RoundingMode = 0 | 1 | 2 | 3;\n\n    interface BigConstructor {\n        /**\n         * Returns a new instance of a Big number object\n         *\n         * String values may be in exponential, as well as normal (non-exponential) notation.\n         * There is no limit to the number of digits of a string value (other than that of Javascript's maximum array size), but the largest recommended exponent magnitude is 1e+6.\n         * Infinity, NaN and hexadecimal literal strings, e.g. '0xff', are not valid.\n         * String values in octal literal form will be interpreted as decimals, e.g. '011' is 11, not 9.\n         *\n         * @throws `NaN` on an invalid value.\n         */\n        new(value: BigSource): Big;\n\n        /**\n         * Returns a new instance of a Big number object\n         *\n         * String values may be in exponential, as well as normal (non-exponential) notation.\n         * There is no limit to the number of digits of a string value (other than that of Javascript's maximum array size), but the largest recommended exponent magnitude is 1e+6.\n         * Infinity, NaN and hexadecimal literal strings, e.g. '0xff', are not valid.\n         * String values in octal literal form will be interpreted as decimals, e.g. '011' is 11, not 9.\n         *\n         * @throws `NaN` on an invalid value.\n         */\n        (value: BigSource): Big;\n\n        /**\n         * Create an additional Big number constructor\n         *\n         * Values created with the returned constructor will have a separate set of configuration values.\n         * This can be used to create Big objects with different DP and RM values.\n         * Big numbers created by different constructors can be used together in operations, and it is the DP and RM setting of the Big number that an operation is called upon that will apply.\n         * In the interest of memory efficiency, all Big number constructors share the same prototype object,\n         * so while the DP and RM (and any other own properties) of a constructor are isolated and untouchable by another, its prototype methods are not.\n         */\n        (): BigConstructor;\n\n        /**\n         * The maximum number of decimal places of the results of operations involving division.\n         * It is relevant only to the div and sqrt methods, and the pow method when the exponent is negative.\n         *\n         * 0 to 1e+6 inclusive\n         * Default value: 20\n         */\n        DP: number;\n        /**\n         * The rounding mode used in the above operations and by round, toExponential, toFixed and toPrecision.\n         * Default value: 1\n         */\n        RM: number;\n        /**\n         * The negative exponent value at and below which toString returns exponential notation.\n         *\n         * -1e+6 to 0 inclusive\n         * Default value: -7\n         */\n        NE: number;\n        /**\n         * The positive exponent value at and above which toString returns exponential notation.\n         *\n         * 0 to 1e+6 inclusive\n         * Default value: 21\n         */\n        PE: number;\n        /**\n         * When set to true, an error will be thrown if a primitive number is passed to the Big constructor,\n         * or if valueOf is called, or if toNumber is called on a Big which cannot be converted to a primitive number without a loss of precision.\n         *\n         * true|false\n         * Default value: false\n         */\n        strict: boolean;\n\n        /** Readonly rounding modes */\n\n        /**\n         * Rounds towards zero.\n         * I.e. truncate, no rounding.\n         */\n        readonly roundDown: 0;\n        /**\n         * Rounds towards nearest neighbour.\n         * If equidistant, rounds away from zero.\n         */\n        readonly roundHalfUp: 1;\n        /**\n         * Rounds towards nearest neighbour.\n         * If equidistant, rounds towards even neighbour.\n         */\n        readonly roundHalfEven: 2;\n        /**\n         * Rounds away from zero.\n         */\n        readonly roundUp: 3;\n\n        readonly Big: BigConstructor;\n    }\n\n    interface Big {\n        /** Returns a Big number whose value is the absolute value, i.e. the magnitude, of this Big number. */\n        abs(): Big;\n        /**\n         * Returns a Big number whose value is the value of this Big number plus n - alias for .plus().\n         *\n         * @throws `NaN` if n is invalid.\n         */\n        add(n: BigSource): Big;\n        /**\n         * Compare the values.\n         *\n         * @throws `NaN` if n is invalid.\n         */\n        cmp(n: BigSource): Comparison;\n        /**\n         * Returns a Big number whose value is the value of this Big number divided by n.\n         *\n         * If the result has more fraction digits than is specified by Big.DP, it will be rounded to Big.DP decimal places using rounding mode Big.RM.\n         *\n         * @throws `NaN` if n is invalid.\n         * @throws `±Infinity` on division by zero.\n         * @throws `NaN` on division of zero by zero.\n         */\n        div(n: BigSource): Big;\n        /**\n         * Returns true if the value of this Big equals the value of n, otherwise returns false.\n         *\n         * @throws `NaN` if n is invalid.\n         */\n        eq(n: BigSource): boolean;\n        /**\n         * Returns true if the value of this Big is greater than the value of n, otherwise returns false.\n         *\n         * @throws `NaN` if n is invalid.\n         */\n        gt(n: BigSource): boolean;\n        /**\n         * Returns true if the value of this Big is greater than or equal to the value of n, otherwise returns false.\n         *\n         * @throws `NaN` if n is invalid.\n         */\n        gte(n: BigSource): boolean;\n        /**\n         * Returns true if the value of this Big is less than the value of n, otherwise returns false.\n         *\n         * @throws `NaN` if n is invalid.\n         */\n        lt(n: BigSource): boolean;\n        /**\n         * Returns true if the value of this Big is less than or equal to the value of n, otherwise returns false.\n         *\n         * @throws `NaN` if n is invalid.\n         */\n        lte(n: BigSource): boolean;\n        /**\n         * Returns a Big number whose value is the value of this Big number minus n.\n         *\n         * @throws `NaN` if n is invalid.\n         */\n        minus(n: BigSource): Big;\n        /**\n         * Returns a Big number whose value is the value of this Big number modulo n, i.e. the integer remainder of dividing this Big number by n.\n         *\n         * The result will have the same sign as this Big number, and it will match that of Javascript's % operator (within the limits of its precision) and BigDecimal's remainder method.\n         *\n         * @throws `NaN` if n is negative or otherwise invalid.\n         */\n        mod(n: BigSource): Big;\n        /**\n         * Returns a Big number whose value is the value of this Big number times n - alias for .times().\n         *\n         * @throws `NaN` if n is invalid.\n         */\n        mul(n: BigSource): Big;\n        /**\n         * Return a new Big whose value is the value of this Big negated.\n         */\n        neg(): Big;\n        /**\n         * Returns a Big number whose value is the value of this Big number plus n.\n         *\n         * @throws `NaN` if n is invalid.\n         */\n        plus(n: BigSource): Big;\n        /**\n         * Returns a Big number whose value is the value of this Big number raised to the power exp.\n         *\n         * If exp is negative and the result has more fraction digits than is specified by Big.DP, it will be rounded to Big.DP decimal places using rounding mode Big.RM.\n         *\n         * @param exp The power to raise the number to, -1e+6 to 1e+6 inclusive\n         * @throws `!pow!` if exp is invalid.\n         *\n         * Note: High value exponents may cause this method to be slow to return.\n         */\n        pow(exp: number): Big;\n        /**\n         * Return a new Big whose value is the value of this Big rounded to a maximum precision of sd\n         * significant digits using rounding mode rm, or Big.RM if rm is not specified.\n         *\n         * @param sd Significant digits: integer, 1 to MAX_DP inclusive.\n         * @param rm Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\n         * @throws `!prec!` if sd is invalid.\n         * @throws `!Big.RM!` if rm is invalid.\n         */\n        prec(sd: number, rm?: RoundingMode): Big;\n        /**\n         * Returns a Big number whose value is the value of this Big number rounded using rounding mode rm to a maximum of dp decimal places.\n         *\n         * @param dp Decimal places, 0 to 1e+6 inclusive\n         * @param rm Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\n         * @throws `!round!` if dp is invalid.\n         * @throws `!Big.RM!` if rm is invalid.\n         */\n        round(dp?: number, rm?: RoundingMode): Big;\n        /**\n         * Returns a Big number whose value is the square root of this Big number.\n         *\n         * If the result has more fraction digits than is specified by Big.DP, it will be rounded to Big.DP decimal places using rounding mode Big.RM.\n         *\n         * @throws `NaN` if this Big number is negative.\n         */\n        sqrt(): Big;\n        /**\n         * Returns a Big number whose value is the value of this Big number minus n - alias for .minus().\n         *\n         * @throws `NaN` if n is invalid.\n         */\n        sub(n: BigSource): Big;\n        /**\n         * Returns a Big number whose value is the value of this Big number times n.\n         *\n         * @throws `NaN` if n is invalid.\n         */\n        times(n: BigSource): Big;\n        /**\n         * Returns a string representing the value of this Big number in exponential notation to a fixed number of decimal places dp.\n         *\n         * If the value of this Big number in exponential notation has more digits to the right of the decimal point than is specified by dp,\n         * the return value will be rounded to dp decimal places using rounding mode Big.RM.\n         *\n         * If the value of this Big number in exponential notation has fewer digits to the right of the decimal point than is specified by dp, the return value will be appended with zeros accordingly.\n         *\n         * If dp is omitted, or is null or undefined, the number of digits after the decimal point defaults to the minimum number of digits necessary to represent the value exactly.\n         *\n         * @param dp Decimal places, 0 to 1e+6 inclusive\n         * @param rm Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\n         * @throws `!toFix!` if dp is invalid.\n         */\n        toExponential(dp?: number, rm?: RoundingMode): string;\n        /**\n         * Returns a string representing the value of this Big number in normal notation to a fixed number of decimal places dp.\n         *\n         * If the value of this Big number in normal notation has more digits to the right of the decimal point than is specified by dp,\n         * the return value will be rounded to dp decimal places using rounding mode Big.RM.\n         *\n         * If the value of this Big number in normal notation has fewer fraction digits then is specified by dp, the return value will be appended with zeros accordingly.\n         *\n         * Unlike Number.prototype.toFixed, which returns exponential notation if a number is greater or equal to 1021, this method will always return normal notation.\n         *\n         * If dp is omitted, or is null or undefined, then the return value is simply the value in normal notation.\n         * This is also unlike Number.prototype.toFixed, which returns the value to zero decimal places.\n         *\n         * @param dp Decimal places, 0 to 1e+6 inclusive\n         * @param rm Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\n         * @throws `!toFix!` if dp is invalid.\n         */\n        toFixed(dp?: number, rm?: RoundingMode): string;\n        /**\n         * Returns a string representing the value of this Big number to the specified number of significant digits sd.\n         *\n         * If the value of this Big number has more digits than is specified by sd, the return value will be rounded to sd significant digits using rounding mode Big.RM.\n         *\n         * If the value of this Big number has fewer digits than is specified by sd, the return value will be appended with zeros accordingly.\n         *\n         * If sd is less than the number of digits necessary to represent the integer part of the value in normal notation, then exponential notation is used.\n         *\n         * If sd is omitted, or is null or undefined, then the return value is the same as .toString().\n         *\n         * @param sd Significant digits, 1 to 1e+6 inclusive\n         * @param rm Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\n         * @throws `!toPre!` if sd is invalid.\n         */\n        toPrecision(sd?: number, rm?: RoundingMode): string;\n        /**\n         * Returns a string representing the value of this Big number.\n         *\n         * If this Big number has a positive exponent that is equal to or greater than 21, or a negative exponent equal to or less than -7, then exponential notation is returned.\n         *\n         * The point at which toString returns exponential rather than normal notation can be adjusted by changing\n         * the value of Big.E_POS and Big.E_NEG. By default, Big numbers correspond to Javascript's number type in this regard.\n         */\n        toString(): string;\n        /**\n         * Returns a primitive number representing the value of this Big number.\n         *\n         * If Big.strict is true an error will be thrown if toNumber is called on a Big number which cannot be converted to a primitive number without a loss of precision.\n         *\n         * @since 6.0\n         */\n        toNumber(): number;\n        /**\n         * Returns a string representing the value of this Big number.\n         *\n         * If this Big number has a positive exponent that is equal to or greater than 21, or a negative exponent equal to or less than -7, then exponential notation is returned.\n         *\n         * The point at which toString returns exponential rather than normal notation can be adjusted by changing\n         * the value of Big.E_POS and Big.E_NEG. By default, Big numbers correspond to Javascript's number type in this regard.\n         */\n        valueOf(): string;\n        /**\n         * Returns a string representing the value of this Big number.\n         *\n         * If this Big number has a positive exponent that is equal to or greater than 21, or a negative exponent equal to or less than -7, then exponential notation is returned.\n         *\n         * The point at which toString returns exponential rather than normal notation can be adjusted by changing\n         * the value of Big.E_POS and Big.E_NEG. By default, Big numbers correspond to Javascript's number type in this regard.\n         */\n        toJSON(): string;\n        /**\n         * Returns an array of single digits\n         */\n        c: number[];\n        /**\n         * Returns the exponent, Integer, -1e+6 to 1e+6 inclusive\n         */\n        e: number;\n        /**\n         * Returns the sign, -1 or 1\n         */\n        s: number;\n    }\n}\n\n// We want the exported symbol 'Big' to represent two things:\n// - The Big interface, when used in a type context.\n// - The BigConstructor instance, when used in a value context.\ndeclare const Big: Big.BigConstructor;\ntype Big = Big.Big;\n\n// The export is the same as type/value combo symbol 'Big'.\nexport = Big;\nexport as namespace Big;\n","pgPool.ts":"\n      import * as pg from 'pg';\n      export default new pg.Pool();"};