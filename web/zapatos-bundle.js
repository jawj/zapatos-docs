const zapatosBundle = {"custom/PgGeometry.d.ts":"/*\n** Please edit this file as needed **\nIt's been generated by Zapatos as a custom type definition placeholder, and won't be overwritten\n*/\n\ndeclare module 'zapatos/custom' {\n  export type PgGeometry = any;  // replace with your custom type or interface as desired\n}\n","custom/index.d.ts":"/*\n** DON'T EDIT THIS FILE **\nIt's been generated by Zapatos (v3.4.0), and is liable to be overwritten\n\nZapatos: https://jawj.github.io/zapatos/\nCopyright (C) 2020 George MacKerron\nReleased under the MIT licence: see LICENCE file\n*/\n\n// this empty declaration appears to fix relative imports in other custom type files\ndeclare module 'zapatos/custom' { }\n","schema.d.ts":"/*\n** DON'T EDIT THIS FILE **\nIt's been generated by Zapatos (v3.4.0), and is liable to be overwritten\n\nZapatos: https://jawj.github.io/zapatos/\nCopyright (C) 2020 George MacKerron\nReleased under the MIT licence: see LICENCE file\n*/\n\ndeclare module 'zapatos/schema' {\n\n  import type * as db from 'zapatos/db';\n  import type * as c from 'zapatos/custom';\n\n  // got a type error on schemaVersionCanary below? update by running `npx zapatos`\n  export interface schemaVersionCanary extends db.SchemaVersionCanary { version: 101 }\n\n  type JSONSelectableFromSelectable<T> = { [K in keyof T]:\n    Date extends T[K] ? Exclude<T[K], Date> | db.DateString :\n    Date[] extends T[K] ? Exclude<T[K], Date[]> | db.DateString[] :\n    T[K]\n  };\n\n  /* === schema: public === */\n\n  /* --- enums --- */\n\n  export type appleEnvironment = 'PROD' | 'Sandbox';\n  export namespace every {\n    export type appleEnvironment = ['PROD', 'Sandbox'];\n  }\n\n  /* --- tables --- */\n\n  export namespace appleTransactions {\n    export type Table = 'appleTransactions';\n    export interface Selectable {\n      /**\n      * **appleTransactions.environment**\n      * - `appleEnvironment` in database\n      * - `NOT NULL`, no default\n      */\n      environment: appleEnvironment;\n      /**\n      * **appleTransactions.originalTransactionId**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      originalTransactionId: string;\n      /**\n      * **appleTransactions.accountId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      accountId: number;\n      /**\n      * **appleTransactions.latestReceiptData**\n      * - `text` in database\n      * - Nullable, no default\n      */\n      latestReceiptData: string | null;\n    }\n    export interface Whereable {\n      /**\n      * **appleTransactions.environment**\n      * - `appleEnvironment` in database\n      * - `NOT NULL`, no default\n      */\n      environment?: appleEnvironment | db.Parameter<appleEnvironment> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, appleEnvironment | db.Parameter<appleEnvironment> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **appleTransactions.originalTransactionId**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      originalTransactionId?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **appleTransactions.accountId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      accountId?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **appleTransactions.latestReceiptData**\n      * - `text` in database\n      * - Nullable, no default\n      */\n      latestReceiptData?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **appleTransactions.environment**\n      * - `appleEnvironment` in database\n      * - `NOT NULL`, no default\n      */\n      environment: appleEnvironment | db.Parameter<appleEnvironment> | db.SQLFragment;\n      /**\n      * **appleTransactions.originalTransactionId**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      originalTransactionId: string | db.Parameter<string> | db.SQLFragment;\n      /**\n      * **appleTransactions.accountId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      accountId: number | db.Parameter<number> | db.SQLFragment;\n      /**\n      * **appleTransactions.latestReceiptData**\n      * - `text` in database\n      * - Nullable, no default\n      */\n      latestReceiptData?: string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **appleTransactions.environment**\n      * - `appleEnvironment` in database\n      * - `NOT NULL`, no default\n      */\n      environment?: appleEnvironment | db.Parameter<appleEnvironment> | db.SQLFragment | db.SQLFragment<any, appleEnvironment | db.Parameter<appleEnvironment> | db.SQLFragment>;\n      /**\n      * **appleTransactions.originalTransactionId**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      originalTransactionId?: string | db.Parameter<string> | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment>;\n      /**\n      * **appleTransactions.accountId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      accountId?: number | db.Parameter<number> | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment>;\n      /**\n      * **appleTransactions.latestReceiptData**\n      * - `text` in database\n      * - Nullable, no default\n      */\n      latestReceiptData?: string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment>;\n    }\n    export interface JSONSelectable extends JSONSelectableFromSelectable<Selectable> { }\n    export type UniqueIndex = 'appleTransactionsPrimaryKey';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = db.GenericSQLExpression | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Table | Whereable | Column;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  export namespace arrays {\n    export type Table = 'arrays';\n    export interface Selectable {\n      /**\n      * **arrays.jsonValue**\n      * - `jsonb` in database\n      * - Nullable, no default\n      */\n      jsonValue: db.JSONValue | null;\n      /**\n      * **arrays.textArray**\n      * - `_text` in database\n      * - Nullable, no default\n      */\n      textArray: string[] | null;\n    }\n    export interface Whereable {\n      /**\n      * **arrays.jsonValue**\n      * - `jsonb` in database\n      * - Nullable, no default\n      */\n      jsonValue?: db.JSONValue | db.Parameter<db.JSONValue> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, db.JSONValue | db.Parameter<db.JSONValue> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **arrays.textArray**\n      * - `_text` in database\n      * - Nullable, no default\n      */\n      textArray?: string[] | db.Parameter<string[]> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string[] | db.Parameter<string[]> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **arrays.jsonValue**\n      * - `jsonb` in database\n      * - Nullable, no default\n      */\n      jsonValue?: db.JSONValue | db.Parameter<db.JSONValue> | null | db.DefaultType | db.SQLFragment;\n      /**\n      * **arrays.textArray**\n      * - `_text` in database\n      * - Nullable, no default\n      */\n      textArray?: string[] | db.Parameter<string[]> | null | db.DefaultType | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **arrays.jsonValue**\n      * - `jsonb` in database\n      * - Nullable, no default\n      */\n      jsonValue?: db.JSONValue | db.Parameter<db.JSONValue> | null | db.DefaultType | db.SQLFragment | db.SQLFragment<any, db.JSONValue | db.Parameter<db.JSONValue> | null | db.DefaultType | db.SQLFragment>;\n      /**\n      * **arrays.textArray**\n      * - `_text` in database\n      * - Nullable, no default\n      */\n      textArray?: string[] | db.Parameter<string[]> | null | db.DefaultType | db.SQLFragment | db.SQLFragment<any, string[] | db.Parameter<string[]> | null | db.DefaultType | db.SQLFragment>;\n    }\n    export interface JSONSelectable extends JSONSelectableFromSelectable<Selectable> { }\n    export type UniqueIndex = never;\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = db.GenericSQLExpression | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Table | Whereable | Column;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  export namespace authors {\n    export type Table = 'authors';\n    export interface Selectable {\n      /**\n      * **authors.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('authors_id_seq'::regclass)`\n      */\n      id: number;\n      /**\n      * **authors.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name: string;\n      /**\n      * **authors.isLiving**\n      * - `bool` in database\n      * - Nullable, no default\n      */\n      isLiving: boolean | null;\n    }\n    export interface Whereable {\n      /**\n      * **authors.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('authors_id_seq'::regclass)`\n      */\n      id?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **authors.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **authors.isLiving**\n      * - `bool` in database\n      * - Nullable, no default\n      */\n      isLiving?: boolean | db.Parameter<boolean> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, boolean | db.Parameter<boolean> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **authors.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('authors_id_seq'::regclass)`\n      */\n      id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;\n      /**\n      * **authors.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name: string | db.Parameter<string> | db.SQLFragment;\n      /**\n      * **authors.isLiving**\n      * - `bool` in database\n      * - Nullable, no default\n      */\n      isLiving?: boolean | db.Parameter<boolean> | null | db.DefaultType | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **authors.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('authors_id_seq'::regclass)`\n      */\n      id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.DefaultType | db.SQLFragment>;\n      /**\n      * **authors.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name?: string | db.Parameter<string> | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment>;\n      /**\n      * **authors.isLiving**\n      * - `bool` in database\n      * - Nullable, no default\n      */\n      isLiving?: boolean | db.Parameter<boolean> | null | db.DefaultType | db.SQLFragment | db.SQLFragment<any, boolean | db.Parameter<boolean> | null | db.DefaultType | db.SQLFragment>;\n    }\n    export interface JSONSelectable extends JSONSelectableFromSelectable<Selectable> { }\n    export type UniqueIndex = 'authors_pkey';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = db.GenericSQLExpression | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Table | Whereable | Column;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  export namespace bankAccounts {\n    export type Table = 'bankAccounts';\n    export interface Selectable {\n      /**\n      * **bankAccounts.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('\"bankAccounts_id_seq\"'::regclass)`\n      */\n      id: number;\n      /**\n      * **bankAccounts.balance**\n      * - `int4` in database\n      * - `NOT NULL`, default: `0`\n      */\n      balance: number;\n    }\n    export interface Whereable {\n      /**\n      * **bankAccounts.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('\"bankAccounts_id_seq\"'::regclass)`\n      */\n      id?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **bankAccounts.balance**\n      * - `int4` in database\n      * - `NOT NULL`, default: `0`\n      */\n      balance?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **bankAccounts.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('\"bankAccounts_id_seq\"'::regclass)`\n      */\n      id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;\n      /**\n      * **bankAccounts.balance**\n      * - `int4` in database\n      * - `NOT NULL`, default: `0`\n      */\n      balance?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **bankAccounts.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('\"bankAccounts_id_seq\"'::regclass)`\n      */\n      id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.DefaultType | db.SQLFragment>;\n      /**\n      * **bankAccounts.balance**\n      * - `int4` in database\n      * - `NOT NULL`, default: `0`\n      */\n      balance?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.DefaultType | db.SQLFragment>;\n    }\n    export interface JSONSelectable extends JSONSelectableFromSelectable<Selectable> { }\n    export type UniqueIndex = 'bankAccounts_pkey';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = db.GenericSQLExpression | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Table | Whereable | Column;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  export namespace books {\n    export type Table = 'books';\n    export interface Selectable {\n      /**\n      * **books.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('books_id_seq'::regclass)`\n      */\n      id: number;\n      /**\n      * **books.authorId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      authorId: number;\n      /**\n      * **books.title**\n      * - `text` in database\n      * - Nullable, no default\n      */\n      title: string | null;\n      /**\n      * **books.createdAt**\n      * - `timestamptz` in database\n      * - `NOT NULL`, default: `now()`\n      */\n      createdAt: Date;\n    }\n    export interface Whereable {\n      /**\n      * **books.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('books_id_seq'::regclass)`\n      */\n      id?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **books.authorId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      authorId?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **books.title**\n      * - `text` in database\n      * - Nullable, no default\n      */\n      title?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **books.createdAt**\n      * - `timestamptz` in database\n      * - `NOT NULL`, default: `now()`\n      */\n      createdAt?: Date | db.Parameter<Date> | db.DateString | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, Date | db.Parameter<Date> | db.DateString | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **books.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('books_id_seq'::regclass)`\n      */\n      id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;\n      /**\n      * **books.authorId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      authorId: number | db.Parameter<number> | db.SQLFragment;\n      /**\n      * **books.title**\n      * - `text` in database\n      * - Nullable, no default\n      */\n      title?: string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment;\n      /**\n      * **books.createdAt**\n      * - `timestamptz` in database\n      * - `NOT NULL`, default: `now()`\n      */\n      createdAt?: Date | db.Parameter<Date> | db.DateString | db.DefaultType | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **books.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('books_id_seq'::regclass)`\n      */\n      id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.DefaultType | db.SQLFragment>;\n      /**\n      * **books.authorId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      authorId?: number | db.Parameter<number> | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment>;\n      /**\n      * **books.title**\n      * - `text` in database\n      * - Nullable, no default\n      */\n      title?: string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment>;\n      /**\n      * **books.createdAt**\n      * - `timestamptz` in database\n      * - `NOT NULL`, default: `now()`\n      */\n      createdAt?: Date | db.Parameter<Date> | db.DateString | db.DefaultType | db.SQLFragment | db.SQLFragment<any, Date | db.Parameter<Date> | db.DateString | db.DefaultType | db.SQLFragment>;\n    }\n    export interface JSONSelectable extends JSONSelectableFromSelectable<Selectable> { }\n    export type UniqueIndex = 'books_pkey';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = db.GenericSQLExpression | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Table | Whereable | Column;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  export namespace doctors {\n    export type Table = 'doctors';\n    export interface Selectable {\n      /**\n      * **doctors.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('doctors_id_seq'::regclass)`\n      */\n      id: number;\n      /**\n      * **doctors.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name: string;\n    }\n    export interface Whereable {\n      /**\n      * **doctors.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('doctors_id_seq'::regclass)`\n      */\n      id?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **doctors.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **doctors.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('doctors_id_seq'::regclass)`\n      */\n      id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;\n      /**\n      * **doctors.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name: string | db.Parameter<string> | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **doctors.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('doctors_id_seq'::regclass)`\n      */\n      id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.DefaultType | db.SQLFragment>;\n      /**\n      * **doctors.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name?: string | db.Parameter<string> | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment>;\n    }\n    export interface JSONSelectable extends JSONSelectableFromSelectable<Selectable> { }\n    export type UniqueIndex = 'doctors_pkey';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = db.GenericSQLExpression | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Table | Whereable | Column;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  export namespace emailAuthentication {\n    export type Table = 'emailAuthentication';\n    export interface Selectable {\n      /**\n      * **emailAuthentication.email**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      email: string;\n      /**\n      * **emailAuthentication.consecutiveFailedLogins**\n      * - `int4` in database\n      * - `NOT NULL`, default: `0`\n      */\n      consecutiveFailedLogins: number;\n      /**\n      * **emailAuthentication.lastFailedLogin**\n      * - `timestamptz` in database\n      * - Nullable, no default\n      */\n      lastFailedLogin: Date | null;\n    }\n    export interface Whereable {\n      /**\n      * **emailAuthentication.email**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      email?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **emailAuthentication.consecutiveFailedLogins**\n      * - `int4` in database\n      * - `NOT NULL`, default: `0`\n      */\n      consecutiveFailedLogins?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **emailAuthentication.lastFailedLogin**\n      * - `timestamptz` in database\n      * - Nullable, no default\n      */\n      lastFailedLogin?: Date | db.Parameter<Date> | db.DateString | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, Date | db.Parameter<Date> | db.DateString | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **emailAuthentication.email**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      email: string | db.Parameter<string> | db.SQLFragment;\n      /**\n      * **emailAuthentication.consecutiveFailedLogins**\n      * - `int4` in database\n      * - `NOT NULL`, default: `0`\n      */\n      consecutiveFailedLogins?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;\n      /**\n      * **emailAuthentication.lastFailedLogin**\n      * - `timestamptz` in database\n      * - Nullable, no default\n      */\n      lastFailedLogin?: Date | db.Parameter<Date> | db.DateString | null | db.DefaultType | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **emailAuthentication.email**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      email?: string | db.Parameter<string> | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment>;\n      /**\n      * **emailAuthentication.consecutiveFailedLogins**\n      * - `int4` in database\n      * - `NOT NULL`, default: `0`\n      */\n      consecutiveFailedLogins?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.DefaultType | db.SQLFragment>;\n      /**\n      * **emailAuthentication.lastFailedLogin**\n      * - `timestamptz` in database\n      * - Nullable, no default\n      */\n      lastFailedLogin?: Date | db.Parameter<Date> | db.DateString | null | db.DefaultType | db.SQLFragment | db.SQLFragment<any, Date | db.Parameter<Date> | db.DateString | null | db.DefaultType | db.SQLFragment>;\n    }\n    export interface JSONSelectable extends JSONSelectableFromSelectable<Selectable> { }\n    export type UniqueIndex = 'emailAuthentication_pkey';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = db.GenericSQLExpression | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Table | Whereable | Column;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  export namespace employees {\n    export type Table = 'employees';\n    export interface Selectable {\n      /**\n      * **employees.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('employees_id_seq'::regclass)`\n      */\n      id: number;\n      /**\n      * **employees.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name: string;\n      /**\n      * **employees.managerId**\n      * - `int4` in database\n      * - Nullable, no default\n      */\n      managerId: number | null;\n    }\n    export interface Whereable {\n      /**\n      * **employees.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('employees_id_seq'::regclass)`\n      */\n      id?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **employees.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **employees.managerId**\n      * - `int4` in database\n      * - Nullable, no default\n      */\n      managerId?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **employees.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('employees_id_seq'::regclass)`\n      */\n      id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;\n      /**\n      * **employees.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name: string | db.Parameter<string> | db.SQLFragment;\n      /**\n      * **employees.managerId**\n      * - `int4` in database\n      * - Nullable, no default\n      */\n      managerId?: number | db.Parameter<number> | null | db.DefaultType | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **employees.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('employees_id_seq'::regclass)`\n      */\n      id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.DefaultType | db.SQLFragment>;\n      /**\n      * **employees.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name?: string | db.Parameter<string> | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment>;\n      /**\n      * **employees.managerId**\n      * - `int4` in database\n      * - Nullable, no default\n      */\n      managerId?: number | db.Parameter<number> | null | db.DefaultType | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | null | db.DefaultType | db.SQLFragment>;\n    }\n    export interface JSONSelectable extends JSONSelectableFromSelectable<Selectable> { }\n    export type UniqueIndex = 'employees_pkey';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = db.GenericSQLExpression | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Table | Whereable | Column;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  export namespace nameCounts {\n    export type Table = 'nameCounts';\n    export interface Selectable {\n      /**\n      * **nameCounts.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name: string;\n      /**\n      * **nameCounts.count**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      count: number;\n    }\n    export interface Whereable {\n      /**\n      * **nameCounts.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **nameCounts.count**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      count?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **nameCounts.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name: string | db.Parameter<string> | db.SQLFragment;\n      /**\n      * **nameCounts.count**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      count: number | db.Parameter<number> | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **nameCounts.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name?: string | db.Parameter<string> | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment>;\n      /**\n      * **nameCounts.count**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      count?: number | db.Parameter<number> | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment>;\n    }\n    export interface JSONSelectable extends JSONSelectableFromSelectable<Selectable> { }\n    export type UniqueIndex = 'nameCounts_pkey';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = db.GenericSQLExpression | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Table | Whereable | Column;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  export namespace photos {\n    export type Table = 'photos';\n    export interface Selectable {\n      /**\n      * **photos.photoId**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n      photoId: number;\n      /**\n      * **photos.url**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      url: string;\n    }\n    export interface Whereable {\n      /**\n      * **photos.photoId**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n      photoId?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **photos.url**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      url?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **photos.photoId**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n      photoId?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;\n      /**\n      * **photos.url**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      url: string | db.Parameter<string> | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **photos.photoId**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n      photoId?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.DefaultType | db.SQLFragment>;\n      /**\n      * **photos.url**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      url?: string | db.Parameter<string> | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment>;\n    }\n    export interface JSONSelectable extends JSONSelectableFromSelectable<Selectable> { }\n    export type UniqueIndex = 'photos_pkey';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = db.GenericSQLExpression | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Table | Whereable | Column;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  export namespace shifts {\n    export type Table = 'shifts';\n    export interface Selectable {\n      /**\n      * **shifts.day**\n      * - `date` in database\n      * - `NOT NULL`, no default\n      */\n      day: Date;\n      /**\n      * **shifts.doctorId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      doctorId: number;\n    }\n    export interface Whereable {\n      /**\n      * **shifts.day**\n      * - `date` in database\n      * - `NOT NULL`, no default\n      */\n      day?: Date | db.Parameter<Date> | db.DateString | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, Date | db.Parameter<Date> | db.DateString | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **shifts.doctorId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      doctorId?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **shifts.day**\n      * - `date` in database\n      * - `NOT NULL`, no default\n      */\n      day: Date | db.Parameter<Date> | db.DateString | db.SQLFragment;\n      /**\n      * **shifts.doctorId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      doctorId: number | db.Parameter<number> | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **shifts.day**\n      * - `date` in database\n      * - `NOT NULL`, no default\n      */\n      day?: Date | db.Parameter<Date> | db.DateString | db.SQLFragment | db.SQLFragment<any, Date | db.Parameter<Date> | db.DateString | db.SQLFragment>;\n      /**\n      * **shifts.doctorId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      doctorId?: number | db.Parameter<number> | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment>;\n    }\n    export interface JSONSelectable extends JSONSelectableFromSelectable<Selectable> { }\n    export type UniqueIndex = 'shifts_pkey';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = db.GenericSQLExpression | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Table | Whereable | Column;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  export namespace stores {\n    export type Table = 'stores';\n    export interface Selectable {\n      /**\n      * **stores.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('stores_id_seq'::regclass)`\n      */\n      id: number;\n      /**\n      * **stores.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name: string;\n      /**\n      * **stores.geom**\n      * - `geometry` in database\n      * - `NOT NULL`, no default\n      */\n      geom: c.PgGeometry;\n    }\n    export interface Whereable {\n      /**\n      * **stores.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('stores_id_seq'::regclass)`\n      */\n      id?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **stores.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **stores.geom**\n      * - `geometry` in database\n      * - `NOT NULL`, no default\n      */\n      geom?: c.PgGeometry | db.Parameter<c.PgGeometry> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, c.PgGeometry | db.Parameter<c.PgGeometry> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **stores.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('stores_id_seq'::regclass)`\n      */\n      id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;\n      /**\n      * **stores.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name: string | db.Parameter<string> | db.SQLFragment;\n      /**\n      * **stores.geom**\n      * - `geometry` in database\n      * - `NOT NULL`, no default\n      */\n      geom: c.PgGeometry | db.Parameter<c.PgGeometry> | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **stores.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('stores_id_seq'::regclass)`\n      */\n      id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.DefaultType | db.SQLFragment>;\n      /**\n      * **stores.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name?: string | db.Parameter<string> | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment>;\n      /**\n      * **stores.geom**\n      * - `geometry` in database\n      * - `NOT NULL`, no default\n      */\n      geom?: c.PgGeometry | db.Parameter<c.PgGeometry> | db.SQLFragment | db.SQLFragment<any, c.PgGeometry | db.Parameter<c.PgGeometry> | db.SQLFragment>;\n    }\n    export interface JSONSelectable extends JSONSelectableFromSelectable<Selectable> { }\n    export type UniqueIndex = 'stores_pkey';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = db.GenericSQLExpression | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Table | Whereable | Column;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  export namespace subjectPhotos {\n    export type Table = 'subjectPhotos';\n    export interface Selectable {\n      /**\n      * **subjectPhotos.subjectId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      subjectId: number;\n      /**\n      * **subjectPhotos.photoId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      photoId: number;\n    }\n    export interface Whereable {\n      /**\n      * **subjectPhotos.subjectId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      subjectId?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **subjectPhotos.photoId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      photoId?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **subjectPhotos.subjectId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      subjectId: number | db.Parameter<number> | db.SQLFragment;\n      /**\n      * **subjectPhotos.photoId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      photoId: number | db.Parameter<number> | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **subjectPhotos.subjectId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      subjectId?: number | db.Parameter<number> | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment>;\n      /**\n      * **subjectPhotos.photoId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      photoId?: number | db.Parameter<number> | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment>;\n    }\n    export interface JSONSelectable extends JSONSelectableFromSelectable<Selectable> { }\n    export type UniqueIndex = 'userphotosunique';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = db.GenericSQLExpression | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Table | Whereable | Column;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  export namespace subjects {\n    export type Table = 'subjects';\n    export interface Selectable {\n      /**\n      * **subjects.subjectId**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n      subjectId: number;\n      /**\n      * **subjects.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name: string;\n    }\n    export interface Whereable {\n      /**\n      * **subjects.subjectId**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n      subjectId?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **subjects.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **subjects.subjectId**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n      subjectId?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;\n      /**\n      * **subjects.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name: string | db.Parameter<string> | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **subjects.subjectId**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n      subjectId?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.DefaultType | db.SQLFragment>;\n      /**\n      * **subjects.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name?: string | db.Parameter<string> | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment>;\n    }\n    export interface JSONSelectable extends JSONSelectableFromSelectable<Selectable> { }\n    export type UniqueIndex = 'subjects_pkey';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = db.GenericSQLExpression | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Table | Whereable | Column;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  export namespace tags {\n    export type Table = 'tags';\n    export interface Selectable {\n      /**\n      * **tags.tag**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      tag: string;\n      /**\n      * **tags.bookId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      bookId: number;\n    }\n    export interface Whereable {\n      /**\n      * **tags.tag**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      tag?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **tags.bookId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      bookId?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **tags.tag**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      tag: string | db.Parameter<string> | db.SQLFragment;\n      /**\n      * **tags.bookId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      bookId: number | db.Parameter<number> | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **tags.tag**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      tag?: string | db.Parameter<string> | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment>;\n      /**\n      * **tags.bookId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      bookId?: number | db.Parameter<number> | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment>;\n    }\n    export interface JSONSelectable extends JSONSelectableFromSelectable<Selectable> { }\n    export type UniqueIndex = 'tagsUniqueIdx';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = db.GenericSQLExpression | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Table | Whereable | Column;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  export namespace usedVoucherCodes {\n    export type Table = 'usedVoucherCodes';\n    export interface Selectable {\n      /**\n      * **usedVoucherCodes.code**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      code: string;\n      /**\n      * **usedVoucherCodes.redeemedAt**\n      * - `timestamptz` in database\n      * - `NOT NULL`, default: `now()`\n      */\n      redeemedAt: Date;\n    }\n    export interface Whereable {\n      /**\n      * **usedVoucherCodes.code**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      code?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **usedVoucherCodes.redeemedAt**\n      * - `timestamptz` in database\n      * - `NOT NULL`, default: `now()`\n      */\n      redeemedAt?: Date | db.Parameter<Date> | db.DateString | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, Date | db.Parameter<Date> | db.DateString | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **usedVoucherCodes.code**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      code: string | db.Parameter<string> | db.SQLFragment;\n      /**\n      * **usedVoucherCodes.redeemedAt**\n      * - `timestamptz` in database\n      * - `NOT NULL`, default: `now()`\n      */\n      redeemedAt?: Date | db.Parameter<Date> | db.DateString | db.DefaultType | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **usedVoucherCodes.code**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      code?: string | db.Parameter<string> | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment>;\n      /**\n      * **usedVoucherCodes.redeemedAt**\n      * - `timestamptz` in database\n      * - `NOT NULL`, default: `now()`\n      */\n      redeemedAt?: Date | db.Parameter<Date> | db.DateString | db.DefaultType | db.SQLFragment | db.SQLFragment<any, Date | db.Parameter<Date> | db.DateString | db.DefaultType | db.SQLFragment>;\n    }\n    export interface JSONSelectable extends JSONSelectableFromSelectable<Selectable> { }\n    export type UniqueIndex = 'usedVoucherCodes_pkey';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = db.GenericSQLExpression | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Table | Whereable | Column;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  export namespace users {\n    export type Table = 'users';\n    export interface Selectable {\n      /**\n      * **users.id**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n      id: number;\n      /**\n      * **users.ipOctet**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n      ipOctet: number;\n      /**\n      * **users.friendlyName**\n      * - `text` in database\n      * - Nullable, no default\n      */\n      friendlyName: string | null;\n    }\n    export interface Whereable {\n      /**\n      * **users.id**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n      id?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **users.ipOctet**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n      ipOctet?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **users.friendlyName**\n      * - `text` in database\n      * - Nullable, no default\n      */\n      friendlyName?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **users.id**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n      id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;\n      /**\n      * **users.ipOctet**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n      ipOctet?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;\n      /**\n      * **users.friendlyName**\n      * - `text` in database\n      * - Nullable, no default\n      */\n      friendlyName?: string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **users.id**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n      id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.DefaultType | db.SQLFragment>;\n      /**\n      * **users.ipOctet**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n      ipOctet?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.DefaultType | db.SQLFragment>;\n      /**\n      * **users.friendlyName**\n      * - `text` in database\n      * - Nullable, no default\n      */\n      friendlyName?: string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment>;\n    }\n    export interface JSONSelectable extends JSONSelectableFromSelectable<Selectable> { }\n    export type UniqueIndex = 'users_pkey' | 'users_ipOctet_key';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = db.GenericSQLExpression | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Table | Whereable | Column;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  /* === cross-table types === */\n\n  export type Table = appleTransactions.Table | arrays.Table | authors.Table | bankAccounts.Table | books.Table | doctors.Table | emailAuthentication.Table | employees.Table | nameCounts.Table | photos.Table | shifts.Table | stores.Table | subjectPhotos.Table | subjects.Table | tags.Table | usedVoucherCodes.Table | users.Table;\n  export type Selectable = appleTransactions.Selectable | arrays.Selectable | authors.Selectable | bankAccounts.Selectable | books.Selectable | doctors.Selectable | emailAuthentication.Selectable | employees.Selectable | nameCounts.Selectable | photos.Selectable | shifts.Selectable | stores.Selectable | subjectPhotos.Selectable | subjects.Selectable | tags.Selectable | usedVoucherCodes.Selectable | users.Selectable;\n  export type Whereable = appleTransactions.Whereable | arrays.Whereable | authors.Whereable | bankAccounts.Whereable | books.Whereable | doctors.Whereable | emailAuthentication.Whereable | employees.Whereable | nameCounts.Whereable | photos.Whereable | shifts.Whereable | stores.Whereable | subjectPhotos.Whereable | subjects.Whereable | tags.Whereable | usedVoucherCodes.Whereable | users.Whereable;\n  export type Insertable = appleTransactions.Insertable | arrays.Insertable | authors.Insertable | bankAccounts.Insertable | books.Insertable | doctors.Insertable | emailAuthentication.Insertable | employees.Insertable | nameCounts.Insertable | photos.Insertable | shifts.Insertable | stores.Insertable | subjectPhotos.Insertable | subjects.Insertable | tags.Insertable | usedVoucherCodes.Insertable | users.Insertable;\n  export type Updatable = appleTransactions.Updatable | arrays.Updatable | authors.Updatable | bankAccounts.Updatable | books.Updatable | doctors.Updatable | emailAuthentication.Updatable | employees.Updatable | nameCounts.Updatable | photos.Updatable | shifts.Updatable | stores.Updatable | subjectPhotos.Updatable | subjects.Updatable | tags.Updatable | usedVoucherCodes.Updatable | users.Updatable;\n  export type UniqueIndex = appleTransactions.UniqueIndex | arrays.UniqueIndex | authors.UniqueIndex | bankAccounts.UniqueIndex | books.UniqueIndex | doctors.UniqueIndex | emailAuthentication.UniqueIndex | employees.UniqueIndex | nameCounts.UniqueIndex | photos.UniqueIndex | shifts.UniqueIndex | stores.UniqueIndex | subjectPhotos.UniqueIndex | subjects.UniqueIndex | tags.UniqueIndex | usedVoucherCodes.UniqueIndex | users.UniqueIndex;\n  export type Column = appleTransactions.Column | arrays.Column | authors.Column | bankAccounts.Column | books.Column | doctors.Column | emailAuthentication.Column | employees.Column | nameCounts.Column | photos.Column | shifts.Column | stores.Column | subjectPhotos.Column | subjects.Column | tags.Column | usedVoucherCodes.Column | users.Column;\n  export type AllTables = [appleTransactions.Table, arrays.Table, authors.Table, bankAccounts.Table, books.Table, doctors.Table, emailAuthentication.Table, employees.Table, nameCounts.Table, photos.Table, shifts.Table, stores.Table, subjectPhotos.Table, subjects.Table, tags.Table, usedVoucherCodes.Table, users.Table];\n  export type AllMaterializedViews = [];\n\n\n  export type SelectableForTable<T extends Table> = {\n    appleTransactions: appleTransactions.Selectable;\n    arrays: arrays.Selectable;\n    authors: authors.Selectable;\n    bankAccounts: bankAccounts.Selectable;\n    books: books.Selectable;\n    doctors: doctors.Selectable;\n    emailAuthentication: emailAuthentication.Selectable;\n    employees: employees.Selectable;\n    nameCounts: nameCounts.Selectable;\n    photos: photos.Selectable;\n    shifts: shifts.Selectable;\n    stores: stores.Selectable;\n    subjectPhotos: subjectPhotos.Selectable;\n    subjects: subjects.Selectable;\n    tags: tags.Selectable;\n    usedVoucherCodes: usedVoucherCodes.Selectable;\n    users: users.Selectable;\n  }[T];\n\n  export type WhereableForTable<T extends Table> = {\n    appleTransactions: appleTransactions.Whereable;\n    arrays: arrays.Whereable;\n    authors: authors.Whereable;\n    bankAccounts: bankAccounts.Whereable;\n    books: books.Whereable;\n    doctors: doctors.Whereable;\n    emailAuthentication: emailAuthentication.Whereable;\n    employees: employees.Whereable;\n    nameCounts: nameCounts.Whereable;\n    photos: photos.Whereable;\n    shifts: shifts.Whereable;\n    stores: stores.Whereable;\n    subjectPhotos: subjectPhotos.Whereable;\n    subjects: subjects.Whereable;\n    tags: tags.Whereable;\n    usedVoucherCodes: usedVoucherCodes.Whereable;\n    users: users.Whereable;\n  }[T];\n\n  export type InsertableForTable<T extends Table> = {\n    appleTransactions: appleTransactions.Insertable;\n    arrays: arrays.Insertable;\n    authors: authors.Insertable;\n    bankAccounts: bankAccounts.Insertable;\n    books: books.Insertable;\n    doctors: doctors.Insertable;\n    emailAuthentication: emailAuthentication.Insertable;\n    employees: employees.Insertable;\n    nameCounts: nameCounts.Insertable;\n    photos: photos.Insertable;\n    shifts: shifts.Insertable;\n    stores: stores.Insertable;\n    subjectPhotos: subjectPhotos.Insertable;\n    subjects: subjects.Insertable;\n    tags: tags.Insertable;\n    usedVoucherCodes: usedVoucherCodes.Insertable;\n    users: users.Insertable;\n  }[T];\n\n  export type UpdatableForTable<T extends Table> = {\n    appleTransactions: appleTransactions.Updatable;\n    arrays: arrays.Updatable;\n    authors: authors.Updatable;\n    bankAccounts: bankAccounts.Updatable;\n    books: books.Updatable;\n    doctors: doctors.Updatable;\n    emailAuthentication: emailAuthentication.Updatable;\n    employees: employees.Updatable;\n    nameCounts: nameCounts.Updatable;\n    photos: photos.Updatable;\n    shifts: shifts.Updatable;\n    stores: stores.Updatable;\n    subjectPhotos: subjectPhotos.Updatable;\n    subjects: subjects.Updatable;\n    tags: tags.Updatable;\n    usedVoucherCodes: usedVoucherCodes.Updatable;\n    users: users.Updatable;\n  }[T];\n\n  export type UniqueIndexForTable<T extends Table> = {\n    appleTransactions: appleTransactions.UniqueIndex;\n    arrays: arrays.UniqueIndex;\n    authors: authors.UniqueIndex;\n    bankAccounts: bankAccounts.UniqueIndex;\n    books: books.UniqueIndex;\n    doctors: doctors.UniqueIndex;\n    emailAuthentication: emailAuthentication.UniqueIndex;\n    employees: employees.UniqueIndex;\n    nameCounts: nameCounts.UniqueIndex;\n    photos: photos.UniqueIndex;\n    shifts: shifts.UniqueIndex;\n    stores: stores.UniqueIndex;\n    subjectPhotos: subjectPhotos.UniqueIndex;\n    subjects: subjects.UniqueIndex;\n    tags: tags.UniqueIndex;\n    usedVoucherCodes: usedVoucherCodes.UniqueIndex;\n    users: users.UniqueIndex;\n  }[T];\n\n  export type ColumnForTable<T extends Table> = {\n    appleTransactions: appleTransactions.Column;\n    arrays: arrays.Column;\n    authors: authors.Column;\n    bankAccounts: bankAccounts.Column;\n    books: books.Column;\n    doctors: doctors.Column;\n    emailAuthentication: emailAuthentication.Column;\n    employees: employees.Column;\n    nameCounts: nameCounts.Column;\n    photos: photos.Column;\n    shifts: shifts.Column;\n    stores: stores.Column;\n    subjectPhotos: subjectPhotos.Column;\n    subjects: subjects.Column;\n    tags: tags.Column;\n    usedVoucherCodes: usedVoucherCodes.Column;\n    users: users.Column;\n  }[T];\n\n  export type SQLForTable<T extends Table> = {\n    appleTransactions: appleTransactions.SQL;\n    arrays: arrays.SQL;\n    authors: authors.SQL;\n    bankAccounts: bankAccounts.SQL;\n    books: books.SQL;\n    doctors: doctors.SQL;\n    emailAuthentication: emailAuthentication.SQL;\n    employees: employees.SQL;\n    nameCounts: nameCounts.SQL;\n    photos: photos.SQL;\n    shifts: shifts.SQL;\n    stores: stores.SQL;\n    subjectPhotos: subjectPhotos.SQL;\n    subjects: subjects.SQL;\n    tags: tags.SQL;\n    usedVoucherCodes: usedVoucherCodes.SQL;\n    users: users.SQL;\n  }[T];\n\n}\n","node_modules/@types/zapatos/db/canary.d.ts":"/**\n * This value gets incremented whenever there's an incompatible change to the\n * generated schema format, in order to raise a type error and thereby force\n * schema regeneration.\n */\nexport interface SchemaVersionCanary {\n    version: 101;\n}\n","node_modules/@types/zapatos/db/conditions.d.ts":"import { SQLFragment } from './core';\nexport declare const isNull: SQLFragment<boolean, never>;\nexport declare const isNotNull: SQLFragment<boolean, never>;\nexport declare const isTrue: SQLFragment<boolean, never>;\nexport declare const isNotTrue: SQLFragment<boolean, never>;\nexport declare const isFalse: SQLFragment<boolean, never>;\nexport declare const isNotFalse: SQLFragment<boolean, never>;\nexport declare const isUnknown: SQLFragment<boolean, never>;\nexport declare const isNotUnknown: SQLFragment<boolean, never>;\nexport declare const isDistinctFrom: <T>(a: T) => SQLFragment<boolean, T>;\nexport declare const isNotDistinctFrom: <T>(a: T) => SQLFragment<boolean, T>;\nexport declare const eq: <T>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const ne: <T>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const gt: <T>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const gte: <T>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const lt: <T>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const lte: <T>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const between: <T>(a: T, b: T) => SQLFragment<boolean | null, T>;\nexport declare const betweenSymmetric: <T>(a: T, b: T) => SQLFragment<boolean | null, T>;\nexport declare const notBetween: <T>(a: T, b: T) => SQLFragment<boolean | null, T>;\nexport declare const notBetweenSymmetric: <T>(a: T, b: T) => SQLFragment<boolean | null, T>;\nexport declare const like: <T extends string>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const notLike: <T extends string>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const ilike: <T extends string>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const notIlike: <T extends string>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const similarTo: <T extends string>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const notSimilarTo: <T extends string>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const reMatch: <T extends string>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const reImatch: <T extends string>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const notReMatch: <T extends string>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const notReImatch: <T extends string>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const isIn: <T>(a: T[]) => SQLFragment<boolean | null, T> | SQLFragment<any[], never>;\nexport declare const isNotIn: <T>(a: T[]) => SQLFragment<any[], never> | SQLFragment<boolean | null, T>;\nexport declare const or: <T>(...conditions: SQLFragment<any, T>[]) => SQLFragment<boolean | null, T>;\nexport declare const and: <T>(...conditions: SQLFragment<any, T>[]) => SQLFragment<boolean | null, T>;\nexport declare const not: <T>(condition: SQLFragment<any, T>) => SQLFragment<boolean | null, T>;\ndeclare type IntervalUnit = 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day' | 'week' | 'month' | 'year' | 'decade' | 'century' | 'millennium';\nexport declare const fromNow: (n: number, unit?: IntervalUnit) => SQLFragment<any[], never>;\nexport declare const after: <T>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const before: <T>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const add: <T extends number | Date>(a: T) => SQLFragment<number, T>;\nexport declare const subtract: <T extends number | Date>(a: T) => SQLFragment<number, T>;\nexport {};\n","node_modules/@types/zapatos/db/config.d.ts":"export interface SQLQuery {\n    text: string;\n    values: any[];\n}\nexport interface Config {\n    transactionAttemptsMax: number;\n    transactionRetryDelay: {\n        minMs: number;\n        maxMs: number;\n    };\n    castArrayParamsToJson: boolean;\n    castObjectParamsToJson: boolean;\n    queryListener?(query: SQLQuery, txnId?: number): void;\n    resultListener?(result: any, txnId?: number, elapsedMs?: number): void;\n    transactionListener?(message: string, txnId?: number): void;\n}\nexport declare type NewConfig = Partial<Config>;\n/**\n * Get (a copy of) the current configuration.\n */\nexport declare const getConfig: () => {\n    transactionAttemptsMax: number;\n    transactionRetryDelay: {\n        minMs: number;\n        maxMs: number;\n    };\n    castArrayParamsToJson: boolean;\n    castObjectParamsToJson: boolean;\n    queryListener?(query: SQLQuery, txnId?: number | undefined): void;\n    resultListener?(result: any, txnId?: number | undefined, elapsedMs?: number | undefined): void;\n    transactionListener?(message: string, txnId?: number | undefined): void;\n};\n/**\n * Set key(s) on the configuration.\n * @param newConfig Partial configuration object\n */\nexport declare const setConfig: (newConfig: NewConfig) => {\n    transactionAttemptsMax: number;\n    transactionRetryDelay: {\n        minMs: number;\n        maxMs: number;\n    };\n    castArrayParamsToJson: boolean;\n    castObjectParamsToJson: boolean;\n    queryListener?: ((query: SQLQuery, txnId?: number | undefined) => void) | undefined;\n    resultListener?: ((result: any, txnId?: number | undefined, elapsedMs?: number | undefined) => void) | undefined;\n    transactionListener?: ((message: string, txnId?: number | undefined) => void) | undefined;\n};\n","node_modules/@types/zapatos/db/core.d.ts":"import type * as pg from 'pg';\nimport { SQLQuery } from './config';\nimport { NoInfer } from './utils';\nimport type { Updatable, Whereable, Table, Column } from 'zapatos/schema';\n/**\n * Compiles to `DEFAULT` for use in `INSERT`/`UPDATE` queries.\n */\nexport declare const Default: unique symbol;\nexport declare type DefaultType = typeof Default;\n/**\n * Compiles to the current column name within a `Whereable`.\n */\nexport declare const self: unique symbol;\nexport declare type SelfType = typeof self;\n/**\n * Signals all rows are to be returned (without filtering via a `WHERE` clause)\n */\nexport declare const all: unique symbol;\nexport declare type AllType = typeof all;\n/**\n * JSON types\n */\nexport declare type JSONValue = null | boolean | number | string | JSONObject | JSONArray;\nexport declare type JSONObject = {\n    [k: string]: JSONValue;\n};\nexport declare type JSONArray = JSONValue[];\n/**\n * Date to be represented as an ISO8601 string, which is how Postgres casts them\n */\nexport declare type DateString = string;\n/**\n * Compiles to a numbered query parameter (`$1`, `$2`, etc) and adds the wrapped value\n * at the appropriate position of the values array passed to `pg`.\n * @param x The value to be wrapped\n * @param cast Optional cast type. If a string, the parameter will be cast to\n * this type within the query e.g. `CAST($1 AS type)` instead of plain `$1`. If\n * `true`, the value will be JSON stringified and cast to `json` (irrespective\n * of the configuration parameters `castArrayParamsToJson` and\n * `castObjectParamsToJson`). If `false`, the value will **not** be JSON-\n * stringified or cast to `json` (again irrespective of the configuration\n * parameters `castArrayParamsToJson` and `castObjectParamsToJson`).\n */\nexport declare class Parameter<T = any> {\n    value: T;\n    cast?: string | boolean | undefined;\n    constructor(value: T, cast?: string | boolean | undefined);\n}\n/**\n * Returns a `Parameter` instance, which compiles to a numbered query parameter\n * (`$1`, `$2`, etc) and adds its wrapped value at the appropriate position of\n * the values array passed to `pg`.\n * @param x The value to be wrapped\n * @param cast Optional cast type. If a string, the parameter will be cast to\n * this type within the query e.g. `CAST($1 AS type)` instead of plain `$1`. If\n * `true`, the value will be JSON stringified and cast to `json` (irrespective\n * of the configuration parameters `castArrayParamsToJson` and\n * `castObjectParamsToJson`). If `false`, the value will **not** be JSON\n * stringified or cast to `json` (again irrespective of the configuration\n * parameters `castArrayParamsToJson` and `castObjectParamsToJson`).\n */\nexport declare function param<T = any>(x: T, cast?: boolean | string): Parameter<T>;\n/**\n * Compiles to the wrapped string value, as is. Dangerous: https://xkcd.com/327/.\n */\nexport declare class DangerousRawString {\n    value: string;\n    constructor(value: string);\n}\n/**\n * Returns a `DangerousRawString` instance, wrapping a string.\n * `DangerousRawString` compiles to the wrapped string value, as is.\n * Dangerous: https://xkcd.com/327/.\n */\nexport declare function raw(x: string): DangerousRawString;\n/**\n * Wraps either an array or object, and compiles to a quoted, comma-separated\n * list of array values (for use in a `SELECT` query) or object keys (for use\n * in an `INSERT`, `UPDATE` or `UPSERT` query, alongside `ColumnValues`).\n */\nexport declare class ColumnNames<T> {\n    value: T;\n    constructor(value: T);\n}\n/**\n * Returns a `ColumnNames` instance, wrapping either an array or an object.\n * `ColumnNames` compiles to a quoted, comma-separated list of array values (for\n * use in a `SELECT` query) or object keys (for use in an `INSERT`, `UDPATE` or\n * `UPSERT` query alongside a `ColumnValues`).\n */\nexport declare function cols<T>(x: T): ColumnNames<T>;\n/**\n * Compiles to a quoted, comma-separated list of object keys for use in an\n * `INSERT`, `UPDATE` or `UPSERT` query, alongside `ColumnNames`.\n */\nexport declare class ColumnValues<T> {\n    value: T;\n    constructor(value: T);\n}\n/**\n * Returns a ColumnValues instance, wrapping an object. ColumnValues compiles to\n * a  quoted, comma-separated list of object keys for use in an INSERT, UPDATE\n * or UPSERT query alongside a `ColumnNames`.\n */\nexport declare function vals<T>(x: T): ColumnValues<T>;\n/**\n * Compiles to the name of the column it wraps in the table of the parent query.\n * @param value The column name\n */\nexport declare class ParentColumn<T extends Column = Column> {\n    value: T;\n    constructor(value: T);\n}\n/**\n * Returns a `ParentColumn` instance, wrapping a column name, which compiles to\n * that column name of the table of the parent query.\n */\nexport declare function parent<T extends Column = Column>(x: T): ParentColumn<T>;\nexport declare type GenericSQLExpression = SQLFragment<any, any> | Parameter | DefaultType | DangerousRawString | SelfType;\nexport declare type SQLExpression = Table | ColumnNames<Updatable | (keyof Updatable)[]> | ColumnValues<Updatable | any[]> | Whereable | Column | GenericSQLExpression;\nexport declare type SQL = SQLExpression | SQLExpression[];\nexport declare type Queryable = pg.ClientBase | pg.Pool;\n/**\n * Tagged template function returning a `SQLFragment`. The first generic type\n * argument defines what interpolated value types are allowed. The second\n * defines what type the `SQLFragment` produces, where relevant (i.e. when\n * calling `.run(...)` on it, or using it as the value of an `extras` object).\n */\nexport declare function sql<Interpolations = SQL, RunResult = pg.QueryResult['rows'], Constraint = never>(literals: TemplateStringsArray, ...expressions: NoInfer<Interpolations>[]): SQLFragment<RunResult, Constraint>;\nexport declare class SQLFragment<RunResult = pg.QueryResult['rows'], Constraint = never> {\n    private literals;\n    private expressions;\n    protected constraint?: Constraint;\n    /**\n     * When calling `run`, this function is applied to the object returned by `pg`\n     * to produce the result that is returned. By default, the `rows` array is\n     * returned — i.e. `(qr) => qr.rows` — but some shortcut functions alter this\n     * in order to match their declared `RunResult` type.\n     */\n    runResultTransform: (qr: pg.QueryResult) => any;\n    parentTable?: string;\n    noop: boolean;\n    noopResult: any;\n    constructor(literals: string[], expressions: SQL[]);\n    /**\n     * Compile and run this query using the provided database connection. What's\n     * returned is piped via `runResultTransform` before being returned.\n     * @param queryable A database client or pool\n     * @param force If true, force this query to hit the DB even if it's marked as a no-op\n     */\n    run: (queryable: Queryable, force?: boolean) => Promise<RunResult>;\n    /**\n     * Compile this query, returning a `{ text: string, values: any[] }` object\n     * that could be passed to the `pg` query function. Arguments are generally\n     * only passed when the function calls itself recursively.\n     */\n    compile: (result?: SQLQuery, parentTable?: string | undefined, currentColumn?: string | undefined) => SQLQuery;\n    compileExpression: (expression: SQL, result?: SQLQuery, parentTable?: string | undefined, currentColumn?: string | undefined) => void;\n}\n","node_modules/@types/zapatos/db/index.d.ts":"export * from './canary';\nexport * from './config';\nexport * from './core';\nexport * from './pgErrors';\nexport * from './shortcuts';\nexport * from './transaction';\nexport * as conditions from './conditions';\n","node_modules/@types/zapatos/db/pgErrors.d.ts":"interface Error {\n    code?: string;\n}\n/**\n * Check whether an error object matches any of a set of Postgres error types.\n * @param err The error to check\n * @param types The Postgres error types to check against\n */\nexport declare function isDatabaseError(err: Error, ...types: (keyof typeof pgErrors)[]): boolean;\ndeclare const pgErrors: {\n    SuccessfulCompletion: string;\n    Warning: string;\n    NoData: string;\n    SqlStatementNotYetComplete: string;\n    ConnectionException: string;\n    TriggeredActionException: string;\n    FeatureNotSupported: string;\n    InvalidTransactionInitiation: string;\n    LocatorException: string;\n    InvalidGrantor: string;\n    InvalidRoleSpecification: string;\n    DiagnosticsException: string;\n    CaseNotFound: string;\n    CardinalityViolation: string;\n    DataException: string;\n    IntegrityConstraintViolation: string;\n    InvalidCursorState: string;\n    InvalidTransactionState: string;\n    InvalidSqlStatementName: string;\n    TriggeredDataChangeViolation: string;\n    InvalidAuthorizationSpecification: string;\n    DependentPrivilegeDescriptorsStillExist: string;\n    InvalidTransactionTermination: string;\n    SqlRoutineException: string;\n    InvalidCursorName: string;\n    ExternalRoutineException: string;\n    ExternalRoutineInvocationException: string;\n    SavepointException: string;\n    InvalidCatalogName: string;\n    InvalidSchemaName: string;\n    TransactionRollback: string;\n    SyntaxErrorOrAccessRuleViolation: string;\n    WithCheckOptionViolation: string;\n    InsufficientResources: string;\n    DiskFull: string;\n    OutOfMemory: string;\n    TooManyConnections: string;\n    ConfigurationLimitExceeded: string;\n    ProgramLimitExceeded: string;\n    ObjectNotInPrerequisiteState: string;\n    OperatorIntervention: string;\n    SystemError: string;\n    SnapshotTooOld: string;\n    ConfigFileError: string;\n    FdwError: string;\n    PlpgsqlError: string;\n    InternalError: string;\n    SuccessfulCompletion_SuccessfulCompletion: string;\n    Warning_Warning: string;\n    Warning_NullValueEliminatedInSetFunction: string;\n    Warning_StringDataRightTruncation: string;\n    Warning_PrivilegeNotRevoked: string;\n    Warning_PrivilegeNotGranted: string;\n    Warning_ImplicitZeroBitPadding: string;\n    Warning_DynamicResultSetsReturned: string;\n    Warning_DeprecatedFeature: string;\n    NoData_NoData: string;\n    NoData_NoAdditionalDynamicResultSetsReturned: string;\n    SqlStatementNotYetComplete_SqlStatementNotYetComplete: string;\n    ConnectionException_ConnectionException: string;\n    ConnectionException_SqlclientUnableToEstablishSqlconnection: string;\n    ConnectionException_ConnectionDoesNotExist: string;\n    ConnectionException_SqlserverRejectedEstablishmentOfSqlconnection: string;\n    ConnectionException_ConnectionFailure: string;\n    ConnectionException_TransactionResolutionUnknown: string;\n    ConnectionException_ProtocolViolation: string;\n    TriggeredActionException_TriggeredActionException: string;\n    FeatureNotSupported_FeatureNotSupported: string;\n    InvalidTransactionInitiation_InvalidTransactionInitiation: string;\n    LocatorException_LocatorException: string;\n    LocatorException_InvalidLocatorSpecification: string;\n    InvalidGrantor_InvalidGrantor: string;\n    InvalidGrantor_InvalidGrantOperation: string;\n    InvalidRoleSpecification_InvalidRoleSpecification: string;\n    DiagnosticsException_DiagnosticsException: string;\n    DiagnosticsException_StackedDiagnosticsAccessedWithoutActiveHandler: string;\n    CaseNotFound_CaseNotFound: string;\n    CardinalityViolation_CardinalityViolation: string;\n    DataException_DataException: string;\n    DataException_StringDataRightTruncation: string;\n    DataException_NullValueNoIndicatorParameter: string;\n    DataException_NumericValueOutOfRange: string;\n    DataException_NullValueNotAllowed: string;\n    DataException_ErrorInAssignment: string;\n    DataException_InvalidDatetimeFormat: string;\n    DataException_DatetimeFieldOverflow: string;\n    DataException_InvalidTimeZoneDisplacementValue: string;\n    DataException_EscapeCharacterConflict: string;\n    DataException_InvalidUseOfEscapeCharacter: string;\n    DataException_InvalidEscapeOctet: string;\n    DataException_ZeroLengthCharacterString: string;\n    DataException_MostSpecificTypeMismatch: string;\n    DataException_SequenceGeneratorLimitExceeded: string;\n    DataException_NotAnXmlDocument: string;\n    DataException_InvalidXmlDocument: string;\n    DataException_InvalidXmlContent: string;\n    DataException_InvalidXmlComment: string;\n    DataException_InvalidXmlProcessingInstruction: string;\n    DataException_InvalidIndicatorParameterValue: string;\n    DataException_SubstringError: string;\n    DataException_DivisionByZero: string;\n    DataException_InvalidPrecedingOrFollowingSize: string;\n    DataException_InvalidArgumentForNtileFunction: string;\n    DataException_IntervalFieldOverflow: string;\n    DataException_InvalidArgumentForNthValueFunction: string;\n    DataException_InvalidCharacterValueForCast: string;\n    DataException_InvalidEscapeCharacter: string;\n    DataException_InvalidRegularExpression: string;\n    DataException_InvalidArgumentForLogarithm: string;\n    DataException_InvalidArgumentForPowerFunction: string;\n    DataException_InvalidArgumentForWidthBucketFunction: string;\n    DataException_InvalidRowCountInLimitClause: string;\n    DataException_InvalidRowCountInResultOffsetClause: string;\n    DataException_CharacterNotInRepertoire: string;\n    DataException_IndicatorOverflow: string;\n    DataException_InvalidParameterValue: string;\n    DataException_UnterminatedCString: string;\n    DataException_InvalidEscapeSequence: string;\n    DataException_StringDataLengthMismatch: string;\n    DataException_TrimError: string;\n    DataException_ArraySubscriptError: string;\n    DataException_InvalidTablesampleRepeat: string;\n    DataException_InvalidTablesampleArgument: string;\n    DataException_FloatingPointException: string;\n    DataException_InvalidTextRepresentation: string;\n    DataException_InvalidBinaryRepresentation: string;\n    DataException_BadCopyFileFormat: string;\n    DataException_UntranslatableCharacter: string;\n    DataException_NonstandardUseOfEscapeCharacter: string;\n    IntegrityConstraintViolation_IntegrityConstraintViolation: string;\n    IntegrityConstraintViolation_RestrictViolation: string;\n    IntegrityConstraintViolation_NotNullViolation: string;\n    IntegrityConstraintViolation_ForeignKeyViolation: string;\n    IntegrityConstraintViolation_UniqueViolation: string;\n    IntegrityConstraintViolation_CheckViolation: string;\n    IntegrityConstraintViolation_ExclusionViolation: string;\n    InvalidCursorState_InvalidCursorState: string;\n    InvalidTransactionState_InvalidTransactionState: string;\n    InvalidTransactionState_ActiveSqlTransaction: string;\n    InvalidTransactionState_BranchTransactionAlreadyActive: string;\n    InvalidTransactionState_InappropriateAccessModeForBranchTransaction: string;\n    InvalidTransactionState_InappropriateIsolationLevelForBranchTransaction: string;\n    InvalidTransactionState_NoActiveSqlTransactionForBranchTransaction: string;\n    InvalidTransactionState_ReadOnlySqlTransaction: string;\n    InvalidTransactionState_SchemaAndDataStatementMixingNotSupported: string;\n    InvalidTransactionState_HeldCursorRequiresSameIsolationLevel: string;\n    InvalidTransactionState_NoActiveSqlTransaction: string;\n    InvalidTransactionState_InFailedSqlTransaction: string;\n    InvalidTransactionState_IdleInTransactionSessionTimeout: string;\n    InvalidSqlStatementName_InvalidSqlStatementName: string;\n    TriggeredDataChangeViolation_TriggeredDataChangeViolation: string;\n    InvalidAuthorizationSpecification_InvalidAuthorizationSpecification: string;\n    InvalidAuthorizationSpecification_InvalidPassword: string;\n    DependentPrivilegeDescriptorsStillExist_DependentPrivilegeDescriptorsStillExist: string;\n    DependentPrivilegeDescriptorsStillExist_DependentObjectsStillExist: string;\n    InvalidTransactionTermination_InvalidTransactionTermination: string;\n    SqlRoutineException_SqlRoutineException: string;\n    SqlRoutineException_ModifyingSqlDataNotPermitted: string;\n    SqlRoutineException_ProhibitedSqlStatementAttempted: string;\n    SqlRoutineException_ReadingSqlDataNotPermitted: string;\n    SqlRoutineException_FunctionExecutedNoReturnStatement: string;\n    InvalidCursorName_InvalidCursorName: string;\n    ExternalRoutineException_ExternalRoutineException: string;\n    ExternalRoutineException_ContainingSqlNotPermitted: string;\n    ExternalRoutineException_ModifyingSqlDataNotPermitted: string;\n    ExternalRoutineException_ProhibitedSqlStatementAttempted: string;\n    ExternalRoutineException_ReadingSqlDataNotPermitted: string;\n    ExternalRoutineInvocationException_ExternalRoutineInvocationException: string;\n    ExternalRoutineInvocationException_InvalidSqlstateReturned: string;\n    ExternalRoutineInvocationException_NullValueNotAllowed: string;\n    ExternalRoutineInvocationException_TriggerProtocolViolated: string;\n    ExternalRoutineInvocationException_SrfProtocolViolated: string;\n    ExternalRoutineInvocationException_EventTriggerProtocolViolated: string;\n    SavepointException_SavepointException: string;\n    SavepointException_InvalidSavepointSpecification: string;\n    InvalidCatalogName_InvalidCatalogName: string;\n    InvalidSchemaName_InvalidSchemaName: string;\n    TransactionRollback_TransactionRollback: string;\n    TransactionRollback_SerializationFailure: string;\n    TransactionRollback_TransactionIntegrityConstraintViolation: string;\n    TransactionRollback_StatementCompletionUnknown: string;\n    TransactionRollback_DeadlockDetected: string;\n    SyntaxErrorOrAccessRuleViolation_SyntaxErrorOrAccessRuleViolation: string;\n    SyntaxErrorOrAccessRuleViolation_InsufficientPrivilege: string;\n    SyntaxErrorOrAccessRuleViolation_SyntaxError: string;\n    SyntaxErrorOrAccessRuleViolation_InvalidName: string;\n    SyntaxErrorOrAccessRuleViolation_InvalidColumnDefinition: string;\n    SyntaxErrorOrAccessRuleViolation_NameTooLong: string;\n    SyntaxErrorOrAccessRuleViolation_DuplicateColumn: string;\n    SyntaxErrorOrAccessRuleViolation_AmbiguousColumn: string;\n    SyntaxErrorOrAccessRuleViolation_UndefinedColumn: string;\n    SyntaxErrorOrAccessRuleViolation_UndefinedObject: string;\n    SyntaxErrorOrAccessRuleViolation_DuplicateObject: string;\n    SyntaxErrorOrAccessRuleViolation_DuplicateAlias: string;\n    SyntaxErrorOrAccessRuleViolation_DuplicateFunction: string;\n    SyntaxErrorOrAccessRuleViolation_AmbiguousFunction: string;\n    SyntaxErrorOrAccessRuleViolation_GroupingError: string;\n    SyntaxErrorOrAccessRuleViolation_DatatypeMismatch: string;\n    SyntaxErrorOrAccessRuleViolation_WrongObjectType: string;\n    SyntaxErrorOrAccessRuleViolation_InvalidForeignKey: string;\n    SyntaxErrorOrAccessRuleViolation_CannotCoerce: string;\n    SyntaxErrorOrAccessRuleViolation_UndefinedFunction: string;\n    SyntaxErrorOrAccessRuleViolation_GeneratedAlways: string;\n    SyntaxErrorOrAccessRuleViolation_ReservedName: string;\n    SyntaxErrorOrAccessRuleViolation_UndefinedTable: string;\n    SyntaxErrorOrAccessRuleViolation_UndefinedParameter: string;\n    SyntaxErrorOrAccessRuleViolation_DuplicateCursor: string;\n    SyntaxErrorOrAccessRuleViolation_DuplicateDatabase: string;\n    SyntaxErrorOrAccessRuleViolation_DuplicatePreparedStatement: string;\n    SyntaxErrorOrAccessRuleViolation_DuplicateSchema: string;\n    SyntaxErrorOrAccessRuleViolation_DuplicateTable: string;\n    SyntaxErrorOrAccessRuleViolation_AmbiguousParameter: string;\n    SyntaxErrorOrAccessRuleViolation_AmbiguousAlias: string;\n    SyntaxErrorOrAccessRuleViolation_InvalidColumnReference: string;\n    SyntaxErrorOrAccessRuleViolation_InvalidCursorDefinition: string;\n    SyntaxErrorOrAccessRuleViolation_InvalidDatabaseDefinition: string;\n    SyntaxErrorOrAccessRuleViolation_InvalidFunctionDefinition: string;\n    SyntaxErrorOrAccessRuleViolation_InvalidPreparedStatementDefinition: string;\n    SyntaxErrorOrAccessRuleViolation_InvalidSchemaDefinition: string;\n    SyntaxErrorOrAccessRuleViolation_InvalidTableDefinition: string;\n    SyntaxErrorOrAccessRuleViolation_InvalidObjectDefinition: string;\n    SyntaxErrorOrAccessRuleViolation_IndeterminateDatatype: string;\n    SyntaxErrorOrAccessRuleViolation_InvalidRecursion: string;\n    SyntaxErrorOrAccessRuleViolation_WindowingError: string;\n    SyntaxErrorOrAccessRuleViolation_CollationMismatch: string;\n    SyntaxErrorOrAccessRuleViolation_IndeterminateCollation: string;\n    WithCheckOptionViolation_WithCheckOptionViolation: string;\n    InsufficientResources_InsufficientResources: string;\n    InsufficientResources_DiskFull: string;\n    InsufficientResources_OutOfMemory: string;\n    InsufficientResources_TooManyConnections: string;\n    InsufficientResources_ConfigurationLimitExceeded: string;\n    ProgramLimitExceeded_ProgramLimitExceeded: string;\n    ProgramLimitExceeded_StatementTooComplex: string;\n    ProgramLimitExceeded_TooManyColumns: string;\n    ProgramLimitExceeded_TooManyArguments: string;\n    ObjectNotInPrerequisiteState_ObjectNotInPrerequisiteState: string;\n    ObjectNotInPrerequisiteState_ObjectInUse: string;\n    ObjectNotInPrerequisiteState_CantChangeRuntimeParam: string;\n    ObjectNotInPrerequisiteState_LockNotAvailable: string;\n    OperatorIntervention_OperatorIntervention: string;\n    OperatorIntervention_QueryCanceled: string;\n    OperatorIntervention_AdminShutdown: string;\n    OperatorIntervention_CrashShutdown: string;\n    OperatorIntervention_CannotConnectNow: string;\n    OperatorIntervention_DatabaseDropped: string;\n    SystemError_SystemError: string;\n    SystemError_IoError: string;\n    SystemError_UndefinedFile: string;\n    SystemError_DuplicateFile: string;\n    SnapshotTooOld_SnapshotTooOld: string;\n    ConfigFileError_ConfigFileError: string;\n    ConfigFileError_LockFileExists: string;\n    FdwError_FdwError: string;\n    FdwError_FdwOutOfMemory: string;\n    FdwError_FdwDynamicParameterValueNeeded: string;\n    FdwError_FdwInvalidDataType: string;\n    FdwError_FdwColumnNameNotFound: string;\n    FdwError_FdwInvalidDataTypeDescriptors: string;\n    FdwError_FdwInvalidColumnName: string;\n    FdwError_FdwInvalidColumnNumber: string;\n    FdwError_FdwInvalidUseOfNullPointer: string;\n    FdwError_FdwInvalidStringFormat: string;\n    FdwError_FdwInvalidHandle: string;\n    FdwError_FdwInvalidOptionIndex: string;\n    FdwError_FdwInvalidOptionName: string;\n    FdwError_FdwOptionNameNotFound: string;\n    FdwError_FdwReplyHandle: string;\n    FdwError_FdwUnableToCreateExecution: string;\n    FdwError_FdwUnableToCreateReply: string;\n    FdwError_FdwUnableToEstablishConnection: string;\n    FdwError_FdwNoSchemas: string;\n    FdwError_FdwSchemaNotFound: string;\n    FdwError_FdwTableNotFound: string;\n    FdwError_FdwFunctionSequenceError: string;\n    FdwError_FdwTooManyHandles: string;\n    FdwError_FdwInconsistentDescriptorInformation: string;\n    FdwError_FdwInvalidAttributeValue: string;\n    FdwError_FdwInvalidStringLengthOrBufferLength: string;\n    FdwError_FdwInvalidDescriptorFieldIdentifier: string;\n    PlpgsqlError_PlpgsqlError: string;\n    PlpgsqlError_RaiseException: string;\n    PlpgsqlError_NoDataFound: string;\n    PlpgsqlError_TooManyRows: string;\n    PlpgsqlError_AssertFailure: string;\n    InternalError_InternalError: string;\n    InternalError_DataCorrupted: string;\n    InternalError_IndexCorrupted: string;\n};\nexport {};\n","node_modules/@types/zapatos/db/shortcuts.d.ts":"import type { SelectableForTable, WhereableForTable, InsertableForTable, UpdatableForTable, ColumnForTable, UniqueIndexForTable, SQLForTable, Table } from 'zapatos/schema';\nimport { AllType, DateString, SQLFragment } from './core';\nimport { PromisedType } from './utils';\ndeclare type JSONSelectableForTable<T extends Table> = {\n    [K in keyof SelectableForTable<T>]: Date extends SelectableForTable<T>[K] ? Exclude<SelectableForTable<T>[K], Date> | DateString : Date[] extends SelectableForTable<T>[K] ? Exclude<SelectableForTable<T>[K], Date[]> | DateString[] : SelectableForTable<T>[K];\n};\nexport declare type JSONOnlyColsForTable<T extends Table, C extends any[]> = Pick<JSONSelectableForTable<T>, C[number]>;\nexport interface SQLFragmentsMap {\n    [k: string]: SQLFragment<any>;\n}\nexport declare type PromisedSQLFragmentReturnType<R extends SQLFragment<any>> = PromisedType<ReturnType<R['run']>>;\nexport declare type LateralResult<L extends SQLFragmentsMap> = {\n    [K in keyof L]: PromisedSQLFragmentReturnType<L[K]>;\n};\nexport declare type ExtrasResult<L extends SQLFragmentsMap> = {\n    [K in keyof L]: PromisedSQLFragmentReturnType<L[K]>;\n};\ndeclare type ExtrasOption = SQLFragmentsMap | undefined;\ndeclare type ColumnsOption<T extends Table> = ColumnForTable<T>[] | undefined;\ndeclare type LimitedLateralOption = SQLFragmentsMap | undefined;\ndeclare type FullLateralOption = LimitedLateralOption | SQLFragment<any>;\ndeclare type LateralOption<C extends ColumnsOption<Table>, E extends ExtrasOption> = undefined extends C ? undefined extends E ? FullLateralOption : LimitedLateralOption : LimitedLateralOption;\nexport interface ReturningOptionsForTable<T extends Table, C extends ColumnsOption<T>, E extends ExtrasOption> {\n    returning?: C;\n    extras?: E;\n}\ndeclare type ReturningTypeForTable<T extends Table, C extends ColumnsOption<T>, E extends ExtrasOption> = (undefined extends C ? JSONSelectableForTable<T> : C extends ColumnForTable<T>[] ? JSONOnlyColsForTable<T, C> : never) & (undefined extends E ? {} : E extends SQLFragmentsMap ? ExtrasResult<E> : never);\ninterface InsertSignatures {\n    <T extends Table, C extends ColumnForTable<T>[] | undefined, E extends SQLFragmentsMap | undefined>(table: T, values: InsertableForTable<T>, options?: ReturningOptionsForTable<T, C, E>): SQLFragment<ReturningTypeForTable<T, C, E>>;\n    <T extends Table, C extends ColumnForTable<T>[] | undefined, E extends SQLFragmentsMap | undefined>(table: T, values: InsertableForTable<T>[], options?: ReturningOptionsForTable<T, C, E>): SQLFragment<ReturningTypeForTable<T, C, E>[]>;\n}\n/**\n * Generate an `INSERT` query `SQLFragment`.\n * @param table The table into which to insert\n * @param values The `Insertable` values (or array thereof) to be inserted\n */\nexport declare const insert: InsertSignatures;\n/**\n * Wraps a unique index of the target table for use as the arbiter constraint\n * of an `upsert` shortcut query.\n */\nexport declare class Constraint<T extends Table> {\n    value: UniqueIndexForTable<T>;\n    constructor(value: UniqueIndexForTable<T>);\n}\n/**\n * Returns a `Constraint` instance, wrapping a unique index of the target table\n * for use as the arbiter constraint of an `upsert` shortcut query.\n */\nexport declare function constraint<T extends Table>(x: UniqueIndexForTable<T>): Constraint<T>;\nexport interface UpsertAction {\n    $action: 'INSERT' | 'UPDATE';\n}\ndeclare type UpsertReturnableForTable<T extends Table, C extends ColumnForTable<T>[] | undefined, E extends SQLFragmentsMap | undefined> = ReturningTypeForTable<T, C, E> & UpsertAction;\ndeclare type UpsertConflictTargetForTable<T extends Table> = Constraint<T> | ColumnForTable<T> | ColumnForTable<T>[];\ndeclare type UpdateColumns<T extends Table> = ColumnForTable<T> | ColumnForTable<T>[] | readonly [];\ninterface UpsertOptions<T extends Table, C extends ColumnForTable<T>[] | undefined, E extends SQLFragmentsMap | undefined, UC extends UpdateColumns<T>> extends ReturningOptionsForTable<T, C, E> {\n    updateValues?: UpdatableForTable<T>;\n    updateColumns?: UC;\n    noNullUpdateColumns?: ColumnForTable<T> | ColumnForTable<T>[];\n}\ninterface UpsertSignatures {\n    <T extends Table, C extends ColumnForTable<T>[] | undefined, E extends SQLFragmentsMap | undefined, UC extends UpdateColumns<T>>(table: T, values: InsertableForTable<T>, conflictTarget: UpsertConflictTargetForTable<T>, options?: UpsertOptions<T, C, E, UC>): SQLFragment<UpsertReturnableForTable<T, C, E> | (UC['length'] extends 0 ? undefined : never)>;\n    <T extends Table, C extends ColumnForTable<T>[] | undefined, E extends SQLFragmentsMap | undefined, UC extends UpdateColumns<T>>(table: T, values: InsertableForTable<T>[], conflictTarget: UpsertConflictTargetForTable<T>, options?: UpsertOptions<T, C, E, UC>): SQLFragment<UpsertReturnableForTable<T, C, E>[] | (UC['length'] extends 0 ? undefined : never)>;\n}\nexport declare const doNothing: readonly [];\n/**\n * Generate an 'upsert' (`INSERT ... ON CONFLICT ...`) query `SQLFragment`.\n * @param table The table to update or insert into\n * @param values An `Insertable` of values (or an array thereof) to be inserted\n * or updated\n * @param conflictTarget A `UNIQUE`-indexed column (or array thereof) or a\n * `UNIQUE` index (wrapped in `db.constraint(...)`) that determines whether we\n * get an `UPDATE` (when there's a matching existing value) or an `INSERT`\n * (when there isn't)\n * @param options Optionally, an object with any of the keys `updateColumns`,\n * `noNullUpdateColumns` and `updateValues` (see documentation).\n */\nexport declare const upsert: UpsertSignatures;\ninterface UpdateSignatures {\n    <T extends Table, C extends ColumnForTable<T>[] | undefined, E extends SQLFragmentsMap | undefined>(table: T, values: UpdatableForTable<T>, where: WhereableForTable<T> | SQLFragment, options?: ReturningOptionsForTable<T, C, E>): SQLFragment<ReturningTypeForTable<T, C, E>[]>;\n}\n/**\n * Generate an `UPDATE` query `SQLFragment`.\n * @param table The table to update\n * @param values An `Updatable` of the new values with which to update the table\n * @param where A `Whereable` (or `SQLFragment`) defining which rows to update\n */\nexport declare const update: UpdateSignatures;\nexport interface DeleteSignatures {\n    <T extends Table, C extends ColumnForTable<T>[] | undefined, E extends SQLFragmentsMap | undefined>(table: T, where: WhereableForTable<T> | SQLFragment, options?: ReturningOptionsForTable<T, C, E>): SQLFragment<ReturningTypeForTable<T, C, E>[]>;\n}\n/**\n * Generate an `DELETE` query `SQLFragment` (plain 'delete' is a reserved word)\n * @param table The table to delete from\n * @param where A `Whereable` (or `SQLFragment`) defining which rows to delete\n */\nexport declare const deletes: DeleteSignatures;\ndeclare type TruncateIdentityOpts = 'CONTINUE IDENTITY' | 'RESTART IDENTITY';\ndeclare type TruncateForeignKeyOpts = 'RESTRICT' | 'CASCADE';\ninterface TruncateSignatures {\n    (table: Table | Table[]): SQLFragment<undefined>;\n    (table: Table | Table[], optId: TruncateIdentityOpts): SQLFragment<undefined>;\n    (table: Table | Table[], optFK: TruncateForeignKeyOpts): SQLFragment<undefined>;\n    (table: Table | Table[], optId: TruncateIdentityOpts, optFK: TruncateForeignKeyOpts): SQLFragment<undefined>;\n}\n/**\n * Generate a `TRUNCATE` query `SQLFragment`.\n * @param table The table (or array thereof) to truncate\n * @param opts Options: 'CONTINUE IDENTITY'/'RESTART IDENTITY' and/or\n * 'RESTRICT'/'CASCADE'\n */\nexport declare const truncate: TruncateSignatures;\ninterface OrderSpecForTable<T extends Table> {\n    by: SQLForTable<T>;\n    direction: 'ASC' | 'DESC';\n    nulls?: 'FIRST' | 'LAST';\n}\nexport interface SelectLockingOptions {\n    for: 'UPDATE' | 'NO KEY UPDATE' | 'SHARE' | 'KEY SHARE';\n    of?: Table | Table[];\n    wait?: 'NOWAIT' | 'SKIP LOCKED';\n}\nexport interface SelectOptionsForTable<T extends Table, C extends ColumnsOption<T>, L extends LateralOption<C, E>, E extends ExtrasOption> {\n    distinct?: boolean | ColumnForTable<T> | ColumnForTable<T>[] | SQLFragment<any>;\n    order?: OrderSpecForTable<T> | OrderSpecForTable<T>[];\n    limit?: number;\n    offset?: number;\n    withTies?: boolean;\n    columns?: C;\n    extras?: E;\n    groupBy?: ColumnForTable<T> | ColumnForTable<T>[] | SQLFragment<any>;\n    having?: WhereableForTable<T> | SQLFragment<any>;\n    lateral?: L;\n    alias?: string;\n    lock?: SelectLockingOptions | SelectLockingOptions[];\n}\ndeclare type SelectReturnTypeForTable<T extends Table, C extends ColumnsOption<T>, L extends LateralOption<C, E>, E extends ExtrasOption> = (undefined extends L ? ReturningTypeForTable<T, C, E> : L extends SQLFragmentsMap ? ReturningTypeForTable<T, C, E> & LateralResult<L> : L extends SQLFragment<any> ? PromisedSQLFragmentReturnType<L> : never);\nexport declare enum SelectResultMode {\n    Many = 0,\n    One = 1,\n    ExactlyOne = 2,\n    Count = 3\n}\nexport declare type FullSelectReturnTypeForTable<T extends Table, C extends ColumnsOption<T>, L extends LateralOption<C, E>, E extends ExtrasOption, M extends SelectResultMode> = {\n    [SelectResultMode.Many]: SelectReturnTypeForTable<T, C, L, E>[];\n    [SelectResultMode.ExactlyOne]: SelectReturnTypeForTable<T, C, L, E>;\n    [SelectResultMode.One]: SelectReturnTypeForTable<T, C, L, E> | undefined;\n    [SelectResultMode.Count]: number;\n}[M];\nexport interface SelectSignatures {\n    <T extends Table, C extends ColumnsOption<T>, L extends LateralOption<C, E>, E extends ExtrasOption, M extends SelectResultMode = SelectResultMode.Many>(table: T, where: WhereableForTable<T> | SQLFragment | AllType, options?: SelectOptionsForTable<T, C, L, E>, mode?: M): SQLFragment<FullSelectReturnTypeForTable<T, C, L, E, M>>;\n}\nexport declare class NotExactlyOneError extends Error {\n    query: SQLFragment;\n    constructor(query: SQLFragment, ...params: any[]);\n}\n/**\n * Generate a `SELECT` query `SQLFragment`. This can be nested with other\n * `select`/`selectOne`/`count` queries using the `lateral` option.\n * @param table The table to select from\n * @param where A `Whereable` or `SQLFragment` defining the rows to be selected,\n * or `all`\n * @param options Options object. Keys (all optional) are:\n * * `columns` — an array of column names: only these columns will be returned\n * * `order` – an array of `OrderSpec` objects, such as\n * `{ by: 'column', direction: 'ASC' }`\n * * `limit` and `offset` – numbers: apply this limit and offset to the query\n * * `lateral` — either an object mapping keys to nested `select`/`selectOne`/\n * `count` queries to be `LATERAL JOIN`ed, or a single `select`/`selectOne`/\n * `count` query whose result will be passed through directly as the result of\n * the containing query\n * * `alias` — table alias (string): required if using `lateral` to join a table\n * to itself\n * * `extras` — an object mapping key(s) to `SQLFragment`s, so that derived\n * quantities can be included in the JSON result\n * @param mode (Used internally by `selectOne` and `count`)\n */\nexport declare const select: SelectSignatures;\nexport interface SelectOneSignatures {\n    <T extends Table, C extends ColumnsOption<T>, L extends LateralOption<C, E>, E extends ExtrasOption>(table: T, where: WhereableForTable<T> | SQLFragment | AllType, options?: SelectOptionsForTable<T, C, L, E>): SQLFragment<FullSelectReturnTypeForTable<T, C, L, E, SelectResultMode.One>>;\n}\n/**\n * Generate a `SELECT` query `SQLFragment` that returns only a single result (or\n * undefined). A `LIMIT 1` clause is added automatically. This can be nested with\n * other `select`/`selectOne`/`count` queries using the `lateral` option.\n * @param table The table to select from\n * @param where A `Whereable` or `SQLFragment` defining the rows to be selected,\n * or `all`\n * @param options Options object. See documentation for `select` for details.\n */\nexport declare const selectOne: SelectOneSignatures;\nexport interface SelectExactlyOneSignatures {\n    <T extends Table, C extends ColumnsOption<T>, L extends LateralOption<C, E>, E extends ExtrasOption>(table: T, where: WhereableForTable<T> | SQLFragment | AllType, options?: SelectOptionsForTable<T, C, L, E>): SQLFragment<FullSelectReturnTypeForTable<T, C, L, E, SelectResultMode.ExactlyOne>>;\n}\n/**\n * Generate a `SELECT` query `SQLFragment` that returns a single result or\n * throws an error. A `LIMIT 1` clause is added automatically. This can be\n * nested with other `select`/`selectOne`/`count` queries using the `lateral`\n * option.\n * @param table The table to select from\n * @param where A `Whereable` or `SQLFragment` defining the rows to be selected,\n * or `all`\n * @param options Options object. See documentation for `select` for details.\n */\nexport declare const selectExactlyOne: SelectExactlyOneSignatures;\nexport interface CountSignatures {\n    <T extends Table>(table: T, where: WhereableForTable<T> | SQLFragment | AllType, options?: {\n        columns?: ColumnsOption<T>;\n        alias?: string;\n    }): SQLFragment<number>;\n}\n/**\n * Generate a `SELECT` query `SQLFragment` that returns a count. This can be\n * nested in other `select`/`selectOne` queries using their `lateral` option.\n * @param table The table to count from\n * @param where A `Whereable` or `SQLFragment` defining the rows to be counted,\n * or `all`\n * @param options Options object. Keys are: `columns`, `alias`.\n */\nexport declare const count: CountSignatures;\nexport {};\n","node_modules/@types/zapatos/db/transaction.d.ts":"import * as pg from 'pg';\nexport declare enum IsolationLevel {\n    Serializable = \"SERIALIZABLE\",\n    RepeatableRead = \"REPEATABLE READ\",\n    ReadCommitted = \"READ COMMITTED\",\n    SerializableRO = \"SERIALIZABLE, READ ONLY\",\n    RepeatableReadRO = \"REPEATABLE READ, READ ONLY\",\n    ReadCommittedRO = \"READ COMMITTED, READ ONLY\",\n    SerializableRODeferrable = \"SERIALIZABLE, READ ONLY, DEFERRABLE\"\n}\nexport declare type IsolationSatisfying<T extends IsolationLevel> = {\n    [IsolationLevel.Serializable]: IsolationLevel.Serializable;\n    [IsolationLevel.RepeatableRead]: IsolationSatisfying<IsolationLevel.Serializable> | IsolationLevel.RepeatableRead;\n    [IsolationLevel.ReadCommitted]: IsolationSatisfying<IsolationLevel.RepeatableRead> | IsolationLevel.ReadCommitted;\n    [IsolationLevel.SerializableRO]: IsolationSatisfying<IsolationLevel.Serializable> | IsolationLevel.SerializableRO;\n    [IsolationLevel.RepeatableReadRO]: IsolationSatisfying<IsolationLevel.SerializableRO> | IsolationSatisfying<IsolationLevel.RepeatableRead> | IsolationLevel.RepeatableReadRO;\n    [IsolationLevel.ReadCommittedRO]: IsolationSatisfying<IsolationLevel.RepeatableReadRO> | IsolationSatisfying<IsolationLevel.ReadCommitted> | IsolationLevel.ReadCommittedRO;\n    [IsolationLevel.SerializableRODeferrable]: IsolationSatisfying<IsolationLevel.SerializableRO> | IsolationLevel.SerializableRODeferrable;\n}[T];\nexport interface TxnClient<T extends IsolationLevel> extends pg.PoolClient {\n    _zapatos?: {\n        isolationLevel: T;\n        txnId: number;\n    };\n}\nexport declare type TxnClientForSerializable = TxnClient<IsolationSatisfying<IsolationLevel.Serializable>>;\nexport declare type TxnClientForRepeatableRead = TxnClient<IsolationSatisfying<IsolationLevel.RepeatableRead>>;\nexport declare type TxnClientForReadCommitted = TxnClient<IsolationSatisfying<IsolationLevel.ReadCommitted>>;\nexport declare type TxnClientForSerializableRO = TxnClient<IsolationSatisfying<IsolationLevel.SerializableRO>>;\nexport declare type TxnClientForRepeatableReadRO = TxnClient<IsolationSatisfying<IsolationLevel.RepeatableReadRO>>;\nexport declare type TxnClientForReadCommittedRO = TxnClient<IsolationSatisfying<IsolationLevel.ReadCommittedRO>>;\nexport declare type TxnClientForSerializableRODeferrable = TxnClient<IsolationSatisfying<IsolationLevel.SerializableRODeferrable>>;\n/**\n * Provide a database client to the callback, whose queries are then wrapped in\n * a database transaction. The transaction is committed, retried, or rolled back\n * as appropriate.\n * @param txnClientOrPool The `pg.Pool` from which to check out the database\n * client or an appropriate transaction client to be passed through\n * @param isolationLevel The desired isolation level (e.g.\n * `IsolationLevel.Serializable`)\n * @param callback A callback function that runs queries on the client provided\n * to it\n */\nexport declare function transaction<T, M extends IsolationLevel>(txnClientOrPool: pg.Pool | TxnClient<IsolationSatisfying<M>>, isolationLevel: M, callback: (client: TxnClient<IsolationSatisfying<M>>) => Promise<T>): Promise<T>;\n/**\n * Shortcut for `transaction` with isolation level `Serializable`.\n * @param txnClientOrPool The `pg.Pool` from which to check out the database\n * client\n * @param callback A callback function that runs queries on the client provided\n * to it\n */\nexport declare function serializable<T>(txnClientOrPool: pg.Pool | TxnClientForSerializable, callback: (client: TxnClientForSerializable) => Promise<T>): Promise<T>;\n/**\n * Shortcut for `transaction` with isolation level `RepeatableRead`.\n * @param txnClientOrPool The `pg.Pool` from which to check out the database\n * client or an appropriate client to be passed through\n * @param callback A callback function that runs queries on the client provided\n * to it\n */\nexport declare function repeatableRead<T>(txnClientOrPool: pg.Pool | TxnClientForRepeatableRead, callback: (client: TxnClientForRepeatableRead) => Promise<T>): Promise<T>;\n/**\n * Shortcut for `transaction` with isolation level `ReadCommitted`.\n * @param txnClientOrPool The `pg.Pool` from which to check out the database\n * client or an appropriate client to be passed through\n * @param callback A callback function that runs queries on the client provided\n * to it\n */\nexport declare function readCommitted<T>(txnClientOrPool: pg.Pool | TxnClientForReadCommitted, callback: (client: TxnClientForReadCommitted) => Promise<T>): Promise<T>;\n/**\n * Shortcut for `transaction` with isolation level `SerializableRO`.\n * @param txnClientOrPool The `pg.Pool` from which to check out the database\n * client or an appropriate client to be passed through\n * @param callback A callback function that runs queries on the client provided\n * to it\n */\nexport declare function serializableRO<T>(txnClientOrPool: pg.Pool | TxnClientForSerializableRO, callback: (client: TxnClientForSerializableRO) => Promise<T>): Promise<T>;\n/**\n * Shortcut for `transaction` with isolation level `RepeatableReadRO`.\n * @param txnClientOrPool The `pg.Pool` from which to check out the database\n * client or an appropriate client to be passed through\n * @param callback A callback function that runs queries on the client provided\n * to it\n */\nexport declare function repeatableReadRO<T>(txnClientOrPool: pg.Pool | TxnClientForRepeatableReadRO, callback: (client: TxnClientForRepeatableReadRO) => Promise<T>): Promise<T>;\n/**\n * Shortcut for `transaction` with isolation level `ReadCommittedRO`.\n * @param txnClientOrPool The `pg.Pool` from which to check out the database\n * client or an appropriate client to be passed through\n * @param callback A callback function that runs queries on the client provided\n * to it\n */\nexport declare function readCommittedRO<T>(txnClientOrPool: pg.Pool | TxnClientForReadCommittedRO, callback: (client: TxnClientForReadCommittedRO) => Promise<T>): Promise<T>;\n/**\n * Shortcut for `transaction` with isolation level `SerializableRODeferrable`.\n * @param txnClientOrPool The `pg.Pool` from which to check out the database\n * client or an appropriate client to be passed through\n * @param callback A callback function that runs queries on the client provided\n * to it\n */\nexport declare function serializableRODeferrable<T>(txnClientOrPool: pg.Pool | TxnClientForSerializableRODeferrable, callback: (client: TxnClientForSerializableRODeferrable) => Promise<T>): Promise<T>;\n","node_modules/@types/zapatos/db/utils.d.ts":"export declare type NoInfer<T> = [T][T extends any ? 0 : never];\nexport declare type PromisedType<P> = P extends PromiseLike<infer U> ? U : never;\n/**\n * Simple promisification of setTimeout.\n * @param delayMs Time to wait, in milliseconds\n */\nexport declare const wait: (delayMs: number) => Promise<unknown>;\n/**\n * Map an input array to an output array, interspersing a constant separator value\n * between the mapped values.\n * @param arr Input array\n * @param separator Separator value\n * @param cb Mapping function\n */\nexport declare const mapWithSeparator: <TIn, TSep, TOut>(arr: TIn[], separator: TSep, cb: (x: TIn, i: number, a: TIn[]) => TOut) => (TSep | TOut)[];\n/**\n * Map an array of objects to an output array by taking the union of all objects' keys\n * and ensuring that any key not present on any object gets a default value.\n *\n * `e.g. [{ x: 1 }, { y: 2 }] => [{ x: 1, y: defaultValue }, { x: defaultValue, y: 2}]`\n * @param objs The array of objects\n * @param defaultValue The default value to assign to missing keys for each object\n */\nexport declare const completeKeysWithDefaultValue: <T extends object>(objs: T[], defaultValue: any) => T[];\n/**\n * Test that a value is a Plain Old JavaScript Object (such as one created by an object\n * literal, e.g. `{x: 1, y: 2}`)\n * @param x The value to test\n */\nexport declare const isPOJO: (x: any) => boolean;\n","node_modules/@types/zapatos/generate/cli.d.ts":"#!/usr/bin/env node\nexport {};\n","node_modules/@types/zapatos/generate/config.d.ts":"import type * as pg from 'pg';\nexport interface RequiredConfig {\n    db: pg.ClientConfig;\n}\nexport interface OptionalConfig {\n    outDir: string;\n    outExt: string;\n    schemas: SchemaRules;\n    progressListener: boolean | ((s: string) => void);\n    warningListener: boolean | ((s: string) => void);\n    customTypesTransform: 'PgMy_type' | 'my_type' | 'PgMyType' | ((s: string) => string);\n    columnOptions: ColumnOptions;\n}\ninterface SchemaRules {\n    [schema: string]: {\n        include: '*' | string[];\n        exclude: '*' | string[];\n    };\n}\ninterface ColumnOptions {\n    [k: string]: {\n        [k: string]: {\n            insert?: 'auto' | 'excluded' | 'optional';\n            update?: 'auto' | 'excluded';\n        };\n    };\n}\nexport declare type Config = RequiredConfig & Partial<OptionalConfig>;\nexport declare type CompleteConfig = RequiredConfig & OptionalConfig;\nexport declare const moduleRoot: () => string;\nexport declare const finaliseConfig: (config: Config) => CompleteConfig;\nexport {};\n","node_modules/@types/zapatos/generate/enums.d.ts":"import * as pg from 'pg';\nexport declare type EnumData = {\n    [k: string]: string[];\n};\nexport declare const enumDataForSchema: (schemaName: string, pool: pg.Pool) => Promise<EnumData>;\nexport declare const enumTypesForEnumData: (enums: EnumData) => string;\n","node_modules/@types/zapatos/generate/header.d.ts":"export declare const header: () => string;\n","node_modules/@types/zapatos/generate/index.d.ts":"export * from './config';\nexport * from './enums';\nexport * from './pgTypes';\nexport * from './tables';\nexport * from './tsOutput';\nexport * from './write';\n","node_modules/@types/zapatos/generate/legacy.d.ts":"import { CompleteConfig } from \"./config\";\nexport declare function srcWarning(config: CompleteConfig): void;\n","node_modules/@types/zapatos/generate/pgTypes.d.ts":"import type { EnumData } from './enums';\nexport declare const tsTypeForPgType: (pgType: string, enums: EnumData) => string;\n","node_modules/@types/zapatos/generate/tables.d.ts":"import * as pg from 'pg';\nimport type { EnumData } from './enums';\nimport type { CustomTypes } from './tsOutput';\nimport { CompleteConfig } from './config';\nexport interface Relation {\n    name: string;\n    type: 'table' | 'mview';\n}\nexport declare const relationsInSchema: (schemaName: string, pool: pg.Pool) => Promise<Relation[]>;\nexport declare const definitionForRelationInSchema: (rel: Relation, schemaName: string, enums: EnumData, customTypes: CustomTypes, config: CompleteConfig, pool: pg.Pool) => Promise<string>;\nexport declare const crossTableTypesForTables: (relations: Relation[]) => string;\n","node_modules/@types/zapatos/generate/tsOutput.d.ts":"import type { CompleteConfig } from './config';\nexport interface CustomTypes {\n    [name: string]: string;\n}\nexport declare const tsForConfig: (config: CompleteConfig) => Promise<{\n    ts: string;\n    customTypeSourceFiles: {\n        [k: string]: string;\n    };\n}>;\n","node_modules/@types/zapatos/generate/write.d.ts":"import { Config } from './config';\n/**\n * Generate a schema and supporting files and folders given a configuration.\n * @param suppliedConfig An object approximately matching `zapatosconfig.json`.\n */\nexport declare const generate: (suppliedConfig: Config) => Promise<void>;\n","node_modules/@types/zapatos/typings/zapatos/schema.d.ts":"export interface Updatable {\n    [k: string]: any;\n}\nexport interface Whereable {\n    [k: string]: any;\n}\nexport interface Insertable {\n    [k: string]: any;\n}\nexport declare type Table = string;\nexport declare type Column = string;\nexport declare type SelectableForTable<T extends Table> = {\n    [k: string]: any;\n};\nexport declare type WhereableForTable<T extends Table> = {\n    [k: string]: any;\n};\nexport declare type InsertableForTable<T extends Table> = {\n    [k: string]: any;\n};\nexport declare type UpdatableForTable<T extends Table> = {\n    [k: string]: any;\n};\nexport declare type ColumnForTable<T extends Table> = string;\nexport declare type UniqueIndexForTable<T extends Table> = string;\nexport declare type SQLForTable<T extends Table> = any;\n","node_modules/@types/pg/index.d.ts":"// Type definitions for pg 7.14\n// Project: http://github.com/brianc/node-postgres\n// Definitions by: Phips Peter <https://github.com/pspeter3>, Ravi van Rooijen <https://github.com/HoldYourWaffle>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n// TypeScript Version: 2.3\n\n/// <reference types=\"node\" />\n\nimport events = require('events');\nimport stream = require('stream');\nimport pgTypes = require('pg-types');\n\nimport { ConnectionOptions } from 'tls';\n\nexport interface ClientConfig {\n    user?: string;\n    database?: string;\n    password?: string | (() => string | Promise<string>);\n    port?: number;\n    host?: string;\n    connectionString?: string;\n    keepAlive?: boolean;\n    stream?: stream.Duplex;\n    statement_timeout?: false | number;\n    parseInputDatesAsUTC?: boolean;\n    ssl?: boolean | ConnectionOptions;\n    query_timeout?: number;\n    keepAliveInitialDelayMillis?: number;\n    idle_in_transaction_session_timeout?: number;\n    application_name?: string;\n    connectionTimeoutMillis?: number;\n}\n\nexport type ConnectionConfig = ClientConfig;\n\nexport interface Defaults extends ClientConfig {\n    poolSize?: number;\n    poolIdleTimeout?: number;\n    reapIntervalMillis?: number;\n    binary?: boolean;\n    parseInt8?: boolean;\n}\n\nexport interface PoolConfig extends ClientConfig {\n    // properties from module 'node-pool'\n    max?: number;\n    min?: number;\n    idleTimeoutMillis?: number;\n    log?: (...messages: any[]) => void;\n    Promise?: PromiseConstructorLike;\n}\n\nexport interface QueryConfig<I extends any[] = any[]> {\n    name?: string;\n    text: string;\n    values?: I;\n}\n\nexport interface Submittable {\n    submit: (connection: Connection) => void;\n}\n\nexport interface QueryArrayConfig<I extends any[] = any[]> extends QueryConfig<I> {\n    rowMode: 'array';\n}\n\nexport interface FieldDef {\n    name: string;\n    tableID: number;\n    columnID: number;\n    dataTypeID: number;\n    dataTypeSize: number;\n    dataTypeModifier: number;\n    format: string;\n}\n\nexport interface QueryResultBase {\n    command: string;\n    rowCount: number;\n    oid: number;\n    fields: FieldDef[];\n}\n\nexport interface QueryResultRow {\n    [column: string]: any;\n}\n\nexport interface QueryResult<R extends QueryResultRow = any> extends QueryResultBase {\n    rows: R[];\n}\n\nexport interface QueryArrayResult<R extends any[] = any[]> extends QueryResultBase {\n    rows: R[];\n}\n\nexport interface Notification {\n    processId: number;\n    channel: string;\n    payload?: string;\n}\n\nexport interface ResultBuilder<R extends QueryResultRow = any> extends QueryResult<R> {\n    addRow(row: R): void;\n}\n\nexport interface QueryParse {\n    name: string;\n    text: string;\n    types: string[];\n}\n\nexport interface BindConfig {\n    portal?: string;\n    statement?: string;\n    binary?: string;\n    values?: Array<Buffer | null | undefined | string>;\n}\n\nexport interface ExecuteConfig {\n    portal?: string;\n    rows?: string;\n}\n\nexport interface MessageConfig {\n    type: string;\n    name?: string;\n}\n\nexport class Connection extends events.EventEmitter {\n    readonly stream: stream.Duplex;\n\n    constructor(config?: ConnectionConfig);\n\n    bind(config: BindConfig | null, more: boolean): void;\n    execute(config: ExecuteConfig | null, more: boolean): void;\n    parse(query: QueryParse, more: boolean): void;\n\n    query(text: string): void;\n\n    describe(msg: MessageConfig, more: boolean): void;\n    close(msg: MessageConfig, more: boolean): void;\n\n    flush(): void;\n    sync(): void;\n    end(): void;\n}\n\n/**\n * {@link https://node-postgres.com/api/pool}\n */\nexport class Pool extends events.EventEmitter {\n    /**\n     * Every field of the config object is entirely optional.\n     * The config passed to the pool is also passed to every client\n     * instance within the pool when the pool creates that client.\n     */\n    constructor(config?: PoolConfig);\n\n    readonly totalCount: number;\n    readonly idleCount: number;\n    readonly waitingCount: number;\n\n    connect(): Promise<PoolClient>;\n    connect(callback: (err: Error, client: PoolClient, done: (release?: any) => void) => void): void;\n\n    end(): Promise<void>;\n    end(callback: () => void): void;\n\n    query<T extends Submittable>(queryStream: T): T;\n    // tslint:disable:no-unnecessary-generics\n    query<R extends any[] = any[], I extends any[] = any[]>(\n        queryConfig: QueryArrayConfig<I>,\n        values?: I,\n    ): Promise<QueryArrayResult<R>>;\n    query<R extends QueryResultRow = any, I extends any[] = any[]>(\n        queryConfig: QueryConfig<I>,\n    ): Promise<QueryResult<R>>;\n    query<R extends QueryResultRow = any, I extends any[] = any[]>(\n        queryTextOrConfig: string | QueryConfig<I>,\n        values?: I,\n    ): Promise<QueryResult<R>>;\n    query<R extends any[] = any[], I extends any[] = any[]>(\n        queryConfig: QueryArrayConfig<I>,\n        callback: (err: Error, result: QueryArrayResult<R>) => void,\n    ): void;\n    query<R extends QueryResultRow = any, I extends any[] = any[]>(\n        queryTextOrConfig: string | QueryConfig<I>,\n        callback: (err: Error, result: QueryResult<R>) => void,\n    ): void;\n    query<R extends QueryResultRow = any, I extends any[] = any[]>(\n        queryText: string,\n        values: I,\n        callback: (err: Error, result: QueryResult<R>) => void,\n    ): void;\n    // tslint:enable:no-unnecessary-generics\n\n    on(event: 'error', listener: (err: Error, client: PoolClient) => void): this;\n    on(event: 'connect' | 'acquire' | 'remove', listener: (client: PoolClient) => void): this;\n}\n\nexport class ClientBase extends events.EventEmitter {\n    constructor(config?: string | ClientConfig);\n\n    connect(): Promise<void>;\n    connect(callback: (err: Error) => void): void;\n\n    query<T extends Submittable>(queryStream: T): T;\n    // tslint:disable:no-unnecessary-generics\n    query<R extends any[] = any[], I extends any[] = any[]>(\n        queryConfig: QueryArrayConfig<I>,\n        values?: I,\n    ): Promise<QueryArrayResult<R>>;\n    query<R extends QueryResultRow = any, I extends any[] = any[]>(\n        queryConfig: QueryConfig<I>,\n    ): Promise<QueryResult<R>>;\n    query<R extends QueryResultRow = any, I extends any[] = any[]>(\n        queryTextOrConfig: string | QueryConfig<I>,\n        values?: I,\n    ): Promise<QueryResult<R>>;\n    query<R extends any[] = any[], I extends any[] = any[]>(\n        queryConfig: QueryArrayConfig<I>,\n        callback: (err: Error, result: QueryArrayResult<R>) => void,\n    ): void;\n    query<R extends QueryResultRow = any, I extends any[] = any[]>(\n        queryTextOrConfig: string | QueryConfig<I>,\n        callback: (err: Error, result: QueryResult<R>) => void,\n    ): void;\n    query<R extends QueryResultRow = any, I extends any[] = any[]>(\n        queryText: string,\n        values: any[],\n        callback: (err: Error, result: QueryResult<R>) => void,\n    ): void;\n    // tslint:enable:no-unnecessary-generics\n\n    copyFrom(queryText: string): stream.Writable;\n    copyTo(queryText: string): stream.Readable;\n\n    pauseDrain(): void;\n    resumeDrain(): void;\n\n    escapeIdentifier(str: string): string;\n    escapeLiteral(str: string): string;\n\n    on(event: 'drain', listener: () => void): this;\n    on(event: 'error' | 'notice', listener: (err: Error) => void): this;\n    on(event: 'notification', listener: (message: Notification) => void): this;\n    // tslint:disable-next-line unified-signatures\n    on(event: 'end', listener: () => void): this;\n}\n\nexport class Client extends ClientBase {\n    user?: string;\n    database?: string;\n    port: number;\n    host: string;\n    password?: string;\n    ssl: boolean;\n\n    constructor(config?: string | ClientConfig);\n\n    end(): Promise<void>;\n    end(callback: (err: Error) => void): void;\n}\n\nexport interface PoolClient extends ClientBase {\n    release(err?: Error | boolean): void;\n}\n\nexport class Query<R extends QueryResultRow = any, I extends any[] = any> extends events.EventEmitter\n    implements Submittable {\n    constructor(queryTextOrConfig?: string | QueryConfig<I>, values?: I);\n    submit: (connection: Connection) => void;\n    on(event: 'row', listener: (row: R, result?: ResultBuilder<R>) => void): this;\n    on(event: 'error', listener: (err: Error) => void): this;\n    on(event: 'end', listener: (result: ResultBuilder<R>) => void): this;\n}\n\nexport class Events extends events.EventEmitter {\n    on(event: 'error', listener: (err: Error, client: Client) => void): this;\n}\n\nexport const types: typeof pgTypes;\n\nexport const defaults: Defaults & ClientConfig;\n\nimport * as Pg from '.';\n\nexport const native: typeof Pg | null;\n","pgPool.ts":"\n      import * as pg from 'pg';\n      export default new pg.Pool();"};