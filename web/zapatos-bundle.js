const zapatosBundle = {"zapatos/.eslintrc.json":"{\n  \"ignorePatterns\": [\n    \"*\"\n  ]\n}","zapatos/LICENCE":"Zapatos: https://jawj.github.io/zapatos/\nCopyright (C) 2020 George MacKerron\nReleased under the MIT licence\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.","zapatos/custom/PgGeometry.js":"/*\n** Please do edit this file as needed **\nIt's a placeholder for a custom type definition\n*/\nexport {};\n","zapatos/custom/PgGeometry.ts":"/*\n** Please do edit this file as needed **\nIt's a placeholder for a custom type definition\n*/\n\nexport type PgGeometry = any;  // replace with your custom type or interface as desired\n","zapatos/custom/index.js":"/*\n** DON'T EDIT THIS FILE **\nIt's been generated by Zapatos (v0.1.57), and is liable to be overwritten\n\nZapatos: https://jawj.github.io/zapatos/\nCopyright (C) 2020 George MacKerron\nReleased under the MIT licence: see LICENCE file\n*/\nexport * from './PgGeometry';\n","zapatos/custom/index.ts":"/*\n** DON'T EDIT THIS FILE **\nIt's been generated by Zapatos (v0.1.58), and is liable to be overwritten\n\nZapatos: https://jawj.github.io/zapatos/\nCopyright (C) 2020 George MacKerron\nReleased under the MIT licence: see LICENCE file\n*/\n\nexport * from './PgGeometry';\n","zapatos/schema.js":"/*\n** DON'T EDIT THIS FILE **\nIt's been generated by Zapatos (v0.1.57), and is liable to be overwritten\n\nZapatos: https://jawj.github.io/zapatos/\nCopyright (C) 2020 George MacKerron\nReleased under the MIT licence: see LICENCE file\n*/\nexport {};\n","zapatos/schema.ts":"/*\n** DON'T EDIT THIS FILE **\nIt's been generated by Zapatos (v0.1.58), and is liable to be overwritten\n\nZapatos: https://jawj.github.io/zapatos/\nCopyright (C) 2020 George MacKerron\nReleased under the MIT licence: see LICENCE file\n*/\n\nimport * as db from './src/core';\nimport * as c from './custom';\n\ntype BasicWhereableFromInsertable<T> = { [K in keyof T]: Exclude<T[K] | db.ParentColumn, null | db.DefaultType> };\ntype WhereableFromBasicWhereable<T> = { [K in keyof T]?: T[K] | db.SQLFragment<any, T[K]> };\ntype WhereableFromInsertable<T> = WhereableFromBasicWhereable<BasicWhereableFromInsertable<T>>;\n\n/* === schema: public === */\n\n/* --- enums --- */\n\nexport type appleEnvironment = 'PROD' | 'Sandbox';\nexport declare namespace every {\n  export type appleEnvironment = ['PROD', 'Sandbox'];\n}\n\n/* --- tables --- */\n\nexport declare namespace appleTransactions {\n  export type Table = 'appleTransactions';\n  export interface Selectable {\n    environment: appleEnvironment;\n    originalTransactionId: string;\n    accountId: number;\n    latestReceiptData: string | null;\n  }\n  export interface Insertable {\n    environment: appleEnvironment | db.Parameter<appleEnvironment> | db.SQLFragment;\n    originalTransactionId: string | db.Parameter<string> | db.SQLFragment;\n    accountId: number | db.Parameter<number> | db.SQLFragment;\n    latestReceiptData?: string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment;\n  }\n  export interface Updatable extends Partial<Insertable> { }\n  export interface Whereable extends WhereableFromInsertable<Insertable> { }\n  export type JSONSelectable = { [K in keyof Selectable]:\n    Date extends Selectable[K] ? Exclude<Selectable[K], Date> | db.DateString :\n    Date[] extends Selectable[K] ? Exclude<Selectable[K], Date[]> | db.DateString[] :\n    Selectable[K]\n  };\n  export type UniqueIndex = 'appleTransactionsPrimaryKey';\n  export type Column = keyof Selectable;\n  export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n  export type SQLExpression = db.GenericSQLExpression | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Table | Whereable | Column;\n  export type SQL = SQLExpression | SQLExpression[];\n}\n\nexport declare namespace arrays {\n  export type Table = 'arrays';\n  export interface Selectable {\n    jsonValue: db.JSONValue | null;\n    textArray: string[] | null;\n  }\n  export interface Insertable {\n    jsonValue?: db.JSONValue | db.Parameter<db.JSONValue> | null | db.DefaultType | db.SQLFragment;\n    textArray?: string[] | db.Parameter<string[]> | null | db.DefaultType | db.SQLFragment;\n  }\n  export interface Updatable extends Partial<Insertable> { }\n  export interface Whereable extends WhereableFromInsertable<Insertable> { }\n  export type JSONSelectable = { [K in keyof Selectable]:\n    Date extends Selectable[K] ? Exclude<Selectable[K], Date> | db.DateString :\n    Date[] extends Selectable[K] ? Exclude<Selectable[K], Date[]> | db.DateString[] :\n    Selectable[K]\n  };\n  export type UniqueIndex = never;\n  export type Column = keyof Selectable;\n  export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n  export type SQLExpression = db.GenericSQLExpression | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Table | Whereable | Column;\n  export type SQL = SQLExpression | SQLExpression[];\n}\n\nexport declare namespace authors {\n  export type Table = 'authors';\n  export interface Selectable {\n    id: number;\n    name: string;\n    isLiving: boolean | null;\n  }\n  export interface Insertable {\n    id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;\n    name: string | db.Parameter<string> | db.SQLFragment;\n    isLiving?: boolean | db.Parameter<boolean> | null | db.DefaultType | db.SQLFragment;\n  }\n  export interface Updatable extends Partial<Insertable> { }\n  export interface Whereable extends WhereableFromInsertable<Insertable> { }\n  export type JSONSelectable = { [K in keyof Selectable]:\n    Date extends Selectable[K] ? Exclude<Selectable[K], Date> | db.DateString :\n    Date[] extends Selectable[K] ? Exclude<Selectable[K], Date[]> | db.DateString[] :\n    Selectable[K]\n  };\n  export type UniqueIndex = 'authors_pkey';\n  export type Column = keyof Selectable;\n  export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n  export type SQLExpression = db.GenericSQLExpression | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Table | Whereable | Column;\n  export type SQL = SQLExpression | SQLExpression[];\n}\n\nexport declare namespace bankAccounts {\n  export type Table = 'bankAccounts';\n  export interface Selectable {\n    id: number;\n    balance: number;\n  }\n  export interface Insertable {\n    id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;\n    balance?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;\n  }\n  export interface Updatable extends Partial<Insertable> { }\n  export interface Whereable extends WhereableFromInsertable<Insertable> { }\n  export type JSONSelectable = { [K in keyof Selectable]:\n    Date extends Selectable[K] ? Exclude<Selectable[K], Date> | db.DateString :\n    Date[] extends Selectable[K] ? Exclude<Selectable[K], Date[]> | db.DateString[] :\n    Selectable[K]\n  };\n  export type UniqueIndex = 'bankAccounts_pkey';\n  export type Column = keyof Selectable;\n  export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n  export type SQLExpression = db.GenericSQLExpression | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Table | Whereable | Column;\n  export type SQL = SQLExpression | SQLExpression[];\n}\n\nexport declare namespace books {\n  export type Table = 'books';\n  export interface Selectable {\n    id: number;\n    authorId: number;\n    title: string | null;\n    createdAt: Date;\n  }\n  export interface Insertable {\n    id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;\n    authorId: number | db.Parameter<number> | db.SQLFragment;\n    title?: string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment;\n    createdAt?: Date | db.Parameter<Date> | db.DateString | db.DefaultType | db.SQLFragment;\n  }\n  export interface Updatable extends Partial<Insertable> { }\n  export interface Whereable extends WhereableFromInsertable<Insertable> { }\n  export type JSONSelectable = { [K in keyof Selectable]:\n    Date extends Selectable[K] ? Exclude<Selectable[K], Date> | db.DateString :\n    Date[] extends Selectable[K] ? Exclude<Selectable[K], Date[]> | db.DateString[] :\n    Selectable[K]\n  };\n  export type UniqueIndex = 'books_pkey';\n  export type Column = keyof Selectable;\n  export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n  export type SQLExpression = db.GenericSQLExpression | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Table | Whereable | Column;\n  export type SQL = SQLExpression | SQLExpression[];\n}\n\nexport declare namespace doctors {\n  export type Table = 'doctors';\n  export interface Selectable {\n    id: number;\n    name: string;\n  }\n  export interface Insertable {\n    id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;\n    name: string | db.Parameter<string> | db.SQLFragment;\n  }\n  export interface Updatable extends Partial<Insertable> { }\n  export interface Whereable extends WhereableFromInsertable<Insertable> { }\n  export type JSONSelectable = { [K in keyof Selectable]:\n    Date extends Selectable[K] ? Exclude<Selectable[K], Date> | db.DateString :\n    Date[] extends Selectable[K] ? Exclude<Selectable[K], Date[]> | db.DateString[] :\n    Selectable[K]\n  };\n  export type UniqueIndex = 'doctors_pkey';\n  export type Column = keyof Selectable;\n  export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n  export type SQLExpression = db.GenericSQLExpression | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Table | Whereable | Column;\n  export type SQL = SQLExpression | SQLExpression[];\n}\n\nexport declare namespace emailAuthentication {\n  export type Table = 'emailAuthentication';\n  export interface Selectable {\n    email: string;\n    consecutiveFailedLogins: number;\n    lastFailedLogin: Date | null;\n  }\n  export interface Insertable {\n    email: string | db.Parameter<string> | db.SQLFragment;\n    consecutiveFailedLogins?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;\n    lastFailedLogin?: Date | db.Parameter<Date> | db.DateString | null | db.DefaultType | db.SQLFragment;\n  }\n  export interface Updatable extends Partial<Insertable> { }\n  export interface Whereable extends WhereableFromInsertable<Insertable> { }\n  export type JSONSelectable = { [K in keyof Selectable]:\n    Date extends Selectable[K] ? Exclude<Selectable[K], Date> | db.DateString :\n    Date[] extends Selectable[K] ? Exclude<Selectable[K], Date[]> | db.DateString[] :\n    Selectable[K]\n  };\n  export type UniqueIndex = 'emailAuthentication_pkey';\n  export type Column = keyof Selectable;\n  export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n  export type SQLExpression = db.GenericSQLExpression | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Table | Whereable | Column;\n  export type SQL = SQLExpression | SQLExpression[];\n}\n\nexport declare namespace employees {\n  export type Table = 'employees';\n  export interface Selectable {\n    id: number;\n    name: string;\n    managerId: number | null;\n  }\n  export interface Insertable {\n    id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;\n    name: string | db.Parameter<string> | db.SQLFragment;\n    managerId?: number | db.Parameter<number> | null | db.DefaultType | db.SQLFragment;\n  }\n  export interface Updatable extends Partial<Insertable> { }\n  export interface Whereable extends WhereableFromInsertable<Insertable> { }\n  export type JSONSelectable = { [K in keyof Selectable]:\n    Date extends Selectable[K] ? Exclude<Selectable[K], Date> | db.DateString :\n    Date[] extends Selectable[K] ? Exclude<Selectable[K], Date[]> | db.DateString[] :\n    Selectable[K]\n  };\n  export type UniqueIndex = 'employees_pkey';\n  export type Column = keyof Selectable;\n  export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n  export type SQLExpression = db.GenericSQLExpression | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Table | Whereable | Column;\n  export type SQL = SQLExpression | SQLExpression[];\n}\n\nexport declare namespace shifts {\n  export type Table = 'shifts';\n  export interface Selectable {\n    day: Date;\n    doctorId: number;\n  }\n  export interface Insertable {\n    day: Date | db.Parameter<Date> | db.DateString | db.SQLFragment;\n    doctorId: number | db.Parameter<number> | db.SQLFragment;\n  }\n  export interface Updatable extends Partial<Insertable> { }\n  export interface Whereable extends WhereableFromInsertable<Insertable> { }\n  export type JSONSelectable = { [K in keyof Selectable]:\n    Date extends Selectable[K] ? Exclude<Selectable[K], Date> | db.DateString :\n    Date[] extends Selectable[K] ? Exclude<Selectable[K], Date[]> | db.DateString[] :\n    Selectable[K]\n  };\n  export type UniqueIndex = 'shifts_pkey';\n  export type Column = keyof Selectable;\n  export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n  export type SQLExpression = db.GenericSQLExpression | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Table | Whereable | Column;\n  export type SQL = SQLExpression | SQLExpression[];\n}\n\nexport declare namespace stores {\n  export type Table = 'stores';\n  export interface Selectable {\n    id: number;\n    name: string;\n    geom: c.PgGeometry;\n  }\n  export interface Insertable {\n    id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;\n    name: string | db.Parameter<string> | db.SQLFragment;\n    geom: c.PgGeometry | db.Parameter<c.PgGeometry> | db.SQLFragment;\n  }\n  export interface Updatable extends Partial<Insertable> { }\n  export interface Whereable extends WhereableFromInsertable<Insertable> { }\n  export type JSONSelectable = { [K in keyof Selectable]:\n    Date extends Selectable[K] ? Exclude<Selectable[K], Date> | db.DateString :\n    Date[] extends Selectable[K] ? Exclude<Selectable[K], Date[]> | db.DateString[] :\n    Selectable[K]\n  };\n  export type UniqueIndex = 'stores_pkey';\n  export type Column = keyof Selectable;\n  export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n  export type SQLExpression = db.GenericSQLExpression | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Table | Whereable | Column;\n  export type SQL = SQLExpression | SQLExpression[];\n}\n\nexport declare namespace tags {\n  export type Table = 'tags';\n  export interface Selectable {\n    tag: string;\n    bookId: number;\n  }\n  export interface Insertable {\n    tag: string | db.Parameter<string> | db.SQLFragment;\n    bookId: number | db.Parameter<number> | db.SQLFragment;\n  }\n  export interface Updatable extends Partial<Insertable> { }\n  export interface Whereable extends WhereableFromInsertable<Insertable> { }\n  export type JSONSelectable = { [K in keyof Selectable]:\n    Date extends Selectable[K] ? Exclude<Selectable[K], Date> | db.DateString :\n    Date[] extends Selectable[K] ? Exclude<Selectable[K], Date[]> | db.DateString[] :\n    Selectable[K]\n  };\n  export type UniqueIndex = 'tagsUniqueIdx';\n  export type Column = keyof Selectable;\n  export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n  export type SQLExpression = db.GenericSQLExpression | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Table | Whereable | Column;\n  export type SQL = SQLExpression | SQLExpression[];\n}\n\n/* === cross-table types === */\n\nexport type Table = appleTransactions.Table | arrays.Table | authors.Table | bankAccounts.Table | books.Table | doctors.Table | emailAuthentication.Table | employees.Table | shifts.Table | stores.Table | tags.Table;\nexport type Selectable = appleTransactions.Selectable | arrays.Selectable | authors.Selectable | bankAccounts.Selectable | books.Selectable | doctors.Selectable | emailAuthentication.Selectable | employees.Selectable | shifts.Selectable | stores.Selectable | tags.Selectable;\nexport type Whereable = appleTransactions.Whereable | arrays.Whereable | authors.Whereable | bankAccounts.Whereable | books.Whereable | doctors.Whereable | emailAuthentication.Whereable | employees.Whereable | shifts.Whereable | stores.Whereable | tags.Whereable;\nexport type Insertable = appleTransactions.Insertable | arrays.Insertable | authors.Insertable | bankAccounts.Insertable | books.Insertable | doctors.Insertable | emailAuthentication.Insertable | employees.Insertable | shifts.Insertable | stores.Insertable | tags.Insertable;\nexport type Updatable = appleTransactions.Updatable | arrays.Updatable | authors.Updatable | bankAccounts.Updatable | books.Updatable | doctors.Updatable | emailAuthentication.Updatable | employees.Updatable | shifts.Updatable | stores.Updatable | tags.Updatable;\nexport type UniqueIndex = appleTransactions.UniqueIndex | arrays.UniqueIndex | authors.UniqueIndex | bankAccounts.UniqueIndex | books.UniqueIndex | doctors.UniqueIndex | emailAuthentication.UniqueIndex | employees.UniqueIndex | shifts.UniqueIndex | stores.UniqueIndex | tags.UniqueIndex;\nexport type Column = appleTransactions.Column | arrays.Column | authors.Column | bankAccounts.Column | books.Column | doctors.Column | emailAuthentication.Column | employees.Column | shifts.Column | stores.Column | tags.Column;\nexport type AllTables = [appleTransactions.Table, arrays.Table, authors.Table, bankAccounts.Table, books.Table, doctors.Table, emailAuthentication.Table, employees.Table, shifts.Table, stores.Table, tags.Table];\n\n\nexport type SelectableForTable<T extends Table> = {\n  appleTransactions: appleTransactions.Selectable;\n  arrays: arrays.Selectable;\n  authors: authors.Selectable;\n  bankAccounts: bankAccounts.Selectable;\n  books: books.Selectable;\n  doctors: doctors.Selectable;\n  emailAuthentication: emailAuthentication.Selectable;\n  employees: employees.Selectable;\n  shifts: shifts.Selectable;\n  stores: stores.Selectable;\n  tags: tags.Selectable;\n}[T];\n\nexport type WhereableForTable<T extends Table> = {\n  appleTransactions: appleTransactions.Whereable;\n  arrays: arrays.Whereable;\n  authors: authors.Whereable;\n  bankAccounts: bankAccounts.Whereable;\n  books: books.Whereable;\n  doctors: doctors.Whereable;\n  emailAuthentication: emailAuthentication.Whereable;\n  employees: employees.Whereable;\n  shifts: shifts.Whereable;\n  stores: stores.Whereable;\n  tags: tags.Whereable;\n}[T];\n\nexport type InsertableForTable<T extends Table> = {\n  appleTransactions: appleTransactions.Insertable;\n  arrays: arrays.Insertable;\n  authors: authors.Insertable;\n  bankAccounts: bankAccounts.Insertable;\n  books: books.Insertable;\n  doctors: doctors.Insertable;\n  emailAuthentication: emailAuthentication.Insertable;\n  employees: employees.Insertable;\n  shifts: shifts.Insertable;\n  stores: stores.Insertable;\n  tags: tags.Insertable;\n}[T];\n\nexport type UpdatableForTable<T extends Table> = {\n  appleTransactions: appleTransactions.Updatable;\n  arrays: arrays.Updatable;\n  authors: authors.Updatable;\n  bankAccounts: bankAccounts.Updatable;\n  books: books.Updatable;\n  doctors: doctors.Updatable;\n  emailAuthentication: emailAuthentication.Updatable;\n  employees: employees.Updatable;\n  shifts: shifts.Updatable;\n  stores: stores.Updatable;\n  tags: tags.Updatable;\n}[T];\n\nexport type UniqueIndexForTable<T extends Table> = {\n  appleTransactions: appleTransactions.UniqueIndex;\n  arrays: arrays.UniqueIndex;\n  authors: authors.UniqueIndex;\n  bankAccounts: bankAccounts.UniqueIndex;\n  books: books.UniqueIndex;\n  doctors: doctors.UniqueIndex;\n  emailAuthentication: emailAuthentication.UniqueIndex;\n  employees: employees.UniqueIndex;\n  shifts: shifts.UniqueIndex;\n  stores: stores.UniqueIndex;\n  tags: tags.UniqueIndex;\n}[T];\n\nexport type ColumnForTable<T extends Table> = {\n  appleTransactions: appleTransactions.Column;\n  arrays: arrays.Column;\n  authors: authors.Column;\n  bankAccounts: bankAccounts.Column;\n  books: books.Column;\n  doctors: doctors.Column;\n  emailAuthentication: emailAuthentication.Column;\n  employees: employees.Column;\n  shifts: shifts.Column;\n  stores: stores.Column;\n  tags: tags.Column;\n}[T];\n\nexport type SQLForTable<T extends Table> = {\n  appleTransactions: appleTransactions.SQL;\n  arrays: arrays.SQL;\n  authors: authors.SQL;\n  bankAccounts: bankAccounts.SQL;\n  books: books.SQL;\n  doctors: doctors.SQL;\n  emailAuthentication: emailAuthentication.SQL;\n  employees: employees.SQL;\n  shifts: shifts.SQL;\n  stores: stores.SQL;\n  tags: tags.SQL;\n}[T];\n\n","zapatos/src/conditions.js":"import { SQLFragment, ParentColumn, Parameter, param, sql, self, vals, } from './core';\nimport { mapWithSeparator } from './utils';\nconst conditionalParam = (a) => a instanceof SQLFragment || a instanceof ParentColumn || a instanceof Parameter ? a : param(a);\nexport const isNull = sql `${self} IS NULL`;\nexport const isNotNull = sql `${self} IS NOT NULL`;\nexport const isTrue = sql `${self} IS TRUE`;\nexport const isNotTrue = sql `${self} IS NOT TRUE`;\nexport const isFalse = sql `${self} IS FALSE`;\nexport const isNotFalse = sql `${self} IS NOT FALSE`;\nexport const isUnknown = sql `${self} IS UNKNOWN`;\nexport const isNotUnknown = sql `${self} IS NOT UNKNOWN`;\nexport const isDistinctFrom = (a) => sql `${self} IS DISTINCT FROM ${conditionalParam(a)}`;\nexport const isNotDistinctFrom = (a) => sql `${self} IS NOT DISTINCT FROM ${conditionalParam(a)}`;\nexport const ne = (a) => sql `${self} <> ${conditionalParam(a)}`;\nexport const gt = (a) => sql `${self} > ${conditionalParam(a)}`;\nexport const gte = (a) => sql `${self} >= ${conditionalParam(a)}`;\nexport const lt = (a) => sql `${self} < ${conditionalParam(a)}`;\nexport const lte = (a) => sql `${self} <= ${conditionalParam(a)}`;\nexport const between = (a, b) => sql `${self} BETWEEN (${conditionalParam(a)}) AND (${conditionalParam(b)})`;\nexport const betweenSymmetric = (a, b) => sql `${self} BETWEEN SYMMETRIC (${conditionalParam(a)}) AND (${conditionalParam(b)})`;\nexport const notBetween = (a, b) => sql `${self} NOT BETWEEN (${conditionalParam(a)}) AND (${conditionalParam(b)})`;\nexport const notBetweenSymmetric = (a, b) => sql `${self} NOT BETWEEN SYMMETRIC (${conditionalParam(a)}) AND (${conditionalParam(b)})`;\nexport const isIn = (a) => sql `${self} IN (${vals(a)})`;\nexport const isNotIn = (a) => sql `${self} NOT IN (${vals(a)})`;\nexport const like = (a) => sql `${self} LIKE ${conditionalParam(a)}`;\nexport const notLike = (a) => sql `${self} NOT LIKE ${conditionalParam(a)}`;\nexport const ilike = (a) => sql `${self} ILIKE ${conditionalParam(a)}`;\nexport const notIlike = (a) => sql `${self} NOT ILIKE ${conditionalParam(a)}`;\nexport const similarTo = (a) => sql `${self} SIMILAR TO ${conditionalParam(a)}`;\nexport const notSimilarTo = (a) => sql `${self} NOT SIMILAR TO ${conditionalParam(a)}`;\nexport const reMatch = (a) => sql `${self} ~ ${conditionalParam(a)}`;\nexport const reImatch = (a) => sql `${self} ~* ${conditionalParam(a)}`;\nexport const notReMatch = (a) => sql `${self} !~ ${conditionalParam(a)}`;\nexport const notReImatch = (a) => sql `${self} !~* ${conditionalParam(a)}`;\nexport const or = (...conditions) => sql `(${mapWithSeparator(conditions, sql ` OR `, c => c)})`;\nexport const and = (...conditions) => sql `(${mapWithSeparator(conditions, sql ` AND `, c => c)})`;\nexport const not = (condition) => sql `(NOT ${condition})`;\n","zapatos/src/conditions.ts":"\nimport {\n  SQLFragment,\n  ParentColumn,\n  Parameter,\n  param,\n  sql,\n  SQL,\n  self,\n  vals,\n} from './core';\n\nimport { mapWithSeparator } from './utils';\n\nconst conditionalParam = (a: any) => a instanceof SQLFragment || a instanceof ParentColumn || a instanceof Parameter ? a : param(a);\n\nexport const isNull = sql<SQL, boolean> `${self} IS NULL`;\nexport const isNotNull = sql<SQL, boolean> `${self} IS NOT NULL`;\nexport const isTrue = sql<SQL, boolean> `${self} IS TRUE`;\nexport const isNotTrue = sql<SQL, boolean> `${self} IS NOT TRUE`;\nexport const isFalse = sql<SQL, boolean> `${self} IS FALSE`;\nexport const isNotFalse = sql<SQL, boolean> `${self} IS NOT FALSE`;\nexport const isUnknown = sql<SQL, boolean> `${self} IS UNKNOWN`;\nexport const isNotUnknown = sql<SQL, boolean> `${self} IS NOT UNKNOWN`;\n\nexport const isDistinctFrom = <T>(a: T) => sql<SQL, boolean, T> `${self} IS DISTINCT FROM ${conditionalParam(a)}`;\nexport const isNotDistinctFrom = <T>(a: T) => sql<SQL, boolean, T> `${self} IS NOT DISTINCT FROM ${conditionalParam(a)}`;\n\nexport const ne = <T>(a: T) => sql<SQL, boolean | null, T> `${self} <> ${conditionalParam(a)}`;\nexport const gt = <T>(a: T) => sql<SQL, boolean | null, T> `${self} > ${conditionalParam(a)}`;\nexport const gte = <T>(a: T) => sql<SQL, boolean | null, T> `${self} >= ${conditionalParam(a)}`;\nexport const lt = <T>(a: T) => sql<SQL, boolean | null, T> `${self} < ${conditionalParam(a)}`;\nexport const lte = <T>(a: T) => sql<SQL, boolean | null, T> `${self} <= ${conditionalParam(a)}`;\n\nexport const between = <T>(a: T, b: T) => sql<SQL, boolean | null, T> `${self} BETWEEN (${conditionalParam(a)}) AND (${conditionalParam(b)})`;\nexport const betweenSymmetric = <T>(a: T, b: T) => sql<SQL, boolean | null, T> `${self} BETWEEN SYMMETRIC (${conditionalParam(a)}) AND (${conditionalParam(b)})`;\nexport const notBetween = <T>(a: T, b: T) => sql<SQL, boolean | null, T> `${self} NOT BETWEEN (${conditionalParam(a)}) AND (${conditionalParam(b)})`;\nexport const notBetweenSymmetric = <T>(a: T, b: T) => sql<SQL, boolean | null, T> `${self} NOT BETWEEN SYMMETRIC (${conditionalParam(a)}) AND (${conditionalParam(b)})`;\n\nexport const isIn = <T>(a: T[]) => sql<SQL, boolean | null, T> `${self} IN (${vals(a)})`;\nexport const isNotIn = <T>(a: T[]) => sql<SQL, boolean | null, T> `${self} NOT IN (${vals(a)})`;\n\nexport const like = <T extends string>(a: T) => sql<SQL, boolean | null, T> `${self} LIKE ${conditionalParam(a)}`;\nexport const notLike = <T extends string>(a: T) => sql<SQL, boolean | null, T> `${self} NOT LIKE ${conditionalParam(a)}`;\nexport const ilike = <T extends string>(a: T) => sql<SQL, boolean | null, T> `${self} ILIKE ${conditionalParam(a)}`;\nexport const notIlike = <T extends string>(a: T) => sql<SQL, boolean | null, T> `${self} NOT ILIKE ${conditionalParam(a)}`;\nexport const similarTo = <T extends string>(a: T) => sql<SQL, boolean | null, T> `${self} SIMILAR TO ${conditionalParam(a)}`;\nexport const notSimilarTo = <T extends string>(a: T) => sql<SQL, boolean | null, T> `${self} NOT SIMILAR TO ${conditionalParam(a)}`;\nexport const reMatch = <T extends string>(a: T) => sql<SQL, boolean | null, T> `${self} ~ ${conditionalParam(a)}`;\nexport const reImatch = <T extends string>(a: T) => sql<SQL, boolean | null, T> `${self} ~* ${conditionalParam(a)}`;\nexport const notReMatch = <T extends string>(a: T) => sql<SQL, boolean | null, T> `${self} !~ ${conditionalParam(a)}`;\nexport const notReImatch = <T extends string>(a: T) => sql<SQL, boolean | null, T> `${self} !~* ${conditionalParam(a)}`;\n\nexport const or = <T>(...conditions: SQLFragment<any, T>[]) => sql<SQL, boolean | null, T> `(${mapWithSeparator(conditions, sql` OR `, c => c)})`;\nexport const and = <T>(...conditions: SQLFragment<any, T>[]) => sql<SQL, boolean | null, T> `(${mapWithSeparator(conditions, sql` AND `, c => c)})`;\nexport const not = <T>(condition: SQLFragment<any, T>) => sql<SQL, boolean | null, T> `(NOT ${condition})`;\n","zapatos/src/config.js":"/*\n** DON'T EDIT THIS FILE (unless you're working on Zapatos) **\nIt's part of Zapatos, and will be overwritten when the database schema is regenerated\n\nZapatos: https://jawj.github.io/zapatos/\nCopyright (C) 2020 George MacKerron\nReleased under the MIT licence: see LICENCE file\n*/\nlet config = {\n    transactionAttemptsMax: 5,\n    transactionRetryDelay: { minMs: 25, maxMs: 250 },\n    castArrayParamsToJson: false,\n    castObjectParamsToJson: false,\n};\n/**\n * Get (a copy of) the current configuration.\n */\nexport const getConfig = () => (Object.assign({}, config));\n/**\n * Set key(s) on the configuration.\n * @param newConfig Partial configuration object\n */\nexport const setConfig = (newConfig) => config = Object.assign(Object.assign({}, config), newConfig);\n","zapatos/src/config.ts":"/*\n** DON'T EDIT THIS FILE (unless you're working on Zapatos) **\nIt's part of Zapatos, and will be overwritten when the database schema is regenerated\n\nZapatos: https://jawj.github.io/zapatos/\nCopyright (C) 2020 George MacKerron\nReleased under the MIT licence: see LICENCE file\n*/\n\nexport interface Config {\n  transactionAttemptsMax: number;\n  transactionRetryDelay: { minMs: number; maxMs: number };\n  castArrayParamsToJson: boolean;   // see https://github.com/brianc/node-postgres/issues/2012\n  castObjectParamsToJson: boolean;  // useful if json will be cast onward differently from text\n  queryListener?(str: any): void;\n  resultListener?(str: any): void;\n  transactionListener?(str: any): void;\n}\nexport type NewConfig = Partial<Config>;\n\nlet config: Config = {  // defaults\n  transactionAttemptsMax: 5,\n  transactionRetryDelay: { minMs: 25, maxMs: 250 },\n  castArrayParamsToJson: false,\n  castObjectParamsToJson: false,\n};\n\n/**\n * Get (a copy of) the current configuration.\n */\nexport const getConfig = () => ({ ...config });\n\n/**\n * Set key(s) on the configuration.\n * @param newConfig Partial configuration object\n */\nexport const setConfig = (newConfig: NewConfig) =>\n  config = { ...config, ...newConfig };\n","zapatos/src/core.js":"/*\n** DON'T EDIT THIS FILE (unless you're working on Zapatos) **\nIt's part of Zapatos, and will be overwritten when the database schema is regenerated\n\nZapatos: https://jawj.github.io/zapatos/\nCopyright (C) 2020 George MacKerron\nReleased under the MIT licence: see LICENCE file\n*/\nimport { getConfig } from './config';\nimport { isPOJO } from './utils';\n// === symbols, types, wrapper classes and shortcuts ===\n/**\n * Compiles to `DEFAULT` for use in `INSERT`/`UPDATE` queries.\n */\nexport const Default = Symbol('DEFAULT');\n/**\n * Compiles to the current column name within a `Whereable`.\n */\nexport const self = Symbol('self');\n/**\n * Signals all rows are to be returned (without filtering via a `WHERE` clause)\n */\nexport const all = Symbol('all');\n/**\n * Compiles to a numbered query parameter (`$1`, `$2`, etc) and adds the wrapped value\n * at the appropriate position of the values array passed to `pg`.\n * @param x The value to be wrapped\n * @param cast Optional cast type. If a string, the parameter will be cast to this type\n * within the query e.g. `CAST($1 AS type)` instead of plain `$1`. If `true`, the value\n * will be JSON stringified and cast to `json` (irrespective of the configuration parameters\n * `castArrayParamsToJson` and `castObjectParamsToJson`). If `false`, the value will **not**\n * be JSON stringified or cast to `json` (again irrespective of the configuration parameters\n * `castArrayParamsToJson` and `castObjectParamsToJson`).\n */\nexport class Parameter {\n    constructor(value, cast) {\n        this.value = value;\n        this.cast = cast;\n    }\n}\n/**\n * Returns a `Parameter` instance, which compiles to a numbered query parameter (`$1`,\n * `$2`, etc) and adds its wrapped value at the appropriate position of the values array\n * passed to `pg`.\n * @param x The value to be wrapped\n * @param cast Optional cast type. If a string, the parameter will be cast to this type\n * within the query e.g. `CAST($1 AS type)` instead of plain `$1`. If `true`, the value\n * will be JSON stringified and cast to `json` (irrespective of the configuration parameters\n * `castArrayParamsToJson` and `castObjectParamsToJson`). If `false`, the value will **not**\n * be JSON stringified or cast to `json` (again irrespective of the configuration parameters\n * `castArrayParamsToJson` and `castObjectParamsToJson`).\n */\nexport function param(x, cast) { return new Parameter(x, cast); }\n/**\n * Compiles to the wrapped string value, as is. Dangerous: https://xkcd.com/327/.\n */\nexport class DangerousRawString {\n    constructor(value) {\n        this.value = value;\n    }\n}\n/**\n * Returns a `DangerousRawString` instance, wrapping a string. `DangerousRawString`\n * compiles to the wrapped string value, as is. Dangerous: https://xkcd.com/327/.\n */\nexport function raw(x) { return new DangerousRawString(x); }\n/**\n * Wraps either an array or object, and compiles to a quoted, comma-separated list of\n * array values (for use in a `SELECT` query) or object keys (for use in an `INSERT`,\n * `UDPATE` or `UPSERT` query, alongside `ColumnValues`).\n */\nexport class ColumnNames {\n    constructor(value) {\n        this.value = value;\n    }\n}\n/**\n * Returns a `ColumnNames` instance, wrapping either an array or an object. `ColumnNames`\n * compiles to a quoted, comma-separated list of array values (for use in a `SELECT`\n * query) or object keys (for use in an `INSERT`, `UDPATE` or `UPSERT` query alongside\n * a `ColumnValues`).\n */\nexport function cols(x) { return new ColumnNames(x); }\n/**\n * Compiles to a quoted, comma-separated list of object keys for use in an `INSERT`,\n * `UPDATE` or `UPSERT` query, alongside `ColumnNames`.\n */\nexport class ColumnValues {\n    constructor(value) {\n        this.value = value;\n    }\n}\n/**\n * Returns a ColumnValues instance, wrapping an object. ColumnValues compiles to a\n * quoted, comma-separated list of object keys for use in an INSERT, UPDATE or UPSERT\n * query alongside a `ColumnNames`.\n */\nexport function vals(x) { return new ColumnValues(x); }\n/**\n * Compiles to the name of the column it wraps in the table of the parent query.\n * @param value The column name\n */\nexport class ParentColumn {\n    constructor(value) {\n        this.value = value;\n    }\n}\n/**\n * Returns a `ParentColumn` instance, wrapping a column name, which compiles to that\n * column name of the table of the parent query.\n */\nexport function parent(x) { return new ParentColumn(x); }\n/**\n * Tagged template function returning a `SQLFragment`. The first generic type argument\n * defines what interpolated value types are allowed. The second defines what type the\n * `SQLFragment` produces, where relevant (i.e. when calling `.run(...)` on it, or using\n * it as the value of an `extras` object).\n */\nexport function sql(literals, ...expressions) {\n    return new SQLFragment(Array.prototype.slice.apply(literals), expressions);\n}\nexport class SQLFragment {\n    constructor(literals, expressions) {\n        this.literals = literals;\n        this.expressions = expressions;\n        /**\n         * When calling `run`, this function is applied to the object returned by `pg` to\n         * produce the result that is returned. By default, the `rows` array is returned — i.e.\n         * `(qr) => qr.rows` — but some shortcut functions alter this in order to match their\n         * declared `RunResult` type.\n         */\n        this.runResultTransform = qr => qr.rows;\n        this.parentTable = undefined; // used for nested shortcut select queries\n        this.noop = false; // if true, bypass actually running the query unless forced to e.g. for empty INSERTs\n        /**\n         * Compile and run this query using the provided database connection. What's returned\n         * is piped via `runResultTransform` before being returned.\n         * @param queryable A database client or pool\n         * @param force If true, force this query to hit the DB even if it's marked as a no-op\n         */\n        this.run = async (queryable, force = false) => {\n            const query = this.compile(), config = getConfig();\n            if (config.queryListener)\n                config.queryListener(query);\n            let result;\n            if (!this.noop || force) {\n                const qr = await queryable.query(query);\n                result = this.runResultTransform(qr);\n            }\n            else {\n                result = this.noopResult;\n            }\n            if (config.resultListener)\n                config.resultListener(result);\n            return result;\n        };\n        /**\n         * Compile this query, returning a `{ text: string, values: any[] }` object that could\n         * be passed to the `pg` query function. Arguments are generally only passed when the\n         * function calls itself recursively.\n         */\n        this.compile = (result = { text: '', values: [] }, parentTable, currentColumn) => {\n            if (this.parentTable)\n                parentTable = this.parentTable;\n            if (this.noop)\n                result.text += \"/* marked no-op: won't hit DB unless forced -> */ \";\n            result.text += this.literals[0];\n            for (let i = 1, len = this.literals.length; i < len; i++) {\n                this.compileExpression(this.expressions[i - 1], result, parentTable, currentColumn);\n                result.text += this.literals[i];\n            }\n            return result;\n        };\n        this.compileExpression = (expression, result = { text: '', values: [] }, parentTable, currentColumn) => {\n            if (this.parentTable)\n                parentTable = this.parentTable;\n            if (expression instanceof SQLFragment) {\n                // another SQL fragment? recursively compile this one\n                expression.compile(result, parentTable, currentColumn);\n            }\n            else if (typeof expression === 'string') {\n                // if it's a string, it should be a x.Table or x.Column type, so just needs quoting\n                result.text += expression.charAt(0) === '\"' ? expression : `\"${expression}\"`;\n            }\n            else if (expression instanceof DangerousRawString) {\n                // Little Bobby Tables passes straight through ...\n                result.text += expression.value;\n            }\n            else if (Array.isArray(expression)) {\n                // an array's elements are compiled one by one -- note that an empty array can be used as a non-value\n                for (let i = 0, len = expression.length; i < len; i++)\n                    this.compileExpression(expression[i], result, parentTable, currentColumn);\n            }\n            else if (expression instanceof Parameter) {\n                // parameters become placeholders, and a corresponding entry in the values array\n                const placeholder = '$' + String(result.values.length + 1), // 1-based indexing\n                config = getConfig();\n                if (((expression.cast !== false && (expression.cast === true || config.castArrayParamsToJson)) &&\n                    Array.isArray(expression.value)) ||\n                    ((expression.cast !== false && (expression.cast === true || config.castObjectParamsToJson)) &&\n                        isPOJO(expression.value))) {\n                    result.values.push(JSON.stringify(expression.value));\n                    result.text += `CAST(${placeholder} AS \"json\")`;\n                }\n                else if (typeof expression.cast === 'string') {\n                    result.values.push(expression.value);\n                    result.text += `CAST(${placeholder} AS \"${expression.cast}\")`;\n                }\n                else {\n                    result.values.push(expression.value);\n                    result.text += placeholder;\n                }\n            }\n            else if (expression === Default) {\n                // a column default\n                result.text += 'DEFAULT';\n            }\n            else if (expression === self) {\n                // alias to the latest column, if applicable\n                if (!currentColumn)\n                    throw new Error(`The 'self' column alias has no meaning here`);\n                result.text += `\"${currentColumn}\"`;\n            }\n            else if (expression instanceof ParentColumn) {\n                // alias to the parent table (plus supplied column name) of a nested query, if applicable\n                if (!parentTable)\n                    throw new Error(`The 'parent' table alias has no meaning here`);\n                result.text += `\"${parentTable}\".\"${expression.value}\"`;\n            }\n            else if (expression instanceof ColumnNames) {\n                // a ColumnNames-wrapped object -> quoted names in a repeatable order\n                // OR a ColumnNames-wrapped array -> quoted array values\n                const columnNames = Array.isArray(expression.value) ? expression.value :\n                    Object.keys(expression.value).sort();\n                result.text += columnNames.map(k => `\"${k}\"`).join(', ');\n            }\n            else if (expression instanceof ColumnValues) {\n                // a ColumnValues-wrapped object OR array \n                // -> values (in ColumnNames-matching order, if applicable) punted as SQLFragments or Parameters\n                if (Array.isArray(expression.value)) {\n                    const values = expression.value;\n                    for (let i = 0, len = values.length; i < len; i++) {\n                        const value = values[i];\n                        if (i > 0)\n                            result.text += ', ';\n                        if (value instanceof SQLFragment)\n                            this.compileExpression(value, result, parentTable);\n                        else\n                            this.compileExpression(new Parameter(value), result, parentTable);\n                    }\n                }\n                else {\n                    const columnNames = Object.keys(expression.value).sort(), columnValues = columnNames.map(k => expression.value[k]);\n                    for (let i = 0, len = columnValues.length; i < len; i++) {\n                        const columnName = columnNames[i], columnValue = columnValues[i];\n                        if (i > 0)\n                            result.text += ', ';\n                        if (columnValue instanceof SQLFragment ||\n                            columnValue instanceof Parameter ||\n                            columnValue === Default)\n                            this.compileExpression(columnValue, result, parentTable, columnName);\n                        else\n                            this.compileExpression(new Parameter(columnValue), result, parentTable, columnName);\n                    }\n                }\n            }\n            else if (typeof expression === 'object') {\n                // must be a Whereable object, so put together a WHERE clause\n                const columnNames = Object.keys(expression).sort();\n                if (columnNames.length) { // if the object is not empty\n                    result.text += '(';\n                    for (let i = 0, len = columnNames.length; i < len; i++) {\n                        const columnName = columnNames[i], columnValue = expression[columnName];\n                        if (i > 0)\n                            result.text += ' AND ';\n                        if (columnValue instanceof SQLFragment) {\n                            result.text += '(';\n                            this.compileExpression(columnValue, result, parentTable, columnName);\n                            result.text += ')';\n                        }\n                        else {\n                            result.text += `\"${columnName}\" = `;\n                            this.compileExpression(columnValue instanceof ParentColumn ? columnValue : new Parameter(columnValue), result, parentTable, columnName);\n                        }\n                    }\n                    result.text += ')';\n                }\n                else {\n                    // or if it is empty, it should always match\n                    result.text += 'TRUE';\n                }\n            }\n            else {\n                throw new Error(`Alien object while interpolating SQL: ${expression}`);\n            }\n        };\n    }\n}\n","zapatos/src/core.ts":"/*\n** DON'T EDIT THIS FILE (unless you're working on Zapatos) **\nIt's part of Zapatos, and will be overwritten when the database schema is regenerated\n\nZapatos: https://jawj.github.io/zapatos/\nCopyright (C) 2020 George MacKerron\nReleased under the MIT licence: see LICENCE file\n*/\n\nimport type * as pg from 'pg';\nimport { getConfig } from './config';\nimport { isPOJO, NoInfer } from './utils';\n\nimport type {\n  Updatable,\n  Whereable,\n  Table,\n  Column,\n} from '../schema';\n\n\n// === symbols, types, wrapper classes and shortcuts ===\n\n/**\n * Compiles to `DEFAULT` for use in `INSERT`/`UPDATE` queries.\n */\nexport const Default = Symbol('DEFAULT');\nexport type DefaultType = typeof Default;\n\n/**\n * Compiles to the current column name within a `Whereable`.\n */\nexport const self = Symbol('self');\nexport type SelfType = typeof self;\n\n/**\n * Signals all rows are to be returned (without filtering via a `WHERE` clause)\n */\nexport const all = Symbol('all');\nexport type AllType = typeof all;\n\n/**\n * JSON types\n */\nexport type JSONValue = null | boolean | number | string | JSONObject | JSONArray;\nexport type JSONObject = { [k: string]: JSONValue };\nexport type JSONArray = JSONValue[];\n\n/**\n * Date to be represented as an ISO8601 string, which is how Postgres casts them\n */\nexport type DateString = string;\n\n/**\n * Compiles to a numbered query parameter (`$1`, `$2`, etc) and adds the wrapped value \n * at the appropriate position of the values array passed to `pg`.\n * @param x The value to be wrapped\n * @param cast Optional cast type. If a string, the parameter will be cast to this type\n * within the query e.g. `CAST($1 AS type)` instead of plain `$1`. If `true`, the value\n * will be JSON stringified and cast to `json` (irrespective of the configuration parameters\n * `castArrayParamsToJson` and `castObjectParamsToJson`). If `false`, the value will **not**\n * be JSON stringified or cast to `json` (again irrespective of the configuration parameters\n * `castArrayParamsToJson` and `castObjectParamsToJson`).\n */\nexport class Parameter<T = any> { constructor(public value: T, public cast?: boolean | string) { } }\n/**\n * Returns a `Parameter` instance, which compiles to a numbered query parameter (`$1`, \n * `$2`, etc) and adds its wrapped value at the appropriate position of the values array \n * passed to `pg`.\n * @param x The value to be wrapped\n * @param cast Optional cast type. If a string, the parameter will be cast to this type \n * within the query e.g. `CAST($1 AS type)` instead of plain `$1`. If `true`, the value \n * will be JSON stringified and cast to `json` (irrespective of the configuration parameters \n * `castArrayParamsToJson` and `castObjectParamsToJson`). If `false`, the value will **not** \n * be JSON stringified or cast to `json` (again irrespective of the configuration parameters \n * `castArrayParamsToJson` and `castObjectParamsToJson`).\n */\nexport function param<T = any>(x: T, cast?: boolean | string) { return new Parameter(x, cast); }\n\n/**\n * Compiles to the wrapped string value, as is. Dangerous: https://xkcd.com/327/.\n */\nexport class DangerousRawString { constructor(public value: string) { } }\n/**\n * Returns a `DangerousRawString` instance, wrapping a string. `DangerousRawString`\n * compiles to the wrapped string value, as is. Dangerous: https://xkcd.com/327/.\n */\nexport function raw(x: string) { return new DangerousRawString(x); }\n\n/**\n * Wraps either an array or object, and compiles to a quoted, comma-separated list of \n * array values (for use in a `SELECT` query) or object keys (for use in an `INSERT`, \n * `UDPATE` or `UPSERT` query, alongside `ColumnValues`).\n */\nexport class ColumnNames<T> { constructor(public value: T) { } }\n/**\n * Returns a `ColumnNames` instance, wrapping either an array or an object. `ColumnNames` \n * compiles to a quoted, comma-separated list of array values (for use in a `SELECT` \n * query) or object keys (for use in an `INSERT`, `UDPATE` or `UPSERT` query alongside \n * a `ColumnValues`).\n */\nexport function cols<T>(x: T) { return new ColumnNames<T>(x); }\n\n/**\n * Compiles to a quoted, comma-separated list of object keys for use in an `INSERT`, \n * `UPDATE` or `UPSERT` query, alongside `ColumnNames`.\n */\nexport class ColumnValues<T> { constructor(public value: T) { } }\n/**\n * Returns a ColumnValues instance, wrapping an object. ColumnValues compiles to a \n * quoted, comma-separated list of object keys for use in an INSERT, UPDATE or UPSERT \n * query alongside a `ColumnNames`.\n */\nexport function vals<T>(x: T) { return new ColumnValues<T>(x); }\n\n/**\n * Compiles to the name of the column it wraps in the table of the parent query.\n * @param value The column name\n */\nexport class ParentColumn<T extends Column = Column> { constructor(public value: T) { } }\n/**\n * Returns a `ParentColumn` instance, wrapping a column name, which compiles to that \n * column name of the table of the parent query.\n */\nexport function parent<T extends Column = Column>(x: T) { return new ParentColumn<T>(x); }\n\n\nexport type GenericSQLExpression = SQLFragment<any, any> | Parameter | DefaultType | DangerousRawString | SelfType;\nexport type SQLExpression = Table | ColumnNames<Updatable | (keyof Updatable)[]> | ColumnValues<Updatable | any[]> | Whereable | Column | GenericSQLExpression;\nexport type SQL = SQLExpression | SQLExpression[];\n\nexport type Queryable = pg.ClientBase | pg.Pool;\n\n\n// === SQL tagged template strings ===\n\ninterface SQLQuery {\n  text: string;\n  values: any[];\n}\n\n/**\n * Tagged template function returning a `SQLFragment`. The first generic type argument \n * defines what interpolated value types are allowed. The second defines what type the \n * `SQLFragment` produces, where relevant (i.e. when calling `.run(...)` on it, or using \n * it as the value of an `extras` object).\n */\nexport function sql<\n  Interpolations = SQL,\n  RunResult = pg.QueryResult['rows'],\n  Constraint = never,\n  >(literals: TemplateStringsArray, ...expressions: NoInfer<Interpolations>[]) {\n  return new SQLFragment<RunResult, Constraint>(Array.prototype.slice.apply(literals), expressions);\n}\n\nexport class SQLFragment<RunResult = pg.QueryResult['rows'], Constraint = never> {\n  protected constraint?: Constraint;\n\n  /**\n   * When calling `run`, this function is applied to the object returned by `pg` to \n   * produce the result that is returned. By default, the `rows` array is returned — i.e.\n   * `(qr) => qr.rows` — but some shortcut functions alter this in order to match their \n   * declared `RunResult` type.\n   */\n  runResultTransform: (qr: pg.QueryResult) => any = qr => qr.rows;\n\n  parentTable?: string = undefined;  // used for nested shortcut select queries\n\n  noop = false;  // if true, bypass actually running the query unless forced to e.g. for empty INSERTs\n  noopResult: any;  // if noop is true and DB is bypassed, what should be returned?\n\n  constructor(private literals: string[], private expressions: SQL[]) { }\n\n  /**\n   * Compile and run this query using the provided database connection. What's returned \n   * is piped via `runResultTransform` before being returned.\n   * @param queryable A database client or pool\n   * @param force If true, force this query to hit the DB even if it's marked as a no-op\n   */\n  run = async (queryable: Queryable, force = false): Promise<RunResult> => {\n    const\n      query = this.compile(),\n      config = getConfig();\n\n    if (config.queryListener) config.queryListener(query);\n\n    let result;\n    if (!this.noop || force) {\n      const qr = await queryable.query(query);\n      result = this.runResultTransform(qr);\n\n    } else {\n      result = this.noopResult;\n    }\n\n    if (config.resultListener) config.resultListener(result);\n    return result;\n  };\n\n  /**\n   * Compile this query, returning a `{ text: string, values: any[] }` object that could \n   * be passed to the `pg` query function. Arguments are generally only passed when the \n   * function calls itself recursively.\n   */\n  compile = (result: SQLQuery = { text: '', values: [] }, parentTable?: string, currentColumn?: Column) => {\n    if (this.parentTable) parentTable = this.parentTable;\n\n    if (this.noop) result.text += \"/* marked no-op: won't hit DB unless forced -> */ \";\n    result.text += this.literals[0];\n    for (let i = 1, len = this.literals.length; i < len; i++) {\n      this.compileExpression(this.expressions[i - 1], result, parentTable, currentColumn);\n      result.text += this.literals[i];\n    }\n    return result;\n  };\n\n  compileExpression = (expression: SQL, result: SQLQuery = { text: '', values: [] }, parentTable?: string, currentColumn?: Column) => {\n    if (this.parentTable) parentTable = this.parentTable;\n\n    if (expression instanceof SQLFragment) {\n      // another SQL fragment? recursively compile this one\n      expression.compile(result, parentTable, currentColumn);\n\n    } else if (typeof expression === 'string') {\n      // if it's a string, it should be a x.Table or x.Column type, so just needs quoting\n      result.text += expression.charAt(0) === '\"' ? expression : `\"${expression}\"`;\n\n    } else if (expression instanceof DangerousRawString) {\n      // Little Bobby Tables passes straight through ...\n      result.text += expression.value;\n\n    } else if (Array.isArray(expression)) {\n      // an array's elements are compiled one by one -- note that an empty array can be used as a non-value\n      for (let i = 0, len = expression.length; i < len; i++) this.compileExpression(expression[i], result, parentTable, currentColumn);\n\n    } else if (expression instanceof Parameter) {\n      // parameters become placeholders, and a corresponding entry in the values array\n      const\n        placeholder = '$' + String(result.values.length + 1),  // 1-based indexing\n        config = getConfig();\n\n      if (\n        ((expression.cast !== false && (expression.cast === true || config.castArrayParamsToJson)) &&\n          Array.isArray(expression.value)) ||\n        ((expression.cast !== false && (expression.cast === true || config.castObjectParamsToJson)) &&\n          isPOJO(expression.value))\n      ) {\n        result.values.push(JSON.stringify(expression.value));\n        result.text += `CAST(${placeholder} AS \"json\")`;\n\n      } else if (typeof expression.cast === 'string') {\n        result.values.push(expression.value);\n        result.text += `CAST(${placeholder} AS \"${expression.cast}\")`;\n\n      } else {\n        result.values.push(expression.value);\n        result.text += placeholder;\n      }\n\n    } else if (expression === Default) {\n      // a column default\n      result.text += 'DEFAULT';\n\n    } else if (expression === self) {\n      // alias to the latest column, if applicable\n      if (!currentColumn) throw new Error(`The 'self' column alias has no meaning here`);\n      result.text += `\"${currentColumn}\"`;\n\n    } else if (expression instanceof ParentColumn) {\n      // alias to the parent table (plus supplied column name) of a nested query, if applicable\n      if (!parentTable) throw new Error(`The 'parent' table alias has no meaning here`);\n      result.text += `\"${parentTable}\".\"${expression.value}\"`;\n\n    } else if (expression instanceof ColumnNames) {\n      // a ColumnNames-wrapped object -> quoted names in a repeatable order\n      // OR a ColumnNames-wrapped array -> quoted array values\n      const columnNames = Array.isArray(expression.value) ? expression.value :\n        Object.keys(expression.value).sort();\n      result.text += columnNames.map(k => `\"${k}\"`).join(', ');\n\n    } else if (expression instanceof ColumnValues) {\n      // a ColumnValues-wrapped object OR array \n      // -> values (in ColumnNames-matching order, if applicable) punted as SQLFragments or Parameters\n\n      if (Array.isArray(expression.value)) {\n        const values: any[] = expression.value;\n        for (let i = 0, len = values.length; i < len; i++) {\n          const value = values[i];\n          if (i > 0) result.text += ', ';\n          if (value instanceof SQLFragment) this.compileExpression(value, result, parentTable);\n          else this.compileExpression(new Parameter(value), result, parentTable);\n        }\n\n      } else {\n        const\n          columnNames = <Column[]>Object.keys(expression.value).sort(),\n          columnValues = columnNames.map(k => (<any>expression.value)[k]);\n\n        for (let i = 0, len = columnValues.length; i < len; i++) {\n          const\n            columnName = columnNames[i],\n            columnValue = columnValues[i];\n          if (i > 0) result.text += ', ';\n          if (columnValue instanceof SQLFragment ||\n            columnValue instanceof Parameter ||\n            columnValue === Default) this.compileExpression(columnValue, result, parentTable, columnName);\n          else this.compileExpression(new Parameter(columnValue), result, parentTable, columnName);\n        }\n      }\n\n    } else if (typeof expression === 'object') {\n      // must be a Whereable object, so put together a WHERE clause\n      const columnNames = <Column[]>Object.keys(expression).sort();\n\n      if (columnNames.length) {  // if the object is not empty\n        result.text += '(';\n        for (let i = 0, len = columnNames.length; i < len; i++) {\n          const\n            columnName = columnNames[i],\n            columnValue = (<any>expression)[columnName];\n          if (i > 0) result.text += ' AND ';\n          if (columnValue instanceof SQLFragment) {\n            result.text += '(';\n            this.compileExpression(columnValue, result, parentTable, columnName);\n            result.text += ')';\n\n          } else {\n            result.text += `\"${columnName}\" = `;\n            this.compileExpression(columnValue instanceof ParentColumn ? columnValue : new Parameter(columnValue),\n              result, parentTable, columnName);\n          }\n        }\n        result.text += ')';\n\n      } else {\n        // or if it is empty, it should always match\n        result.text += 'TRUE';\n      }\n\n    } else {\n      throw new Error(`Alien object while interpolating SQL: ${expression}`);\n    }\n  };\n}\n","zapatos/src/index.js":"/*\n** DON'T EDIT THIS FILE (unless you're working on Zapatos) **\nIt's part of Zapatos, and will be overwritten when the database schema is regenerated\n\nZapatos: https://jawj.github.io/zapatos/\nCopyright (C) 2020 George MacKerron\nReleased under the MIT licence: see LICENCE file\n*/\nexport * from './core';\nexport * from './shortcuts';\nexport * from './transaction';\nexport * from './config';\nexport * from './pgErrors';\nexport * as conditions from './conditions';\n","zapatos/src/index.ts":"/*\n** DON'T EDIT THIS FILE (unless you're working on Zapatos) **\nIt's part of Zapatos, and will be overwritten when the database schema is regenerated\n\nZapatos: https://jawj.github.io/zapatos/\nCopyright (C) 2020 George MacKerron\nReleased under the MIT licence: see LICENCE file\n*/\n\nexport * from './core';\nexport * from './shortcuts';\nexport * from './transaction';\nexport * from './config';\nexport * from './pgErrors';\n\nexport * as conditions from './conditions';\n","zapatos/src/pgErrors.js":"/*\n** DON'T EDIT THIS FILE (unless you're working on Zapatos) **\nIt's part of Zapatos, and will be overwritten when the database schema is regenerated\n\nZapatos: https://jawj.github.io/zapatos/\nCopyright (C) 2020 George MacKerron\nReleased under the MIT licence: see LICENCE file\n*/\n/**\n * Check whether an error object matches any of a set of Postgres error types.\n * @param err The error to check\n * @param types The Postgres error types to check against\n */\nexport function isDatabaseError(err, ...types) {\n    const { code } = err;\n    if (!code || code.length !== 5)\n        return false;\n    return types.some(type => code.startsWith(pgErrors[type]));\n}\nconst pgErrors = {\n    SuccessfulCompletion: \"00\",\n    Warning: \"01\",\n    NoData: \"02\",\n    SqlStatementNotYetComplete: \"03\",\n    ConnectionException: \"08\",\n    TriggeredActionException: \"09\",\n    FeatureNotSupported: \"0A\",\n    InvalidTransactionInitiation: \"0B\",\n    LocatorException: \"0F\",\n    InvalidGrantor: \"0L\",\n    InvalidRoleSpecification: \"0P\",\n    DiagnosticsException: \"0Z\",\n    CaseNotFound: \"20\",\n    CardinalityViolation: \"21\",\n    DataException: \"22\",\n    IntegrityConstraintViolation: \"23\",\n    InvalidCursorState: \"24\",\n    InvalidTransactionState: \"25\",\n    InvalidSqlStatementName: \"26\",\n    TriggeredDataChangeViolation: \"27\",\n    InvalidAuthorizationSpecification: \"28\",\n    DependentPrivilegeDescriptorsStillExist: \"2B\",\n    InvalidTransactionTermination: \"2D\",\n    SqlRoutineException: \"2F\",\n    InvalidCursorName: \"34\",\n    ExternalRoutineException: \"38\",\n    ExternalRoutineInvocationException: \"39\",\n    SavepointException: \"3B\",\n    InvalidCatalogName: \"3D\",\n    InvalidSchemaName: \"3F\",\n    TransactionRollback: \"40\",\n    SyntaxErrorOrAccessRuleViolation: \"42\",\n    WithCheckOptionViolation: \"44\",\n    InsufficientResources: \"53\",\n    DiskFull: \"53\",\n    OutOfMemory: \"53\",\n    TooManyConnections: \"53\",\n    ConfigurationLimitExceeded: \"53\",\n    ProgramLimitExceeded: \"54\",\n    ObjectNotInPrerequisiteState: \"55\",\n    OperatorIntervention: \"57\",\n    SystemError: \"58\",\n    SnapshotTooOld: \"72\",\n    ConfigFileError: \"F0\",\n    FdwError: \"HV\",\n    PlpgsqlError: \"P0\",\n    InternalError: \"XX\",\n    // specific errors from here\n    SuccessfulCompletion_SuccessfulCompletion: \"00000\",\n    Warning_Warning: \"01000\",\n    Warning_NullValueEliminatedInSetFunction: \"01003\",\n    Warning_StringDataRightTruncation: \"01004\",\n    Warning_PrivilegeNotRevoked: \"01006\",\n    Warning_PrivilegeNotGranted: \"01007\",\n    Warning_ImplicitZeroBitPadding: \"01008\",\n    Warning_DynamicResultSetsReturned: \"0100C\",\n    Warning_DeprecatedFeature: \"01P01\",\n    NoData_NoData: \"02000\",\n    NoData_NoAdditionalDynamicResultSetsReturned: \"02001\",\n    SqlStatementNotYetComplete_SqlStatementNotYetComplete: \"03000\",\n    ConnectionException_ConnectionException: \"08000\",\n    ConnectionException_SqlclientUnableToEstablishSqlconnection: \"08001\",\n    ConnectionException_ConnectionDoesNotExist: \"08003\",\n    ConnectionException_SqlserverRejectedEstablishmentOfSqlconnection: \"08004\",\n    ConnectionException_ConnectionFailure: \"08006\",\n    ConnectionException_TransactionResolutionUnknown: \"08007\",\n    ConnectionException_ProtocolViolation: \"08P01\",\n    TriggeredActionException_TriggeredActionException: \"09000\",\n    FeatureNotSupported_FeatureNotSupported: \"0A000\",\n    InvalidTransactionInitiation_InvalidTransactionInitiation: \"0B000\",\n    LocatorException_LocatorException: \"0F000\",\n    LocatorException_InvalidLocatorSpecification: \"0F001\",\n    InvalidGrantor_InvalidGrantor: \"0L000\",\n    InvalidGrantor_InvalidGrantOperation: \"0LP01\",\n    InvalidRoleSpecification_InvalidRoleSpecification: \"0P000\",\n    DiagnosticsException_DiagnosticsException: \"0Z000\",\n    DiagnosticsException_StackedDiagnosticsAccessedWithoutActiveHandler: \"0Z002\",\n    CaseNotFound_CaseNotFound: \"20000\",\n    CardinalityViolation_CardinalityViolation: \"21000\",\n    DataException_DataException: \"22000\",\n    DataException_StringDataRightTruncation: \"22001\",\n    DataException_NullValueNoIndicatorParameter: \"22002\",\n    DataException_NumericValueOutOfRange: \"22003\",\n    DataException_NullValueNotAllowed: \"22004\",\n    DataException_ErrorInAssignment: \"22005\",\n    DataException_InvalidDatetimeFormat: \"22007\",\n    DataException_DatetimeFieldOverflow: \"22008\",\n    DataException_InvalidTimeZoneDisplacementValue: \"22009\",\n    DataException_EscapeCharacterConflict: \"2200B\",\n    DataException_InvalidUseOfEscapeCharacter: \"2200C\",\n    DataException_InvalidEscapeOctet: \"2200D\",\n    DataException_ZeroLengthCharacterString: \"2200F\",\n    DataException_MostSpecificTypeMismatch: \"2200G\",\n    DataException_SequenceGeneratorLimitExceeded: \"2200H\",\n    DataException_NotAnXmlDocument: \"2200L\",\n    DataException_InvalidXmlDocument: \"2200M\",\n    DataException_InvalidXmlContent: \"2200N\",\n    DataException_InvalidXmlComment: \"2200S\",\n    DataException_InvalidXmlProcessingInstruction: \"2200T\",\n    DataException_InvalidIndicatorParameterValue: \"22010\",\n    DataException_SubstringError: \"22011\",\n    DataException_DivisionByZero: \"22012\",\n    DataException_InvalidPrecedingOrFollowingSize: \"22013\",\n    DataException_InvalidArgumentForNtileFunction: \"22014\",\n    DataException_IntervalFieldOverflow: \"22015\",\n    DataException_InvalidArgumentForNthValueFunction: \"22016\",\n    DataException_InvalidCharacterValueForCast: \"22018\",\n    DataException_InvalidEscapeCharacter: \"22019\",\n    DataException_InvalidRegularExpression: \"2201B\",\n    DataException_InvalidArgumentForLogarithm: \"2201E\",\n    DataException_InvalidArgumentForPowerFunction: \"2201F\",\n    DataException_InvalidArgumentForWidthBucketFunction: \"2201G\",\n    DataException_InvalidRowCountInLimitClause: \"2201W\",\n    DataException_InvalidRowCountInResultOffsetClause: \"2201X\",\n    DataException_CharacterNotInRepertoire: \"22021\",\n    DataException_IndicatorOverflow: \"22022\",\n    DataException_InvalidParameterValue: \"22023\",\n    DataException_UnterminatedCString: \"22024\",\n    DataException_InvalidEscapeSequence: \"22025\",\n    DataException_StringDataLengthMismatch: \"22026\",\n    DataException_TrimError: \"22027\",\n    DataException_ArraySubscriptError: \"2202E\",\n    DataException_InvalidTablesampleRepeat: \"2202G\",\n    DataException_InvalidTablesampleArgument: \"2202H\",\n    DataException_FloatingPointException: \"22P01\",\n    DataException_InvalidTextRepresentation: \"22P02\",\n    DataException_InvalidBinaryRepresentation: \"22P03\",\n    DataException_BadCopyFileFormat: \"22P04\",\n    DataException_UntranslatableCharacter: \"22P05\",\n    DataException_NonstandardUseOfEscapeCharacter: \"22P06\",\n    IntegrityConstraintViolation_IntegrityConstraintViolation: \"23000\",\n    IntegrityConstraintViolation_RestrictViolation: \"23001\",\n    IntegrityConstraintViolation_NotNullViolation: \"23502\",\n    IntegrityConstraintViolation_ForeignKeyViolation: \"23503\",\n    IntegrityConstraintViolation_UniqueViolation: \"23505\",\n    IntegrityConstraintViolation_CheckViolation: \"23514\",\n    IntegrityConstraintViolation_ExclusionViolation: \"23P01\",\n    InvalidCursorState_InvalidCursorState: \"24000\",\n    InvalidTransactionState_InvalidTransactionState: \"25000\",\n    InvalidTransactionState_ActiveSqlTransaction: \"25001\",\n    InvalidTransactionState_BranchTransactionAlreadyActive: \"25002\",\n    InvalidTransactionState_InappropriateAccessModeForBranchTransaction: \"25003\",\n    InvalidTransactionState_InappropriateIsolationLevelForBranchTransaction: \"25004\",\n    InvalidTransactionState_NoActiveSqlTransactionForBranchTransaction: \"25005\",\n    InvalidTransactionState_ReadOnlySqlTransaction: \"25006\",\n    InvalidTransactionState_SchemaAndDataStatementMixingNotSupported: \"25007\",\n    InvalidTransactionState_HeldCursorRequiresSameIsolationLevel: \"25008\",\n    InvalidTransactionState_NoActiveSqlTransaction: \"25P01\",\n    InvalidTransactionState_InFailedSqlTransaction: \"25P02\",\n    InvalidTransactionState_IdleInTransactionSessionTimeout: \"25P03\",\n    InvalidSqlStatementName_InvalidSqlStatementName: \"26000\",\n    TriggeredDataChangeViolation_TriggeredDataChangeViolation: \"27000\",\n    InvalidAuthorizationSpecification_InvalidAuthorizationSpecification: \"28000\",\n    InvalidAuthorizationSpecification_InvalidPassword: \"28P01\",\n    DependentPrivilegeDescriptorsStillExist_DependentPrivilegeDescriptorsStillExist: \"2B000\",\n    DependentPrivilegeDescriptorsStillExist_DependentObjectsStillExist: \"2BP01\",\n    InvalidTransactionTermination_InvalidTransactionTermination: \"2D000\",\n    SqlRoutineException_SqlRoutineException: \"2F000\",\n    SqlRoutineException_ModifyingSqlDataNotPermitted: \"2F002\",\n    SqlRoutineException_ProhibitedSqlStatementAttempted: \"2F003\",\n    SqlRoutineException_ReadingSqlDataNotPermitted: \"2F004\",\n    SqlRoutineException_FunctionExecutedNoReturnStatement: \"2F005\",\n    InvalidCursorName_InvalidCursorName: \"34000\",\n    ExternalRoutineException_ExternalRoutineException: \"38000\",\n    ExternalRoutineException_ContainingSqlNotPermitted: \"38001\",\n    ExternalRoutineException_ModifyingSqlDataNotPermitted: \"38002\",\n    ExternalRoutineException_ProhibitedSqlStatementAttempted: \"38003\",\n    ExternalRoutineException_ReadingSqlDataNotPermitted: \"38004\",\n    ExternalRoutineInvocationException_ExternalRoutineInvocationException: \"39000\",\n    ExternalRoutineInvocationException_InvalidSqlstateReturned: \"39001\",\n    ExternalRoutineInvocationException_NullValueNotAllowed: \"39004\",\n    ExternalRoutineInvocationException_TriggerProtocolViolated: \"39P01\",\n    ExternalRoutineInvocationException_SrfProtocolViolated: \"39P02\",\n    ExternalRoutineInvocationException_EventTriggerProtocolViolated: \"39P03\",\n    SavepointException_SavepointException: \"3B000\",\n    SavepointException_InvalidSavepointSpecification: \"3B001\",\n    InvalidCatalogName_InvalidCatalogName: \"3D000\",\n    InvalidSchemaName_InvalidSchemaName: \"3F000\",\n    TransactionRollback_TransactionRollback: \"40000\",\n    TransactionRollback_SerializationFailure: \"40001\",\n    TransactionRollback_TransactionIntegrityConstraintViolation: \"40002\",\n    TransactionRollback_StatementCompletionUnknown: \"40003\",\n    TransactionRollback_DeadlockDetected: \"40P01\",\n    SyntaxErrorOrAccessRuleViolation_SyntaxErrorOrAccessRuleViolation: \"42000\",\n    SyntaxErrorOrAccessRuleViolation_InsufficientPrivilege: \"42501\",\n    SyntaxErrorOrAccessRuleViolation_SyntaxError: \"42601\",\n    SyntaxErrorOrAccessRuleViolation_InvalidName: \"42602\",\n    SyntaxErrorOrAccessRuleViolation_InvalidColumnDefinition: \"42611\",\n    SyntaxErrorOrAccessRuleViolation_NameTooLong: \"42622\",\n    SyntaxErrorOrAccessRuleViolation_DuplicateColumn: \"42701\",\n    SyntaxErrorOrAccessRuleViolation_AmbiguousColumn: \"42702\",\n    SyntaxErrorOrAccessRuleViolation_UndefinedColumn: \"42703\",\n    SyntaxErrorOrAccessRuleViolation_UndefinedObject: \"42704\",\n    SyntaxErrorOrAccessRuleViolation_DuplicateObject: \"42710\",\n    SyntaxErrorOrAccessRuleViolation_DuplicateAlias: \"42712\",\n    SyntaxErrorOrAccessRuleViolation_DuplicateFunction: \"42723\",\n    SyntaxErrorOrAccessRuleViolation_AmbiguousFunction: \"42725\",\n    SyntaxErrorOrAccessRuleViolation_GroupingError: \"42803\",\n    SyntaxErrorOrAccessRuleViolation_DatatypeMismatch: \"42804\",\n    SyntaxErrorOrAccessRuleViolation_WrongObjectType: \"42809\",\n    SyntaxErrorOrAccessRuleViolation_InvalidForeignKey: \"42830\",\n    SyntaxErrorOrAccessRuleViolation_CannotCoerce: \"42846\",\n    SyntaxErrorOrAccessRuleViolation_UndefinedFunction: \"42883\",\n    SyntaxErrorOrAccessRuleViolation_GeneratedAlways: \"428C9\",\n    SyntaxErrorOrAccessRuleViolation_ReservedName: \"42939\",\n    SyntaxErrorOrAccessRuleViolation_UndefinedTable: \"42P01\",\n    SyntaxErrorOrAccessRuleViolation_UndefinedParameter: \"42P02\",\n    SyntaxErrorOrAccessRuleViolation_DuplicateCursor: \"42P03\",\n    SyntaxErrorOrAccessRuleViolation_DuplicateDatabase: \"42P04\",\n    SyntaxErrorOrAccessRuleViolation_DuplicatePreparedStatement: \"42P05\",\n    SyntaxErrorOrAccessRuleViolation_DuplicateSchema: \"42P06\",\n    SyntaxErrorOrAccessRuleViolation_DuplicateTable: \"42P07\",\n    SyntaxErrorOrAccessRuleViolation_AmbiguousParameter: \"42P08\",\n    SyntaxErrorOrAccessRuleViolation_AmbiguousAlias: \"42P09\",\n    SyntaxErrorOrAccessRuleViolation_InvalidColumnReference: \"42P10\",\n    SyntaxErrorOrAccessRuleViolation_InvalidCursorDefinition: \"42P11\",\n    SyntaxErrorOrAccessRuleViolation_InvalidDatabaseDefinition: \"42P12\",\n    SyntaxErrorOrAccessRuleViolation_InvalidFunctionDefinition: \"42P13\",\n    SyntaxErrorOrAccessRuleViolation_InvalidPreparedStatementDefinition: \"42P14\",\n    SyntaxErrorOrAccessRuleViolation_InvalidSchemaDefinition: \"42P15\",\n    SyntaxErrorOrAccessRuleViolation_InvalidTableDefinition: \"42P16\",\n    SyntaxErrorOrAccessRuleViolation_InvalidObjectDefinition: \"42P17\",\n    SyntaxErrorOrAccessRuleViolation_IndeterminateDatatype: \"42P18\",\n    SyntaxErrorOrAccessRuleViolation_InvalidRecursion: \"42P19\",\n    SyntaxErrorOrAccessRuleViolation_WindowingError: \"42P20\",\n    SyntaxErrorOrAccessRuleViolation_CollationMismatch: \"42P21\",\n    SyntaxErrorOrAccessRuleViolation_IndeterminateCollation: \"42P22\",\n    WithCheckOptionViolation_WithCheckOptionViolation: \"44000\",\n    InsufficientResources_InsufficientResources: \"53000\",\n    InsufficientResources_DiskFull: \"53100\",\n    InsufficientResources_OutOfMemory: \"53200\",\n    InsufficientResources_TooManyConnections: \"53300\",\n    InsufficientResources_ConfigurationLimitExceeded: \"53400\",\n    ProgramLimitExceeded_ProgramLimitExceeded: \"54000\",\n    ProgramLimitExceeded_StatementTooComplex: \"54001\",\n    ProgramLimitExceeded_TooManyColumns: \"54011\",\n    ProgramLimitExceeded_TooManyArguments: \"54023\",\n    ObjectNotInPrerequisiteState_ObjectNotInPrerequisiteState: \"55000\",\n    ObjectNotInPrerequisiteState_ObjectInUse: \"55006\",\n    ObjectNotInPrerequisiteState_CantChangeRuntimeParam: \"55P02\",\n    ObjectNotInPrerequisiteState_LockNotAvailable: \"55P03\",\n    OperatorIntervention_OperatorIntervention: \"57000\",\n    OperatorIntervention_QueryCanceled: \"57014\",\n    OperatorIntervention_AdminShutdown: \"57P01\",\n    OperatorIntervention_CrashShutdown: \"57P02\",\n    OperatorIntervention_CannotConnectNow: \"57P03\",\n    OperatorIntervention_DatabaseDropped: \"57P04\",\n    SystemError_SystemError: \"58000\",\n    SystemError_IoError: \"58030\",\n    SystemError_UndefinedFile: \"58P01\",\n    SystemError_DuplicateFile: \"58P02\",\n    SnapshotTooOld_SnapshotTooOld: \"72000\",\n    ConfigFileError_ConfigFileError: \"F0000\",\n    ConfigFileError_LockFileExists: \"F0001\",\n    FdwError_FdwError: \"HV000\",\n    FdwError_FdwOutOfMemory: \"HV001\",\n    FdwError_FdwDynamicParameterValueNeeded: \"HV002\",\n    FdwError_FdwInvalidDataType: \"HV004\",\n    FdwError_FdwColumnNameNotFound: \"HV005\",\n    FdwError_FdwInvalidDataTypeDescriptors: \"HV006\",\n    FdwError_FdwInvalidColumnName: \"HV007\",\n    FdwError_FdwInvalidColumnNumber: \"HV008\",\n    FdwError_FdwInvalidUseOfNullPointer: \"HV009\",\n    FdwError_FdwInvalidStringFormat: \"HV00A\",\n    FdwError_FdwInvalidHandle: \"HV00B\",\n    FdwError_FdwInvalidOptionIndex: \"HV00C\",\n    FdwError_FdwInvalidOptionName: \"HV00D\",\n    FdwError_FdwOptionNameNotFound: \"HV00J\",\n    FdwError_FdwReplyHandle: \"HV00K\",\n    FdwError_FdwUnableToCreateExecution: \"HV00L\",\n    FdwError_FdwUnableToCreateReply: \"HV00M\",\n    FdwError_FdwUnableToEstablishConnection: \"HV00N\",\n    FdwError_FdwNoSchemas: \"HV00P\",\n    FdwError_FdwSchemaNotFound: \"HV00Q\",\n    FdwError_FdwTableNotFound: \"HV00R\",\n    FdwError_FdwFunctionSequenceError: \"HV010\",\n    FdwError_FdwTooManyHandles: \"HV014\",\n    FdwError_FdwInconsistentDescriptorInformation: \"HV021\",\n    FdwError_FdwInvalidAttributeValue: \"HV024\",\n    FdwError_FdwInvalidStringLengthOrBufferLength: \"HV090\",\n    FdwError_FdwInvalidDescriptorFieldIdentifier: \"HV091\",\n    PlpgsqlError_PlpgsqlError: \"P0000\",\n    PlpgsqlError_RaiseException: \"P0001\",\n    PlpgsqlError_NoDataFound: \"P0002\",\n    PlpgsqlError_TooManyRows: \"P0003\",\n    PlpgsqlError_AssertFailure: \"P0004\",\n    InternalError_InternalError: \"XX000\",\n    InternalError_DataCorrupted: \"XX001\",\n    InternalError_IndexCorrupted: \"XX002\",\n};\n","zapatos/src/pgErrors.ts":"/*\n** DON'T EDIT THIS FILE (unless you're working on Zapatos) **\nIt's part of Zapatos, and will be overwritten when the database schema is regenerated\n\nZapatos: https://jawj.github.io/zapatos/\nCopyright (C) 2020 George MacKerron\nReleased under the MIT licence: see LICENCE file\n*/\n\ninterface Error {\n  code?: string;\n}\n\n/**\n * Check whether an error object matches any of a set of Postgres error types.\n * @param err The error to check\n * @param types The Postgres error types to check against\n */\nexport function isDatabaseError(err: Error, ...types: (keyof typeof pgErrors)[]) {\n  const { code } = err;\n  if (!code || code.length !== 5) return false;\n  return types.some(type => code.startsWith(pgErrors[type]));\n}\n\nconst pgErrors = {\n  SuccessfulCompletion: \"00\",\n  Warning: \"01\",\n  NoData: \"02\",\n  SqlStatementNotYetComplete: \"03\",\n  ConnectionException: \"08\",\n  TriggeredActionException: \"09\",\n  FeatureNotSupported: \"0A\",\n  InvalidTransactionInitiation: \"0B\",\n  LocatorException: \"0F\",\n  InvalidGrantor: \"0L\",\n  InvalidRoleSpecification: \"0P\",\n  DiagnosticsException: \"0Z\",\n  CaseNotFound: \"20\",\n  CardinalityViolation: \"21\",\n  DataException: \"22\",\n  IntegrityConstraintViolation: \"23\",\n  InvalidCursorState: \"24\",\n  InvalidTransactionState: \"25\",\n  InvalidSqlStatementName: \"26\",\n  TriggeredDataChangeViolation: \"27\",\n  InvalidAuthorizationSpecification: \"28\",\n  DependentPrivilegeDescriptorsStillExist: \"2B\",\n  InvalidTransactionTermination: \"2D\",\n  SqlRoutineException: \"2F\",\n  InvalidCursorName: \"34\",\n  ExternalRoutineException: \"38\",\n  ExternalRoutineInvocationException: \"39\",\n  SavepointException: \"3B\",\n  InvalidCatalogName: \"3D\",\n  InvalidSchemaName: \"3F\",\n  TransactionRollback: \"40\",\n  SyntaxErrorOrAccessRuleViolation: \"42\",\n  WithCheckOptionViolation: \"44\",\n  InsufficientResources: \"53\",\n  DiskFull: \"53\",\n  OutOfMemory: \"53\",\n  TooManyConnections: \"53\",\n  ConfigurationLimitExceeded: \"53\",\n  ProgramLimitExceeded: \"54\",\n  ObjectNotInPrerequisiteState: \"55\",\n  OperatorIntervention: \"57\",\n  SystemError: \"58\",\n  SnapshotTooOld: \"72\",\n  ConfigFileError: \"F0\",\n  FdwError: \"HV\",\n  PlpgsqlError: \"P0\",\n  InternalError: \"XX\",\n  // specific errors from here\n  SuccessfulCompletion_SuccessfulCompletion: \"00000\",\n  Warning_Warning: \"01000\",\n  Warning_NullValueEliminatedInSetFunction: \"01003\",\n  Warning_StringDataRightTruncation: \"01004\",\n  Warning_PrivilegeNotRevoked: \"01006\",\n  Warning_PrivilegeNotGranted: \"01007\",\n  Warning_ImplicitZeroBitPadding: \"01008\",\n  Warning_DynamicResultSetsReturned: \"0100C\",\n  Warning_DeprecatedFeature: \"01P01\",\n  NoData_NoData: \"02000\",\n  NoData_NoAdditionalDynamicResultSetsReturned: \"02001\",\n  SqlStatementNotYetComplete_SqlStatementNotYetComplete: \"03000\",\n  ConnectionException_ConnectionException: \"08000\",\n  ConnectionException_SqlclientUnableToEstablishSqlconnection: \"08001\",\n  ConnectionException_ConnectionDoesNotExist: \"08003\",\n  ConnectionException_SqlserverRejectedEstablishmentOfSqlconnection: \"08004\",\n  ConnectionException_ConnectionFailure: \"08006\",\n  ConnectionException_TransactionResolutionUnknown: \"08007\",\n  ConnectionException_ProtocolViolation: \"08P01\",\n  TriggeredActionException_TriggeredActionException: \"09000\",\n  FeatureNotSupported_FeatureNotSupported: \"0A000\",\n  InvalidTransactionInitiation_InvalidTransactionInitiation: \"0B000\",\n  LocatorException_LocatorException: \"0F000\",\n  LocatorException_InvalidLocatorSpecification: \"0F001\",\n  InvalidGrantor_InvalidGrantor: \"0L000\",\n  InvalidGrantor_InvalidGrantOperation: \"0LP01\",\n  InvalidRoleSpecification_InvalidRoleSpecification: \"0P000\",\n  DiagnosticsException_DiagnosticsException: \"0Z000\",\n  DiagnosticsException_StackedDiagnosticsAccessedWithoutActiveHandler: \"0Z002\",\n  CaseNotFound_CaseNotFound: \"20000\",\n  CardinalityViolation_CardinalityViolation: \"21000\",\n  DataException_DataException: \"22000\",\n  DataException_StringDataRightTruncation: \"22001\",\n  DataException_NullValueNoIndicatorParameter: \"22002\",\n  DataException_NumericValueOutOfRange: \"22003\",\n  DataException_NullValueNotAllowed: \"22004\",\n  DataException_ErrorInAssignment: \"22005\",\n  DataException_InvalidDatetimeFormat: \"22007\",\n  DataException_DatetimeFieldOverflow: \"22008\",\n  DataException_InvalidTimeZoneDisplacementValue: \"22009\",\n  DataException_EscapeCharacterConflict: \"2200B\",\n  DataException_InvalidUseOfEscapeCharacter: \"2200C\",\n  DataException_InvalidEscapeOctet: \"2200D\",\n  DataException_ZeroLengthCharacterString: \"2200F\",\n  DataException_MostSpecificTypeMismatch: \"2200G\",\n  DataException_SequenceGeneratorLimitExceeded: \"2200H\",\n  DataException_NotAnXmlDocument: \"2200L\",\n  DataException_InvalidXmlDocument: \"2200M\",\n  DataException_InvalidXmlContent: \"2200N\",\n  DataException_InvalidXmlComment: \"2200S\",\n  DataException_InvalidXmlProcessingInstruction: \"2200T\",\n  DataException_InvalidIndicatorParameterValue: \"22010\",\n  DataException_SubstringError: \"22011\",\n  DataException_DivisionByZero: \"22012\",\n  DataException_InvalidPrecedingOrFollowingSize: \"22013\",\n  DataException_InvalidArgumentForNtileFunction: \"22014\",\n  DataException_IntervalFieldOverflow: \"22015\",\n  DataException_InvalidArgumentForNthValueFunction: \"22016\",\n  DataException_InvalidCharacterValueForCast: \"22018\",\n  DataException_InvalidEscapeCharacter: \"22019\",\n  DataException_InvalidRegularExpression: \"2201B\",\n  DataException_InvalidArgumentForLogarithm: \"2201E\",\n  DataException_InvalidArgumentForPowerFunction: \"2201F\",\n  DataException_InvalidArgumentForWidthBucketFunction: \"2201G\",\n  DataException_InvalidRowCountInLimitClause: \"2201W\",\n  DataException_InvalidRowCountInResultOffsetClause: \"2201X\",\n  DataException_CharacterNotInRepertoire: \"22021\",\n  DataException_IndicatorOverflow: \"22022\",\n  DataException_InvalidParameterValue: \"22023\",\n  DataException_UnterminatedCString: \"22024\",\n  DataException_InvalidEscapeSequence: \"22025\",\n  DataException_StringDataLengthMismatch: \"22026\",\n  DataException_TrimError: \"22027\",\n  DataException_ArraySubscriptError: \"2202E\",\n  DataException_InvalidTablesampleRepeat: \"2202G\",\n  DataException_InvalidTablesampleArgument: \"2202H\",\n  DataException_FloatingPointException: \"22P01\",\n  DataException_InvalidTextRepresentation: \"22P02\",\n  DataException_InvalidBinaryRepresentation: \"22P03\",\n  DataException_BadCopyFileFormat: \"22P04\",\n  DataException_UntranslatableCharacter: \"22P05\",\n  DataException_NonstandardUseOfEscapeCharacter: \"22P06\",\n  IntegrityConstraintViolation_IntegrityConstraintViolation: \"23000\",\n  IntegrityConstraintViolation_RestrictViolation: \"23001\",\n  IntegrityConstraintViolation_NotNullViolation: \"23502\",\n  IntegrityConstraintViolation_ForeignKeyViolation: \"23503\",\n  IntegrityConstraintViolation_UniqueViolation: \"23505\",\n  IntegrityConstraintViolation_CheckViolation: \"23514\",\n  IntegrityConstraintViolation_ExclusionViolation: \"23P01\",\n  InvalidCursorState_InvalidCursorState: \"24000\",\n  InvalidTransactionState_InvalidTransactionState: \"25000\",\n  InvalidTransactionState_ActiveSqlTransaction: \"25001\",\n  InvalidTransactionState_BranchTransactionAlreadyActive: \"25002\",\n  InvalidTransactionState_InappropriateAccessModeForBranchTransaction: \"25003\",\n  InvalidTransactionState_InappropriateIsolationLevelForBranchTransaction: \"25004\",\n  InvalidTransactionState_NoActiveSqlTransactionForBranchTransaction: \"25005\",\n  InvalidTransactionState_ReadOnlySqlTransaction: \"25006\",\n  InvalidTransactionState_SchemaAndDataStatementMixingNotSupported: \"25007\",\n  InvalidTransactionState_HeldCursorRequiresSameIsolationLevel: \"25008\",\n  InvalidTransactionState_NoActiveSqlTransaction: \"25P01\",\n  InvalidTransactionState_InFailedSqlTransaction: \"25P02\",\n  InvalidTransactionState_IdleInTransactionSessionTimeout: \"25P03\",\n  InvalidSqlStatementName_InvalidSqlStatementName: \"26000\",\n  TriggeredDataChangeViolation_TriggeredDataChangeViolation: \"27000\",\n  InvalidAuthorizationSpecification_InvalidAuthorizationSpecification: \"28000\",\n  InvalidAuthorizationSpecification_InvalidPassword: \"28P01\",\n  DependentPrivilegeDescriptorsStillExist_DependentPrivilegeDescriptorsStillExist: \"2B000\",\n  DependentPrivilegeDescriptorsStillExist_DependentObjectsStillExist: \"2BP01\",\n  InvalidTransactionTermination_InvalidTransactionTermination: \"2D000\",\n  SqlRoutineException_SqlRoutineException: \"2F000\",\n  SqlRoutineException_ModifyingSqlDataNotPermitted: \"2F002\",\n  SqlRoutineException_ProhibitedSqlStatementAttempted: \"2F003\",\n  SqlRoutineException_ReadingSqlDataNotPermitted: \"2F004\",\n  SqlRoutineException_FunctionExecutedNoReturnStatement: \"2F005\",\n  InvalidCursorName_InvalidCursorName: \"34000\",\n  ExternalRoutineException_ExternalRoutineException: \"38000\",\n  ExternalRoutineException_ContainingSqlNotPermitted: \"38001\",\n  ExternalRoutineException_ModifyingSqlDataNotPermitted: \"38002\",\n  ExternalRoutineException_ProhibitedSqlStatementAttempted: \"38003\",\n  ExternalRoutineException_ReadingSqlDataNotPermitted: \"38004\",\n  ExternalRoutineInvocationException_ExternalRoutineInvocationException: \"39000\",\n  ExternalRoutineInvocationException_InvalidSqlstateReturned: \"39001\",\n  ExternalRoutineInvocationException_NullValueNotAllowed: \"39004\",\n  ExternalRoutineInvocationException_TriggerProtocolViolated: \"39P01\",\n  ExternalRoutineInvocationException_SrfProtocolViolated: \"39P02\",\n  ExternalRoutineInvocationException_EventTriggerProtocolViolated: \"39P03\",\n  SavepointException_SavepointException: \"3B000\",\n  SavepointException_InvalidSavepointSpecification: \"3B001\",\n  InvalidCatalogName_InvalidCatalogName: \"3D000\",\n  InvalidSchemaName_InvalidSchemaName: \"3F000\",\n  TransactionRollback_TransactionRollback: \"40000\",\n  TransactionRollback_SerializationFailure: \"40001\",\n  TransactionRollback_TransactionIntegrityConstraintViolation: \"40002\",\n  TransactionRollback_StatementCompletionUnknown: \"40003\",\n  TransactionRollback_DeadlockDetected: \"40P01\",\n  SyntaxErrorOrAccessRuleViolation_SyntaxErrorOrAccessRuleViolation: \"42000\",\n  SyntaxErrorOrAccessRuleViolation_InsufficientPrivilege: \"42501\",\n  SyntaxErrorOrAccessRuleViolation_SyntaxError: \"42601\",\n  SyntaxErrorOrAccessRuleViolation_InvalidName: \"42602\",\n  SyntaxErrorOrAccessRuleViolation_InvalidColumnDefinition: \"42611\",\n  SyntaxErrorOrAccessRuleViolation_NameTooLong: \"42622\",\n  SyntaxErrorOrAccessRuleViolation_DuplicateColumn: \"42701\",\n  SyntaxErrorOrAccessRuleViolation_AmbiguousColumn: \"42702\",\n  SyntaxErrorOrAccessRuleViolation_UndefinedColumn: \"42703\",\n  SyntaxErrorOrAccessRuleViolation_UndefinedObject: \"42704\",\n  SyntaxErrorOrAccessRuleViolation_DuplicateObject: \"42710\",\n  SyntaxErrorOrAccessRuleViolation_DuplicateAlias: \"42712\",\n  SyntaxErrorOrAccessRuleViolation_DuplicateFunction: \"42723\",\n  SyntaxErrorOrAccessRuleViolation_AmbiguousFunction: \"42725\",\n  SyntaxErrorOrAccessRuleViolation_GroupingError: \"42803\",\n  SyntaxErrorOrAccessRuleViolation_DatatypeMismatch: \"42804\",\n  SyntaxErrorOrAccessRuleViolation_WrongObjectType: \"42809\",\n  SyntaxErrorOrAccessRuleViolation_InvalidForeignKey: \"42830\",\n  SyntaxErrorOrAccessRuleViolation_CannotCoerce: \"42846\",\n  SyntaxErrorOrAccessRuleViolation_UndefinedFunction: \"42883\",\n  SyntaxErrorOrAccessRuleViolation_GeneratedAlways: \"428C9\",\n  SyntaxErrorOrAccessRuleViolation_ReservedName: \"42939\",\n  SyntaxErrorOrAccessRuleViolation_UndefinedTable: \"42P01\",\n  SyntaxErrorOrAccessRuleViolation_UndefinedParameter: \"42P02\",\n  SyntaxErrorOrAccessRuleViolation_DuplicateCursor: \"42P03\",\n  SyntaxErrorOrAccessRuleViolation_DuplicateDatabase: \"42P04\",\n  SyntaxErrorOrAccessRuleViolation_DuplicatePreparedStatement: \"42P05\",\n  SyntaxErrorOrAccessRuleViolation_DuplicateSchema: \"42P06\",\n  SyntaxErrorOrAccessRuleViolation_DuplicateTable: \"42P07\",\n  SyntaxErrorOrAccessRuleViolation_AmbiguousParameter: \"42P08\",\n  SyntaxErrorOrAccessRuleViolation_AmbiguousAlias: \"42P09\",\n  SyntaxErrorOrAccessRuleViolation_InvalidColumnReference: \"42P10\",\n  SyntaxErrorOrAccessRuleViolation_InvalidCursorDefinition: \"42P11\",\n  SyntaxErrorOrAccessRuleViolation_InvalidDatabaseDefinition: \"42P12\",\n  SyntaxErrorOrAccessRuleViolation_InvalidFunctionDefinition: \"42P13\",\n  SyntaxErrorOrAccessRuleViolation_InvalidPreparedStatementDefinition: \"42P14\",\n  SyntaxErrorOrAccessRuleViolation_InvalidSchemaDefinition: \"42P15\",\n  SyntaxErrorOrAccessRuleViolation_InvalidTableDefinition: \"42P16\",\n  SyntaxErrorOrAccessRuleViolation_InvalidObjectDefinition: \"42P17\",\n  SyntaxErrorOrAccessRuleViolation_IndeterminateDatatype: \"42P18\",\n  SyntaxErrorOrAccessRuleViolation_InvalidRecursion: \"42P19\",\n  SyntaxErrorOrAccessRuleViolation_WindowingError: \"42P20\",\n  SyntaxErrorOrAccessRuleViolation_CollationMismatch: \"42P21\",\n  SyntaxErrorOrAccessRuleViolation_IndeterminateCollation: \"42P22\",\n  WithCheckOptionViolation_WithCheckOptionViolation: \"44000\",\n  InsufficientResources_InsufficientResources: \"53000\",\n  InsufficientResources_DiskFull: \"53100\",\n  InsufficientResources_OutOfMemory: \"53200\",\n  InsufficientResources_TooManyConnections: \"53300\",\n  InsufficientResources_ConfigurationLimitExceeded: \"53400\",\n  ProgramLimitExceeded_ProgramLimitExceeded: \"54000\",\n  ProgramLimitExceeded_StatementTooComplex: \"54001\",\n  ProgramLimitExceeded_TooManyColumns: \"54011\",\n  ProgramLimitExceeded_TooManyArguments: \"54023\",\n  ObjectNotInPrerequisiteState_ObjectNotInPrerequisiteState: \"55000\",\n  ObjectNotInPrerequisiteState_ObjectInUse: \"55006\",\n  ObjectNotInPrerequisiteState_CantChangeRuntimeParam: \"55P02\",\n  ObjectNotInPrerequisiteState_LockNotAvailable: \"55P03\",\n  OperatorIntervention_OperatorIntervention: \"57000\",\n  OperatorIntervention_QueryCanceled: \"57014\",\n  OperatorIntervention_AdminShutdown: \"57P01\",\n  OperatorIntervention_CrashShutdown: \"57P02\",\n  OperatorIntervention_CannotConnectNow: \"57P03\",\n  OperatorIntervention_DatabaseDropped: \"57P04\",\n  SystemError_SystemError: \"58000\",\n  SystemError_IoError: \"58030\",\n  SystemError_UndefinedFile: \"58P01\",\n  SystemError_DuplicateFile: \"58P02\",\n  SnapshotTooOld_SnapshotTooOld: \"72000\",\n  ConfigFileError_ConfigFileError: \"F0000\",\n  ConfigFileError_LockFileExists: \"F0001\",\n  FdwError_FdwError: \"HV000\",\n  FdwError_FdwOutOfMemory: \"HV001\",\n  FdwError_FdwDynamicParameterValueNeeded: \"HV002\",\n  FdwError_FdwInvalidDataType: \"HV004\",\n  FdwError_FdwColumnNameNotFound: \"HV005\",\n  FdwError_FdwInvalidDataTypeDescriptors: \"HV006\",\n  FdwError_FdwInvalidColumnName: \"HV007\",\n  FdwError_FdwInvalidColumnNumber: \"HV008\",\n  FdwError_FdwInvalidUseOfNullPointer: \"HV009\",\n  FdwError_FdwInvalidStringFormat: \"HV00A\",\n  FdwError_FdwInvalidHandle: \"HV00B\",\n  FdwError_FdwInvalidOptionIndex: \"HV00C\",\n  FdwError_FdwInvalidOptionName: \"HV00D\",\n  FdwError_FdwOptionNameNotFound: \"HV00J\",\n  FdwError_FdwReplyHandle: \"HV00K\",\n  FdwError_FdwUnableToCreateExecution: \"HV00L\",\n  FdwError_FdwUnableToCreateReply: \"HV00M\",\n  FdwError_FdwUnableToEstablishConnection: \"HV00N\",\n  FdwError_FdwNoSchemas: \"HV00P\",\n  FdwError_FdwSchemaNotFound: \"HV00Q\",\n  FdwError_FdwTableNotFound: \"HV00R\",\n  FdwError_FdwFunctionSequenceError: \"HV010\",\n  FdwError_FdwTooManyHandles: \"HV014\",\n  FdwError_FdwInconsistentDescriptorInformation: \"HV021\",\n  FdwError_FdwInvalidAttributeValue: \"HV024\",\n  FdwError_FdwInvalidStringLengthOrBufferLength: \"HV090\",\n  FdwError_FdwInvalidDescriptorFieldIdentifier: \"HV091\",\n  PlpgsqlError_PlpgsqlError: \"P0000\",\n  PlpgsqlError_RaiseException: \"P0001\",\n  PlpgsqlError_NoDataFound: \"P0002\",\n  PlpgsqlError_TooManyRows: \"P0003\",\n  PlpgsqlError_AssertFailure: \"P0004\",\n  InternalError_InternalError: \"XX000\",\n  InternalError_DataCorrupted: \"XX001\",\n  InternalError_IndexCorrupted: \"XX002\",\n};\n","zapatos/src/shortcuts.js":"/*\n** DON'T EDIT THIS FILE (unless you're working on Zapatos) **\nIt's part of Zapatos, and will be overwritten when the database schema is regenerated\n\nZapatos: https://jawj.github.io/zapatos/\nCopyright (C) 2020 George MacKerron\nReleased under the MIT licence: see LICENCE file\n*/\nimport { all, SQLFragment, sql, cols, vals, raw, param, } from './core';\nimport { completeKeysWithDefault, mapWithSeparator } from './utils';\n/**\n * Generate an `INSERT` query `SQLFragment`.\n * @param table The table into which to insert\n * @param values The `Insertable` values (or array thereof) to be inserted\n */\nexport const insert = function (table, values) {\n    let query;\n    if (Array.isArray(values) && values.length === 0) {\n        query = sql `INSERT INTO ${table} SELECT null WHERE false`;\n        query.noop = true;\n        query.noopResult = [];\n    }\n    else {\n        const completedValues = Array.isArray(values) ? completeKeysWithDefault(values) : values, colsSQL = cols(Array.isArray(completedValues) ? completedValues[0] : completedValues), valuesSQL = Array.isArray(completedValues) ?\n            mapWithSeparator(completedValues, sql `, `, v => sql `(${vals(v)})`) :\n            sql `(${vals(completedValues)})`;\n        query = sql `INSERT INTO ${table} (${colsSQL}) VALUES ${valuesSQL} RETURNING to_jsonb(${table}.*) AS result`;\n    }\n    query.runResultTransform = Array.isArray(values) ?\n        (qr) => qr.rows.map(r => r.result) :\n        (qr) => qr.rows[0].result;\n    return query;\n};\n/* === upsert === */\n/**\n * Wraps a unique index of the target table for use as the arbiter constraint of an\n * `upsert` shortcut query.\n */\nexport class Constraint {\n    constructor(value) {\n        this.value = value;\n    }\n}\n/**\n * Returns a `Constraint` instance, wrapping a unique index of the target table for\n * use as the arbiter constraint of an `upsert` shortcut query.\n */\nexport function constraint(x) { return new Constraint(x); }\n/**\n * Generate an 'upsert' (`INSERT ... ON CONFLICT ...`) query `SQLFragment`.\n * @param table The table to update or insert into\n * @param values An `Insertable` of values (or an array thereof) to be inserted or updated\n * @param conflictTarget A `UNIQUE` index or `UNIQUE`-indexed column (or array thereof) that determines\n * whether this is an `UPDATE` (when there's a matching existing value) or an `INSERT`\n * (when there isn't)\n * @param noNullUpdateCols Optionally, a column (or array thereof) that should not be\n * overwritten with `NULL` values during an update\n */\nexport const upsert = function (table, values, conflictTarget, noNullUpdateCols = []) {\n    if (Array.isArray(values) && values.length === 0)\n        return insert(table, values); // punt a no-op to plain insert\n    if (typeof conflictTarget === 'string')\n        conflictTarget = [conflictTarget]; // now either Column[] or Constraint\n    if (!Array.isArray(noNullUpdateCols))\n        noNullUpdateCols = [noNullUpdateCols];\n    const completedValues = Array.isArray(values) ? completeKeysWithDefault(values) : values, firstRow = Array.isArray(completedValues) ? completedValues[0] : completedValues, colsSQL = cols(firstRow), valuesSQL = Array.isArray(completedValues) ?\n        mapWithSeparator(completedValues, sql `, `, v => sql `(${vals(v)})`) :\n        sql `(${vals(completedValues)})`, colNames = Object.keys(firstRow), nonUniqueCols = Array.isArray(conflictTarget) ?\n        colNames.filter(v => !conflictTarget.includes(v)) :\n        colNames, uniqueColsSQL = Array.isArray(conflictTarget) ?\n        sql `(${mapWithSeparator(conflictTarget.slice().sort(), sql `, `, c => c)})` :\n        sql `ON CONSTRAINT ${conflictTarget.value}`, updateColsSQL = mapWithSeparator(nonUniqueCols.slice().sort(), sql `, `, c => c), updateValuesSQL = mapWithSeparator(nonUniqueCols.slice().sort(), sql `, `, c => noNullUpdateCols.includes(c) ? sql `CASE WHEN EXCLUDED.${c} IS NULL THEN ${table}.${c} ELSE EXCLUDED.${c} END` : sql `EXCLUDED.${c}`);\n    // the added-on $action = 'INSERT' | 'UPDATE' key takes after SQL Server's approach to MERGE\n    // (and on the use of xmax for this purpose, see: https://stackoverflow.com/questions/39058213/postgresql-upsert-differentiate-inserted-and-updated-rows-using-system-columns-x)\n    const query = sql `INSERT INTO ${table} (${colsSQL}) VALUES ${valuesSQL} ON CONFLICT ${uniqueColsSQL} DO UPDATE SET (${updateColsSQL}) = ROW(${updateValuesSQL}) RETURNING to_jsonb(${table}.*) || jsonb_build_object('$action', CASE xmax WHEN 0 THEN 'INSERT' ELSE 'UPDATE' END) AS result`;\n    query.runResultTransform = Array.isArray(completedValues) ?\n        (qr) => qr.rows.map(r => r.result) :\n        (qr) => qr.rows[0].result;\n    return query;\n};\n/**\n * Generate an `UPDATE` query `SQLFragment`.\n * @param table The table to update\n * @param values An `Updatable` of the new values with which to update the table\n * @param where A `Whereable` (or `SQLFragment`) defining which rows to update\n */\nexport const update = function (table, values, where) {\n    // note: the ROW() constructor below is required in Postgres 10+ if we're updating a single column\n    // more info: https://www.postgresql-archive.org/Possible-regression-in-UPDATE-SET-lt-column-list-gt-lt-row-expression-gt-with-just-one-single-column0-td5989074.html\n    const query = sql `UPDATE ${table} SET (${cols(values)}) = ROW(${vals(values)}) WHERE ${where} RETURNING to_jsonb(${table}.*) AS result`;\n    query.runResultTransform = (qr) => qr.rows.map(r => r.result);\n    return query;\n};\n/**\n * Generate an `DELETE` query `SQLFragment` (sadly, plain 'delete' is a reserved word).\n * @param table The table to delete from\n * @param where A `Whereable` (or `SQLFragment`) defining which rows to delete\n */\nexport const deletes = function (table, where) {\n    const query = sql `DELETE FROM ${table} WHERE ${where} RETURNING to_jsonb(${table}.*) AS result`;\n    query.runResultTransform = (qr) => qr.rows.map(r => r.result);\n    return query;\n};\n/**\n * Generate a `TRUNCATE` query `SQLFragment`.\n * @param table The table (or array thereof) to truncate\n * @param opts Options: 'CONTINUE IDENTITY'/'RESTART IDENTITY' and/or 'RESTRICT'/'CASCADE'\n */\nexport const truncate = function (table, ...opts) {\n    if (!Array.isArray(table))\n        table = [table];\n    const tables = mapWithSeparator(table, sql `, `, t => t), query = sql `TRUNCATE ${tables}${raw((opts.length ? ' ' : '') + opts.join(' '))}`;\n    return query;\n};\n;\nexport var SelectResultMode;\n(function (SelectResultMode) {\n    SelectResultMode[SelectResultMode[\"Many\"] = 0] = \"Many\";\n    SelectResultMode[SelectResultMode[\"One\"] = 1] = \"One\";\n    SelectResultMode[SelectResultMode[\"ExactlyOne\"] = 2] = \"ExactlyOne\";\n    SelectResultMode[SelectResultMode[\"Count\"] = 3] = \"Count\";\n})(SelectResultMode || (SelectResultMode = {}));\nexport class NotExactlyOneError extends Error {\n    constructor(query, ...params) {\n        super(...params);\n        if (Error.captureStackTrace)\n            Error.captureStackTrace(this, NotExactlyOneError); // V8 only\n        this.name = 'NotExactlyOneError';\n        this.query = query; // custom property\n    }\n}\n/**\n * Generate a `SELECT` query `SQLFragment`. This can be nested with other `select`/\n * `selectOne`/`count` queries using the `lateral` option.\n * @param table The table to select from\n * @param where A `Whereable` or `SQLFragment` defining the rows to be selected, or `all`\n * @param options Options object. Keys (all optional) are:\n * * `columns` — an array of column names: only these columns will be returned\n * * `order` – an array of `OrderSpec` objects, such as `{ by: 'column', direction: 'ASC'\n * }`\n * * `limit` and `offset` – numbers: apply this limit and offset to the query\n * * `lateral` — an object mapping key(s) to nested `select`/`selectOne`/`count` queries\n * to be `LATERAL JOIN`ed\n * * `alias` — table alias (string): required if using `lateral` to join a table to itself\n * * `extras` — an object mapping key(s) to `SQLFragment`s, so that derived\n * quantities can be included in the JSON result\n * @param mode Used internally by `selectOne` and `count`\n */\nexport const select = function (table, where = all, options = {}, mode = SelectResultMode.Many) {\n    const limit1 = mode === SelectResultMode.One || mode === SelectResultMode.ExactlyOne, allOptions = limit1 ? Object.assign(Object.assign({}, options), { limit: 1 }) : options, alias = allOptions.alias || table, { distinct, groupBy, having, lateral, extras } = allOptions, lock = allOptions.lock === undefined || Array.isArray(allOptions.lock) ? allOptions.lock : [allOptions.lock], order = allOptions.order === undefined || Array.isArray(allOptions.order) ? allOptions.order : [allOptions.order], tableAliasSQL = alias === table ? [] : sql ` AS ${alias}`, distinctSQL = !distinct ? [] : sql ` DISTINCT${distinct instanceof SQLFragment || typeof distinct === 'string' ? sql ` ON (${distinct})` :\n        Array.isArray(distinct) ? sql ` ON (${cols(distinct)})` : []}`, colsSQL = mode === SelectResultMode.Count ?\n        (allOptions.columns ? sql `count(${cols(allOptions.columns)})` : sql `count(${alias}.*)`) :\n        allOptions.columns ?\n            sql `jsonb_build_object(${mapWithSeparator(allOptions.columns, sql `, `, c => sql `${param(c)}::text, ${c}`)})` :\n            sql `to_jsonb(${alias}.*)`, colsLateralSQL = lateral === undefined ? [] :\n        sql ` || jsonb_build_object(${mapWithSeparator(Object.keys(lateral), sql `, `, (k, i) => sql `${param(k)}::text, \"ljoin_${raw(String(i))}\".result`)})`, colsExtraSQL = extras === undefined ? [] :\n        sql ` || jsonb_build_object(${mapWithSeparator(Object.keys(extras), sql `, `, k => sql `${param(k)}::text, ${extras[k]}`)})`, allColsSQL = sql `${colsSQL}${colsLateralSQL}${colsExtraSQL}`, whereSQL = where === all ? [] : sql ` WHERE ${where}`, groupBySQL = !groupBy ? [] : sql ` GROUP BY ${groupBy instanceof SQLFragment || typeof groupBy === 'string' ? groupBy : cols(groupBy)}`, havingSQL = !having ? [] : sql ` HAVING ${having}`, orderSQL = order === undefined ? [] :\n        sql ` ORDER BY ${mapWithSeparator(order, sql `, `, o => {\n            if (!['ASC', 'DESC'].includes(o.direction))\n                throw new Error(`Direction must be ASC/DESC, not '${o.direction}'`);\n            if (o.nulls && !['FIRST', 'LAST'].includes(o.nulls))\n                throw new Error(`Nulls must be FIRST/LAST/undefined, not '${o.nulls}'`);\n            return sql `${o.by} ${raw(o.direction)}${o.nulls ? sql ` NULLS ${raw(o.nulls)}` : []}`;\n        })}`, offsetSQL = allOptions.offset === undefined ? [] : sql ` OFFSET ${param(allOptions.offset)} ROWS`, limitSQL = allOptions.limit === undefined ? [] :\n        sql ` FETCH FIRST ${param(allOptions.limit)} ROWS ${allOptions.withTies ? sql `WITH TIES` : sql `ONLY`}`, lockSQL = lock === undefined ? [] : lock.map(lock => {\n        const ofTables = lock.of === undefined || Array.isArray(lock.of) ? lock.of : [lock.of], ofClause = ofTables === undefined ? [] : sql ` OF ${mapWithSeparator(ofTables, sql `, `, t => t)}`; // `as` clause is required when TS not strict\n        return sql ` FOR ${raw(lock.for)}${ofClause}${lock.wait ? sql ` ${raw(lock.wait)}` : []}`;\n    }), lateralSQL = lateral === undefined ? [] :\n        Object.keys(lateral).map((k, i) => {\n            const subQ = lateral[k];\n            subQ.parentTable = alias; // enables `parent('column')` in subquery's Wherables\n            return sql ` LEFT JOIN LATERAL (${subQ}) AS \"ljoin_${raw(String(i))}\" ON true`;\n        });\n    const rowsQuery = sql `SELECT${distinctSQL} ${allColsSQL} AS result FROM ${table}${tableAliasSQL}${lateralSQL}${whereSQL}${groupBySQL}${havingSQL}${orderSQL}${offsetSQL}${limitSQL}${lockSQL}`, query = mode !== SelectResultMode.Many ? rowsQuery :\n        // we need the aggregate to sit in a sub-SELECT in order to keep ORDER and LIMIT working as usual\n        sql `SELECT coalesce(jsonb_agg(result), '[]') AS result FROM (${rowsQuery}) AS ${raw(`\"sq_${alias}\"`)}`;\n    query.runResultTransform =\n        mode === SelectResultMode.Count ?\n            // note: pg deliberately returns strings for int8 in case 64-bit numbers overflow\n            // (see https://github.com/brianc/node-pg-types#use), but we assume our counts aren't that big\n            (qr) => Number(qr.rows[0].result) :\n            mode === SelectResultMode.ExactlyOne ?\n                (qr) => {\n                    var _a;\n                    const result = (_a = qr.rows[0]) === null || _a === void 0 ? void 0 : _a.result;\n                    if (result === undefined)\n                        throw new NotExactlyOneError(query, 'One result expected but none returned (hint: check `.query.compile()` on this Error)');\n                    return result;\n                } :\n                // SelectResultMode.One or SelectResultMode.Many\n                (qr) => { var _a; return (_a = qr.rows[0]) === null || _a === void 0 ? void 0 : _a.result; };\n    return query;\n};\n/**\n * Generate a `SELECT` query `SQLFragment` that returns only a single result (or\n * undefined). A `LIMIT 1` clause is added automatically. This can be nested with other\n * `select`/`selectOne`/`count` queries using the `lateral` option.\n * @param table The table to select from\n * @param where A `Whereable` or `SQLFragment` defining the rows to be selected, or `all`\n * @param options Options object. See documentation for `select` for details.\n */\nexport const selectOne = function (table, where, options = {}) {\n    // you might argue that 'selectOne' offers little that you can't get with destructuring assignment \n    // and plain 'select' -- e.g. let [x] = async select(...).run(pool); -- but a thing that is definitely worth \n    // having is '| undefined' in the return signature, because the result of indexing never includes undefined\n    // (see e.g. https://github.com/Microsoft/TypeScript/issues/13778)\n    return select(table, where, options, SelectResultMode.One);\n};\n/**\n * Generate a `SELECT` query `SQLFragment` that returns a single result or throws an error.\n * A `LIMIT 1` clause is added automatically. This can be nested with other\n * `select`/`selectOne`/`count` queries using the `lateral` option.\n * @param table The table to select from\n * @param where A `Whereable` or `SQLFragment` defining the rows to be selected, or `all`\n * @param options Options object. See documentation for `select` for details.\n */\nexport const selectExactlyOne = function (table, where, options = {}) {\n    return select(table, where, options, SelectResultMode.ExactlyOne);\n};\n/**\n * Generate a `SELECT` query `SQLFragment` that returns a count. This can be nested in\n * other `select`/`selectOne` queries using their `lateral` option.\n * @param table The table to count from\n * @param where A `Whereable` or `SQLFragment` defining the rows to be counted, or `all`\n * @param options Options object. Keys are: `columns`, `alias`.\n */\nexport const count = function (table, where, options) {\n    return select(table, where, options, SelectResultMode.Count);\n};\n","zapatos/src/shortcuts.ts":"/*\n** DON'T EDIT THIS FILE (unless you're working on Zapatos) **\nIt's part of Zapatos, and will be overwritten when the database schema is regenerated\n\nZapatos: https://jawj.github.io/zapatos/\nCopyright (C) 2020 George MacKerron\nReleased under the MIT licence: see LICENCE file\n*/\n\nimport type {\n  SelectableForTable,\n  WhereableForTable,\n  InsertableForTable,\n  UpdatableForTable,\n  ColumnForTable,\n  UniqueIndexForTable,\n  SQLForTable,\n  Insertable,\n  Updatable,\n  Whereable,\n  Table,\n  Column,\n} from '../schema';\n\nimport {\n  AllType,\n  all,\n  DateString,\n  SQL,\n  SQLFragment,\n  sql,\n  cols,\n  vals,\n  raw,\n  param,\n} from './core';\n\nimport { completeKeysWithDefault, mapWithSeparator } from './utils';\n\ntype JSONSelectableForTable<T extends Table> = { [K in keyof SelectableForTable<T>]:\n  Date extends SelectableForTable<T>[K] ? Exclude<SelectableForTable<T>[K], Date> | DateString :\n  Date[] extends SelectableForTable<T>[K] ? Exclude<SelectableForTable<T>[K], Date[]> | DateString[] :\n  SelectableForTable<T>[K]\n};\n\n\n/* === insert === */\n\ninterface InsertSignatures {\n  <T extends Table>(table: T, values: InsertableForTable<T>): SQLFragment<JSONSelectableForTable<T>>;\n  <T extends Table>(table: T, values: InsertableForTable<T>[]): SQLFragment<JSONSelectableForTable<T>[]>;\n}\n\n/**\n * Generate an `INSERT` query `SQLFragment`.\n * @param table The table into which to insert\n * @param values The `Insertable` values (or array thereof) to be inserted\n */\nexport const insert: InsertSignatures = function\n  (table: Table, values: Insertable | Insertable[]): SQLFragment<any> {\n\n  let query;\n  if (Array.isArray(values) && values.length === 0) {\n    query = sql`INSERT INTO ${table} SELECT null WHERE false`;\n    query.noop = true;\n    query.noopResult = [];\n\n  } else {\n    const\n      completedValues = Array.isArray(values) ? completeKeysWithDefault(values) : values,\n      colsSQL = cols(Array.isArray(completedValues) ? completedValues[0] : completedValues),\n      valuesSQL = Array.isArray(completedValues) ?\n        mapWithSeparator(completedValues as Insertable[], sql<SQL>`, `, v => sql<SQL>`(${vals(v)})`) :\n        sql<SQL>`(${vals(completedValues)})`;\n\n    query = sql<SQL>`INSERT INTO ${table} (${colsSQL}) VALUES ${valuesSQL} RETURNING to_jsonb(${table}.*) AS result`;\n  }\n\n  query.runResultTransform = Array.isArray(values) ?\n    (qr) => qr.rows.map(r => r.result) :\n    (qr) => qr.rows[0].result;\n\n  return query;\n};\n\n\n/* === upsert === */\n\n/**\n * Wraps a unique index of the target table for use as the arbiter constraint of an \n * `upsert` shortcut query.\n */\nexport class Constraint<T extends Table> { constructor(public value: UniqueIndexForTable<T>) { } }\n/**\n * Returns a `Constraint` instance, wrapping a unique index of the target table for \n * use as the arbiter constraint of an `upsert` shortcut query.\n */\nexport function constraint<T extends Table>(x: UniqueIndexForTable<T>) { return new Constraint<T>(x); }\n\nexport interface UpsertAction { $action: 'INSERT' | 'UPDATE' }\ntype UpsertReturnableForTable<T extends Table> = JSONSelectableForTable<T> & UpsertAction;\ntype UpsertConflictTargetForTable<T extends Table> = Constraint<T> | ColumnForTable<T> | ColumnForTable<T>[];\n\ninterface UpsertSignatures {\n  <T extends Table>(table: T, values: InsertableForTable<T>, conflictTarget: UpsertConflictTargetForTable<T>, noNullUpdateCols?: ColumnForTable<T> | ColumnForTable<T>[]): SQLFragment<UpsertReturnableForTable<T>>;\n  <T extends Table>(table: T, values: InsertableForTable<T>[], conflictTarget: UpsertConflictTargetForTable<T>, noNullUpdateCols?: ColumnForTable<T> | ColumnForTable<T>[]): SQLFragment<UpsertReturnableForTable<T>[]>;\n}\n\n/**\n * Generate an 'upsert' (`INSERT ... ON CONFLICT ...`) query `SQLFragment`.\n * @param table The table to update or insert into\n * @param values An `Insertable` of values (or an array thereof) to be inserted or updated\n * @param conflictTarget A `UNIQUE` index or `UNIQUE`-indexed column (or array thereof) that determines\n * whether this is an `UPDATE` (when there's a matching existing value) or an `INSERT` \n * (when there isn't)\n * @param noNullUpdateCols Optionally, a column (or array thereof) that should not be \n * overwritten with `NULL` values during an update\n */\nexport const upsert: UpsertSignatures = function\n  (table: Table, values: Insertable | Insertable[], conflictTarget: Column | Column[] | Constraint<Table>, noNullUpdateCols: Column | Column[] = []): SQLFragment<any> {\n\n  if (Array.isArray(values) && values.length === 0) return insert(table, values);  // punt a no-op to plain insert\n\n  if (typeof conflictTarget === 'string') conflictTarget = [conflictTarget];  // now either Column[] or Constraint\n  if (!Array.isArray(noNullUpdateCols)) noNullUpdateCols = [noNullUpdateCols];\n\n  const\n    completedValues = Array.isArray(values) ? completeKeysWithDefault(values) : values,\n    firstRow = Array.isArray(completedValues) ? completedValues[0] : completedValues,\n    colsSQL = cols(firstRow),\n    valuesSQL = Array.isArray(completedValues) ?\n      mapWithSeparator(completedValues as Insertable[], sql`, `, v => sql`(${vals(v)})`) :\n      sql`(${vals(completedValues)})`,\n    colNames = Object.keys(firstRow) as Column[],\n    nonUniqueCols = Array.isArray(conflictTarget) ?\n      colNames.filter(v => !(conflictTarget as Column[]).includes(v)) :\n      colNames,\n    uniqueColsSQL = Array.isArray(conflictTarget) ?\n      sql`(${mapWithSeparator(conflictTarget.slice().sort(), sql`, `, c => c)})` :\n      sql<string>`ON CONSTRAINT ${conflictTarget.value}`,\n    updateColsSQL = mapWithSeparator(nonUniqueCols.slice().sort(), sql`, `, c => c),\n    updateValuesSQL = mapWithSeparator(nonUniqueCols.slice().sort(), sql`, `, c =>\n      noNullUpdateCols.includes(c) ? sql`CASE WHEN EXCLUDED.${c} IS NULL THEN ${table}.${c} ELSE EXCLUDED.${c} END` : sql`EXCLUDED.${c}`);\n\n  // the added-on $action = 'INSERT' | 'UPDATE' key takes after SQL Server's approach to MERGE\n  // (and on the use of xmax for this purpose, see: https://stackoverflow.com/questions/39058213/postgresql-upsert-differentiate-inserted-and-updated-rows-using-system-columns-x)\n\n  const query = sql<SQL>`INSERT INTO ${table} (${colsSQL}) VALUES ${valuesSQL} ON CONFLICT ${uniqueColsSQL} DO UPDATE SET (${updateColsSQL}) = ROW(${updateValuesSQL}) RETURNING to_jsonb(${table}.*) || jsonb_build_object('$action', CASE xmax WHEN 0 THEN 'INSERT' ELSE 'UPDATE' END) AS result`;\n\n  query.runResultTransform = Array.isArray(completedValues) ?\n    (qr) => qr.rows.map(r => r.result) :\n    (qr) => qr.rows[0].result;\n\n  return query;\n};\n\n\n/* === update === */\n\ninterface UpdateSignatures {\n  <T extends Table>(table: T, values: UpdatableForTable<T>, where: WhereableForTable<T> | SQLFragment): SQLFragment<JSONSelectableForTable<T>[]>;\n}\n\n/**\n * Generate an `UPDATE` query `SQLFragment`.\n * @param table The table to update\n * @param values An `Updatable` of the new values with which to update the table\n * @param where A `Whereable` (or `SQLFragment`) defining which rows to update\n */\nexport const update: UpdateSignatures = function (\n  table: Table,\n  values: Updatable,\n  where: Whereable | SQLFragment): SQLFragment {\n\n  // note: the ROW() constructor below is required in Postgres 10+ if we're updating a single column\n  // more info: https://www.postgresql-archive.org/Possible-regression-in-UPDATE-SET-lt-column-list-gt-lt-row-expression-gt-with-just-one-single-column0-td5989074.html\n\n  const query = sql<SQL>`UPDATE ${table} SET (${cols(values)}) = ROW(${vals(values)}) WHERE ${where} RETURNING to_jsonb(${table}.*) AS result`;\n  query.runResultTransform = (qr) => qr.rows.map(r => r.result);\n  return query;\n};\n\n\n/* === delete === */\n\nexport interface DeleteSignatures {\n  <T extends Table>(table: T, where: WhereableForTable<T> | SQLFragment): SQLFragment<JSONSelectableForTable<T>[]>;\n}\n\n/**\n * Generate an `DELETE` query `SQLFragment` (sadly, plain 'delete' is a reserved word).\n * @param table The table to delete from\n * @param where A `Whereable` (or `SQLFragment`) defining which rows to delete\n */\nexport const deletes: DeleteSignatures = function\n  (table: Table, where: Whereable | SQLFragment): SQLFragment {\n\n  const query = sql<SQL>`DELETE FROM ${table} WHERE ${where} RETURNING to_jsonb(${table}.*) AS result`;\n  query.runResultTransform = (qr) => qr.rows.map(r => r.result);\n  return query;\n};\n\n\n/* === truncate === */\n\ntype TruncateIdentityOpts = 'CONTINUE IDENTITY' | 'RESTART IDENTITY';\ntype TruncateForeignKeyOpts = 'RESTRICT' | 'CASCADE';\n\ninterface TruncateSignatures {\n  (table: Table | Table[]): SQLFragment<undefined>;\n  (table: Table | Table[], optId: TruncateIdentityOpts): SQLFragment<undefined>;\n  (table: Table | Table[], optFK: TruncateForeignKeyOpts): SQLFragment<undefined>;\n  (table: Table | Table[], optId: TruncateIdentityOpts, optFK: TruncateForeignKeyOpts): SQLFragment<undefined>;\n}\n\n/**\n * Generate a `TRUNCATE` query `SQLFragment`.\n * @param table The table (or array thereof) to truncate\n * @param opts Options: 'CONTINUE IDENTITY'/'RESTART IDENTITY' and/or 'RESTRICT'/'CASCADE'\n */\nexport const truncate: TruncateSignatures = function\n  (table: Table | Table[], ...opts: string[]): SQLFragment<undefined> {\n\n  if (!Array.isArray(table)) table = [table];\n  const\n    tables = mapWithSeparator(table, sql`, `, t => t),\n    query = sql<SQL, undefined>`TRUNCATE ${tables}${raw((opts.length ? ' ' : '') + opts.join(' '))}`;\n\n  return query;\n};\n\n\n/* === select === */\n\ninterface OrderSpecForTable<T extends Table> {\n  by: SQLForTable<T>;\n  direction: 'ASC' | 'DESC';\n  nulls?: 'FIRST' | 'LAST';\n}\n\nexport interface SelectLockingOptions {\n  for: 'UPDATE' | 'NO KEY UPDATE' | 'SHARE' | 'KEY SHARE';\n  of?: Table | Table[];\n  wait?: 'NOWAIT' | 'SKIP LOCKED';\n}\n\nexport interface SelectOptionsForTable<\n  T extends Table,\n  C extends ColumnForTable<T>[] | undefined,\n  L extends SQLFragmentsMap | undefined,\n  E extends SQLFragmentsMap | undefined,\n  > {\n  distinct?: boolean | ColumnForTable<T> | ColumnForTable<T>[] | SQLFragment<any>;\n  order?: OrderSpecForTable<T> | OrderSpecForTable<T>[];\n  limit?: number;\n  offset?: number;\n  withTies?: boolean;\n  columns?: C;\n  extras?: E;\n  groupBy?: ColumnForTable<T> | ColumnForTable<T>[] | SQLFragment<any>;\n  having?: WhereableForTable<T> | SQLFragment<any>;\n  lateral?: L;\n  alias?: string;\n  lock?: SelectLockingOptions | SelectLockingOptions[];\n};\n\nexport interface SQLFragmentsMap { [k: string]: SQLFragment<any> }\nexport type PromisedType<P> = P extends Promise<infer U> ? U : never;\nexport type PromisedSQLFragmentReturnType<R extends SQLFragment<any>> = PromisedType<ReturnType<R['run']>>;\n\n// yes, the next two types are identical, but distinct names make complex inferred types more readable\nexport type Lateral<L extends SQLFragmentsMap> = { [K in keyof L]: PromisedSQLFragmentReturnType<L[K]> };\nexport type Extras<L extends SQLFragmentsMap> = { [K in keyof L]: PromisedSQLFragmentReturnType<L[K]> };\n\nexport type JSONOnlyColsForTable<T extends Table, C extends any[] /* `ColumnForTable<T>[]` gives errors here for reasons I haven't got to the bottom of */> = Pick<JSONSelectableForTable<T>, C[number]>;\n\ntype BaseSelectReturnTypeForTable<T extends Table, C extends ColumnForTable<T>[] | undefined> =\n  undefined extends C ? JSONSelectableForTable<T> :\n  C extends ColumnForTable<T>[] ? JSONOnlyColsForTable<T, C> :\n  never;\n\ntype EnhancedSelectReturnTypeForTable<\n  T extends Table,\n  C extends ColumnForTable<T>[] | undefined,\n  L extends SQLFragmentsMap | undefined,\n  E extends SQLFragmentsMap | undefined,\n  > =\n  undefined extends L ?\n  (undefined extends E ? BaseSelectReturnTypeForTable<T, C> :\n    E extends SQLFragmentsMap ? BaseSelectReturnTypeForTable<T, C> & Extras<E> :\n    never) :\n  L extends SQLFragmentsMap ?\n  (undefined extends E ? BaseSelectReturnTypeForTable<T, C> & Lateral<L> :\n    E extends SQLFragmentsMap ? BaseSelectReturnTypeForTable<T, C> & Lateral<L> & Extras<E> :\n    never) :\n  never;\n\nexport enum SelectResultMode { Many, One, ExactlyOne, Count }\n\nexport type FullSelectReturnTypeForTable<\n  T extends Table,\n  C extends ColumnForTable<T>[] | undefined,\n  L extends SQLFragmentsMap | undefined,\n  E extends SQLFragmentsMap | undefined,\n  M extends SelectResultMode,\n  > =\n  {\n    [SelectResultMode.Many]: EnhancedSelectReturnTypeForTable<T, C, L, E>[];\n    [SelectResultMode.ExactlyOne]: EnhancedSelectReturnTypeForTable<T, C, L, E>;\n    [SelectResultMode.One]: EnhancedSelectReturnTypeForTable<T, C, L, E> | undefined;\n    [SelectResultMode.Count]: number;\n  }[M];\n\nexport interface SelectSignatures {\n  <T extends Table,\n    C extends ColumnForTable<T>[] | undefined,\n    L extends SQLFragmentsMap | undefined,\n    E extends SQLFragmentsMap | undefined,\n    M extends SelectResultMode = SelectResultMode.Many\n    >(\n    table: T,\n    where: WhereableForTable<T> | SQLFragment | AllType,\n    options?: SelectOptionsForTable<T, C, L, E>,\n    mode?: M,\n  ): SQLFragment<FullSelectReturnTypeForTable<T, C, L, E, M>>;\n}\n\nexport class NotExactlyOneError extends Error {\n  // see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error\n  query: SQLFragment;\n  constructor(query: SQLFragment, ...params: any[]) {\n    super(...params);\n    if (Error.captureStackTrace) Error.captureStackTrace(this, NotExactlyOneError);  // V8 only\n    this.name = 'NotExactlyOneError';\n    this.query = query;  // custom property\n  }\n}\n\n/**\n * Generate a `SELECT` query `SQLFragment`. This can be nested with other `select`/\n * `selectOne`/`count` queries using the `lateral` option.\n * @param table The table to select from\n * @param where A `Whereable` or `SQLFragment` defining the rows to be selected, or `all`\n * @param options Options object. Keys (all optional) are: \n * * `columns` — an array of column names: only these columns will be returned\n * * `order` – an array of `OrderSpec` objects, such as `{ by: 'column', direction: 'ASC' \n * }`  \n * * `limit` and `offset` – numbers: apply this limit and offset to the query\n * * `lateral` — an object mapping key(s) to nested `select`/`selectOne`/`count` queries \n * to be `LATERAL JOIN`ed\n * * `alias` — table alias (string): required if using `lateral` to join a table to itself\n * * `extras` — an object mapping key(s) to `SQLFragment`s, so that derived \n * quantities can be included in the JSON result\n * @param mode Used internally by `selectOne` and `count`\n */\nexport const select: SelectSignatures = function (\n  table: Table,\n  where: Whereable | SQLFragment | AllType = all,\n  options: SelectOptionsForTable<Table, ColumnForTable<Table>[] | undefined, SQLFragmentsMap | undefined, SQLFragmentsMap | undefined> = {},\n  mode: SelectResultMode = SelectResultMode.Many,\n) {\n\n  const\n    limit1 = mode === SelectResultMode.One || mode === SelectResultMode.ExactlyOne,\n    allOptions = limit1 ? { ...options, limit: 1 } : options,\n    alias = allOptions.alias || table,\n    { distinct, groupBy, having, lateral, extras } = allOptions,\n    lock = allOptions.lock === undefined || Array.isArray(allOptions.lock) ? allOptions.lock : [allOptions.lock],\n    order = allOptions.order === undefined || Array.isArray(allOptions.order) ? allOptions.order : [allOptions.order],\n    tableAliasSQL = alias === table ? [] : sql<string>` AS ${alias}`,\n    distinctSQL = !distinct ? [] : sql` DISTINCT${distinct instanceof SQLFragment || typeof distinct === 'string' ? sql` ON (${distinct})` :\n      Array.isArray(distinct) ? sql` ON (${cols(distinct)})` : []}`,\n    colsSQL = mode === SelectResultMode.Count ?\n      (allOptions.columns ? sql`count(${cols(allOptions.columns)})` : sql<typeof alias>`count(${alias}.*)`) :\n      allOptions.columns ?\n        sql`jsonb_build_object(${mapWithSeparator(allOptions.columns, sql`, `, c => sql<SQL>`${param(c)}::text, ${c}`)})` :\n        sql<typeof alias>`to_jsonb(${alias}.*)`,\n    colsLateralSQL = lateral === undefined ? [] :\n      sql` || jsonb_build_object(${mapWithSeparator(\n        Object.keys(lateral), sql`, `, (k, i) => sql<SQL>`${param(k)}::text, \"ljoin_${raw(String(i))}\".result`)})`,\n    colsExtraSQL = extras === undefined ? [] :\n      sql<any[]>` || jsonb_build_object(${mapWithSeparator(\n        Object.keys(extras), sql`, `, k => sql<SQL>`${param(k)}::text, ${extras![k]}`)})`,\n    allColsSQL = sql`${colsSQL}${colsLateralSQL}${colsExtraSQL}`,\n    whereSQL = where === all ? [] : sql` WHERE ${where}`,\n    groupBySQL = !groupBy ? [] : sql` GROUP BY ${groupBy instanceof SQLFragment || typeof groupBy === 'string' ? groupBy : cols(groupBy)}`,\n    havingSQL = !having ? [] : sql` HAVING ${having}`,\n    orderSQL = order === undefined ? [] :\n      sql` ORDER BY ${mapWithSeparator(order as OrderSpecForTable<Table>[], sql`, `, o => {  // `as` clause is required when TS not strict\n        if (!['ASC', 'DESC'].includes(o.direction)) throw new Error(`Direction must be ASC/DESC, not '${o.direction}'`);\n        if (o.nulls && !['FIRST', 'LAST'].includes(o.nulls)) throw new Error(`Nulls must be FIRST/LAST/undefined, not '${o.nulls}'`);\n        return sql`${o.by} ${raw(o.direction)}${o.nulls ? sql` NULLS ${raw(o.nulls)}` : []}`;\n      })}`,\n    offsetSQL = allOptions.offset === undefined ? [] : sql` OFFSET ${param(allOptions.offset)} ROWS`,\n    limitSQL = allOptions.limit === undefined ? [] :\n      sql<SQL>` FETCH FIRST ${param(allOptions.limit)} ROWS ${allOptions.withTies ? sql`WITH TIES` : sql`ONLY`}`,\n    lockSQL = lock === undefined ? [] : (lock as SelectLockingOptions[]).map(lock => {  // `as` clause is required when TS not strict\n      const\n        ofTables = lock.of === undefined || Array.isArray(lock.of) ? lock.of : [lock.of],\n        ofClause = ofTables === undefined ? [] : sql` OF ${mapWithSeparator(ofTables as Table[], sql`, `, t => t)}`;  // `as` clause is required when TS not strict\n      return sql<SQL>` FOR ${raw(lock.for)}${ofClause}${lock.wait ? sql` ${raw(lock.wait)}` : []}`;\n    }),\n    lateralSQL = lateral === undefined ? [] :\n      Object.keys(lateral).map((k, i) => {\n        const subQ = lateral[k];\n        subQ.parentTable = alias;  // enables `parent('column')` in subquery's Wherables\n        return sql<SQL>` LEFT JOIN LATERAL (${subQ}) AS \"ljoin_${raw(String(i))}\" ON true`;\n      });\n\n  const\n    rowsQuery = sql<SQL, any>`SELECT${distinctSQL} ${allColsSQL} AS result FROM ${table}${tableAliasSQL}${lateralSQL}${whereSQL}${groupBySQL}${havingSQL}${orderSQL}${offsetSQL}${limitSQL}${lockSQL}`,\n    query = mode !== SelectResultMode.Many ? rowsQuery :\n      // we need the aggregate to sit in a sub-SELECT in order to keep ORDER and LIMIT working as usual\n      sql<SQL, any>`SELECT coalesce(jsonb_agg(result), '[]') AS result FROM (${rowsQuery}) AS ${raw(`\"sq_${alias}\"`)}`;\n\n  query.runResultTransform =\n\n    mode === SelectResultMode.Count ?\n      // note: pg deliberately returns strings for int8 in case 64-bit numbers overflow\n      // (see https://github.com/brianc/node-pg-types#use), but we assume our counts aren't that big\n      (qr) => Number(qr.rows[0].result) :\n\n      mode === SelectResultMode.ExactlyOne ?\n        (qr) => {\n          const result = qr.rows[0]?.result;\n          if (result === undefined) throw new NotExactlyOneError(query, 'One result expected but none returned (hint: check `.query.compile()` on this Error)');\n          return result;\n        } :\n\n        // SelectResultMode.One or SelectResultMode.Many\n        (qr) => qr.rows[0]?.result;\n\n  return query;\n};\n\n\n/* === selectOne === */\n\nexport interface SelectOneSignatures {\n  <\n    T extends Table,\n    C extends ColumnForTable<T>[] | undefined,\n    L extends SQLFragmentsMap | undefined,\n    E extends SQLFragmentsMap | undefined\n    >(\n    table: T,\n    where: WhereableForTable<T> | SQLFragment | AllType,\n    options?: SelectOptionsForTable<T, C, L, E>,\n  ): SQLFragment<FullSelectReturnTypeForTable<T, C, L, E, SelectResultMode.One>>;\n}\n\n/**\n * Generate a `SELECT` query `SQLFragment` that returns only a single result (or \n * undefined). A `LIMIT 1` clause is added automatically. This can be nested with other \n * `select`/`selectOne`/`count` queries using the `lateral` option.\n * @param table The table to select from\n * @param where A `Whereable` or `SQLFragment` defining the rows to be selected, or `all`\n * @param options Options object. See documentation for `select` for details.\n */\nexport const selectOne: SelectOneSignatures = function (table, where, options = {}) {\n  // you might argue that 'selectOne' offers little that you can't get with destructuring assignment \n  // and plain 'select' -- e.g. let [x] = async select(...).run(pool); -- but a thing that is definitely worth \n  // having is '| undefined' in the return signature, because the result of indexing never includes undefined\n  // (see e.g. https://github.com/Microsoft/TypeScript/issues/13778)\n\n  return select(table, where, options, SelectResultMode.One);\n};\n\n\n/* === selectExactlyOne === */\n\nexport interface SelectExactlyOneSignatures {\n  <\n    T extends Table,\n    C extends ColumnForTable<T>[] | undefined,\n    L extends SQLFragmentsMap | undefined,\n    E extends SQLFragmentsMap | undefined\n    >(\n    table: T,\n    where: WhereableForTable<T> | SQLFragment | AllType,\n    options?: SelectOptionsForTable<T, C, L, E>,\n  ): SQLFragment<FullSelectReturnTypeForTable<T, C, L, E, SelectResultMode.ExactlyOne>>;\n}\n\n/**\n * Generate a `SELECT` query `SQLFragment` that returns a single result or throws an error. \n * A `LIMIT 1` clause is added automatically. This can be nested with other \n * `select`/`selectOne`/`count` queries using the `lateral` option.\n * @param table The table to select from\n * @param where A `Whereable` or `SQLFragment` defining the rows to be selected, or `all`\n * @param options Options object. See documentation for `select` for details.\n */\n\nexport const selectExactlyOne: SelectExactlyOneSignatures = function (table, where, options = {}) {\n  return select(table, where, options, SelectResultMode.ExactlyOne);\n};\n\n\n/* === count === */\n\nexport interface CountSignatures {\n  <T extends Table>(\n    table: T,\n    where: WhereableForTable<T> | SQLFragment | AllType,\n    options?: { columns?: ColumnForTable<T>[]; alias?: string },\n  ): SQLFragment<number>;\n}\n\n/**\n * Generate a `SELECT` query `SQLFragment` that returns a count. This can be nested in \n * other `select`/`selectOne` queries using their `lateral` option.\n * @param table The table to count from\n * @param where A `Whereable` or `SQLFragment` defining the rows to be counted, or `all`\n * @param options Options object. Keys are: `columns`, `alias`.\n */\nexport const count: CountSignatures = function (table, where, options?) {\n  return select(table, where, options, SelectResultMode.Count);\n};\n","zapatos/src/transaction.js":"/*\n** DON'T EDIT THIS FILE (unless you're working on Zapatos) **\nIt's part of Zapatos, and will be overwritten when the database schema is regenerated\n\nZapatos: https://jawj.github.io/zapatos/\nCopyright (C) 2020 George MacKerron\nReleased under the MIT licence: see LICENCE file\n*/\nimport { isDatabaseError } from './pgErrors';\nimport { wait } from './utils';\nimport { sql, raw } from './core';\nimport { getConfig } from \"./config\";\nexport var Isolation;\n(function (Isolation) {\n    // these are the only meaningful values in Postgres: \n    // see https://www.postgresql.org/docs/11/sql-set-transaction.html\n    Isolation[\"Serializable\"] = \"SERIALIZABLE\";\n    Isolation[\"RepeatableRead\"] = \"REPEATABLE READ\";\n    Isolation[\"ReadCommitted\"] = \"READ COMMITTED\";\n    Isolation[\"SerializableRO\"] = \"SERIALIZABLE, READ ONLY\";\n    Isolation[\"RepeatableReadRO\"] = \"REPEATABLE READ, READ ONLY\";\n    Isolation[\"ReadCommittedRO\"] = \"READ COMMITTED, READ ONLY\";\n    Isolation[\"SerializableRODeferrable\"] = \"SERIALIZABLE, READ ONLY, DEFERRABLE\";\n})(Isolation || (Isolation = {}));\nlet txnSeq = 0;\n/**\n * Provide a database client to the callback, whose queries are then wrapped in a\n * database transaction. The transaction is committed, retried, or rolled back as\n * appropriate.\n * @param pool The `pg.Pool` from which to check out the database client\n * @param isolationMode The `Isolation` mode (e.g `Serializable`)\n * @param callback The callback function that runs queries on the provided client\n */\nexport async function transaction(pool, isolationMode, callback) {\n    const txnId = txnSeq++, txnClient = await pool.connect(), config = getConfig(), { transactionListener } = config, maxAttempts = config.transactionAttemptsMax, { minMs, maxMs } = config.transactionRetryDelay;\n    try {\n        for (let attempt = 1;; attempt++) {\n            try {\n                if (attempt > 1 && transactionListener)\n                    transactionListener(`Retrying transaction #${txnId}, attempt ${attempt} of ${maxAttempts}`);\n                await sql `START TRANSACTION ISOLATION LEVEL ${raw(isolationMode)}`.run(txnClient);\n                const result = await callback(txnClient);\n                await sql `COMMIT`.run(txnClient);\n                return result;\n            }\n            catch (err) {\n                await sql `ROLLBACK`.run(txnClient);\n                // on trapping the following two rollback error codes, see:\n                // https://www.postgresql.org/message-id/1368066680.60649.YahooMailNeo@web162902.mail.bf1.yahoo.com\n                // this is also a good read:\n                // https://www.enterprisedb.com/blog/serializable-postgresql-11-and-beyond\n                if (isDatabaseError(err, \"TransactionRollback_SerializationFailure\", \"TransactionRollback_DeadlockDetected\")) {\n                    if (attempt < maxAttempts) {\n                        const delayBeforeRetry = Math.round(minMs + (maxMs - minMs) * Math.random());\n                        if (transactionListener)\n                            transactionListener(`Transaction #${txnId} rollback (code ${err.code}) on attempt ${attempt} of ${maxAttempts}, retrying in ${delayBeforeRetry}ms`);\n                        await wait(delayBeforeRetry);\n                    }\n                    else {\n                        if (transactionListener)\n                            transactionListener(`Transaction #${txnId} rollback (code ${err.code}) on attempt ${attempt} of ${maxAttempts}, giving up`);\n                        throw err;\n                    }\n                }\n                else {\n                    throw err;\n                }\n            }\n        }\n    }\n    finally {\n        txnClient.release();\n    }\n}\n/**\n * Shortcut for `transaction` with isolation mode Serializable.\n * @param pool The `pg.Pool` from which to check out the database client\n * @param callback The callback function that runs queries on the provided client\n */\nexport async function serializable(pool, callback) {\n    return transaction(pool, Isolation.Serializable, callback);\n}\n/**\n * Shortcut for `transaction` with isolation mode RepeatableRead.\n * @param pool The `pg.Pool` from which to check out the database client\n * @param callback The callback function that runs queries on the provided client\n */\nexport async function repeatableRead(pool, callback) {\n    return transaction(pool, Isolation.RepeatableRead, callback);\n}\n/**\n * Shortcut for `transaction` with isolation mode ReadCommitted.\n * @param pool The `pg.Pool` from which to check out the database client\n * @param callback The callback function that runs queries on the provided client\n */\nexport async function readCommitted(pool, callback) {\n    return transaction(pool, Isolation.ReadCommitted, callback);\n}\n/**\n * Shortcut for `transaction` with isolation mode SerializableRO.\n * @param pool The `pg.Pool` from which to check out the database client\n * @param callback The callback function that runs queries on the provided client\n */\nexport async function serializableRO(pool, callback) {\n    return transaction(pool, Isolation.SerializableRO, callback);\n}\n/**\n * Shortcut for `transaction` with isolation mode RepeatableReadRO.\n * @param pool The `pg.Pool` from which to check out the database client\n * @param callback The callback function that runs queries on the provided client\n */\nexport async function repeatableReadRO(pool, callback) {\n    return transaction(pool, Isolation.RepeatableReadRO, callback);\n}\n/**\n * Shortcut for `transaction` with isolation mode ReadCommittedRO.\n * @param pool The `pg.Pool` from which to check out the database client\n * @param callback The callback function that runs queries on the provided client\n */\nexport async function readCommittedRO(pool, callback) {\n    return transaction(pool, Isolation.ReadCommittedRO, callback);\n}\n/**\n * Shortcut for `transaction` with isolation mode SerializableRODeferrable.\n * @param pool The `pg.Pool` from which to check out the database client\n * @param callback The callback function that runs queries on the provided client\n */\nexport async function serializableRODeferrable(pool, callback) {\n    return transaction(pool, Isolation.SerializableRODeferrable, callback);\n}\n","zapatos/src/transaction.ts":"/*\n** DON'T EDIT THIS FILE (unless you're working on Zapatos) **\nIt's part of Zapatos, and will be overwritten when the database schema is regenerated\n\nZapatos: https://jawj.github.io/zapatos/\nCopyright (C) 2020 George MacKerron\nReleased under the MIT licence: see LICENCE file\n*/\n\nimport type * as pg from 'pg';\nimport { isDatabaseError } from './pgErrors';\nimport { wait } from './utils';\nimport { sql, raw } from './core';\nimport { getConfig } from \"./config\";\n\n\nexport enum Isolation {\n  // these are the only meaningful values in Postgres: \n  // see https://www.postgresql.org/docs/11/sql-set-transaction.html\n  Serializable = \"SERIALIZABLE\",\n  RepeatableRead = \"REPEATABLE READ\",\n  ReadCommitted = \"READ COMMITTED\",\n  SerializableRO = \"SERIALIZABLE, READ ONLY\",\n  RepeatableReadRO = \"REPEATABLE READ, READ ONLY\",\n  ReadCommittedRO = \"READ COMMITTED, READ ONLY\",\n  SerializableRODeferrable = \"SERIALIZABLE, READ ONLY, DEFERRABLE\"\n}\n\nexport declare namespace TxnSatisfying {\n  export type Serializable = Isolation.Serializable;\n  export type RepeatableRead = Serializable | Isolation.RepeatableRead;\n  export type ReadCommitted = RepeatableRead | Isolation.ReadCommitted;\n  export type SerializableRO = Serializable | Isolation.SerializableRO;\n  export type RepeatableReadRO = SerializableRO | RepeatableRead | Isolation.RepeatableReadRO;\n  export type ReadCommittedRO = RepeatableReadRO | ReadCommitted | Isolation.ReadCommittedRO;\n  export type SerializableRODeferrable = SerializableRO | Isolation.SerializableRODeferrable;\n}\n\nexport interface TxnClient<_T extends Isolation> extends pg.PoolClient { }  // eslint-disable-line @typescript-eslint/no-unused-vars\n\nlet txnSeq = 0;\n\n/**\n * Provide a database client to the callback, whose queries are then wrapped in a \n * database transaction. The transaction is committed, retried, or rolled back as \n * appropriate. \n * @param pool The `pg.Pool` from which to check out the database client\n * @param isolationMode The `Isolation` mode (e.g `Serializable`) \n * @param callback The callback function that runs queries on the provided client\n */\nexport async function transaction<T, M extends Isolation>(\n  pool: pg.Pool,\n  isolationMode: M,\n  callback: (client: TxnClient<M>) => Promise<T>\n): Promise<T> {\n\n  const\n    txnId = txnSeq++,\n    txnClient = await pool.connect() as TxnClient<typeof isolationMode>,\n    config = getConfig(),\n    { transactionListener } = config,\n    maxAttempts = config.transactionAttemptsMax,\n    { minMs, maxMs } = config.transactionRetryDelay;\n\n  try {\n    for (let attempt = 1; ; attempt++) {\n      try {\n        if (attempt > 1 && transactionListener) transactionListener(`Retrying transaction #${txnId}, attempt ${attempt} of ${maxAttempts}`);\n\n        await sql`START TRANSACTION ISOLATION LEVEL ${raw(isolationMode)}`.run(txnClient);\n        const result = await callback(txnClient);\n        await sql`COMMIT`.run(txnClient);\n\n        return result;\n\n      } catch (err) {\n        await sql`ROLLBACK`.run(txnClient);\n\n        // on trapping the following two rollback error codes, see:\n        // https://www.postgresql.org/message-id/1368066680.60649.YahooMailNeo@web162902.mail.bf1.yahoo.com\n        // this is also a good read:\n        // https://www.enterprisedb.com/blog/serializable-postgresql-11-and-beyond\n\n        if (isDatabaseError(err, \"TransactionRollback_SerializationFailure\", \"TransactionRollback_DeadlockDetected\")) {\n          if (attempt < maxAttempts) {\n            const delayBeforeRetry = Math.round(minMs + (maxMs - minMs) * Math.random());\n            if (transactionListener) transactionListener(`Transaction #${txnId} rollback (code ${err.code}) on attempt ${attempt} of ${maxAttempts}, retrying in ${delayBeforeRetry}ms`);\n            await wait(delayBeforeRetry);\n\n          } else {\n            if (transactionListener) transactionListener(`Transaction #${txnId} rollback (code ${err.code}) on attempt ${attempt} of ${maxAttempts}, giving up`);\n            throw err;\n          }\n\n        } else {\n          throw err;\n        }\n      }\n    }\n\n  } finally {\n    txnClient.release();\n  }\n}\n\n/**\n * Shortcut for `transaction` with isolation mode Serializable.\n * @param pool The `pg.Pool` from which to check out the database client\n * @param callback The callback function that runs queries on the provided client\n */\nexport async function serializable<T>(pool: pg.Pool, callback: (client: TxnClient<Isolation.Serializable>) => Promise<T>) {\n  return transaction(pool, Isolation.Serializable, callback);\n}\n/**\n * Shortcut for `transaction` with isolation mode RepeatableRead.\n * @param pool The `pg.Pool` from which to check out the database client\n * @param callback The callback function that runs queries on the provided client\n */\nexport async function repeatableRead<T>(pool: pg.Pool, callback: (client: TxnClient<Isolation.RepeatableRead>) => Promise<T>) {\n  return transaction(pool, Isolation.RepeatableRead, callback);\n}\n/**\n * Shortcut for `transaction` with isolation mode ReadCommitted.\n * @param pool The `pg.Pool` from which to check out the database client\n * @param callback The callback function that runs queries on the provided client\n */\nexport async function readCommitted<T>(pool: pg.Pool, callback: (client: TxnClient<Isolation.ReadCommitted>) => Promise<T>) {\n  return transaction(pool, Isolation.ReadCommitted, callback);\n}\n/**\n * Shortcut for `transaction` with isolation mode SerializableRO.\n * @param pool The `pg.Pool` from which to check out the database client\n * @param callback The callback function that runs queries on the provided client\n */\nexport async function serializableRO<T>(pool: pg.Pool, callback: (client: TxnClient<Isolation.SerializableRO>) => Promise<T>) {\n  return transaction(pool, Isolation.SerializableRO, callback);\n}\n/**\n * Shortcut for `transaction` with isolation mode RepeatableReadRO.\n * @param pool The `pg.Pool` from which to check out the database client\n * @param callback The callback function that runs queries on the provided client\n */\nexport async function repeatableReadRO<T>(pool: pg.Pool, callback: (client: TxnClient<Isolation.RepeatableReadRO>) => Promise<T>) {\n  return transaction(pool, Isolation.RepeatableReadRO, callback);\n}\n/**\n * Shortcut for `transaction` with isolation mode ReadCommittedRO.\n * @param pool The `pg.Pool` from which to check out the database client\n * @param callback The callback function that runs queries on the provided client\n */\nexport async function readCommittedRO<T>(pool: pg.Pool, callback: (client: TxnClient<Isolation.ReadCommittedRO>) => Promise<T>) {\n  return transaction(pool, Isolation.ReadCommittedRO, callback);\n}\n/**\n * Shortcut for `transaction` with isolation mode SerializableRODeferrable.\n * @param pool The `pg.Pool` from which to check out the database client\n * @param callback The callback function that runs queries on the provided client\n */\nexport async function serializableRODeferrable<T>(pool: pg.Pool, callback: (client: TxnClient<Isolation.SerializableRODeferrable>) => Promise<T>) {\n  return transaction(pool, Isolation.SerializableRODeferrable, callback);\n}\n","zapatos/src/utils.js":"/*\n** DON'T EDIT THIS FILE (unless you're working on Zapatos) **\nIt's part of Zapatos, and will be overwritten when the database schema is regenerated\n\nZapatos: https://jawj.github.io/zapatos/\nCopyright (C) 2020 George MacKerron\nReleased under the MIT licence: see LICENCE file\n*/\nimport { Default } from './core';\n/**\n * Simple promisification of setTimeout.\n * @param delayMs Time to wait, in milliseconds\n */\nexport const wait = (delayMs) => new Promise(resolve => setTimeout(resolve, delayMs));\n/**\n * Map an input array to an output array, interspersing a constant separator value\n * between the mapped values.\n * @param arr Input array\n * @param separator Separator value\n * @param cb Mapping function\n */\nexport const mapWithSeparator = (arr, separator, cb) => {\n    const result = [];\n    for (let i = 0, len = arr.length; i < len; i++) {\n        if (i > 0)\n            result.push(separator);\n        result.push(cb(arr[i], i, arr));\n    }\n    return result;\n};\n/**\n * Map an array of objects to an output array by taking the union of all objects' keys\n * and ensuring that any key not present on any object gets the value Default.\n *\n * `e.g. [{ x: 1 }, { y: 2 }] => [{ x: 1, y: Default }, { x: Default, y: 2}]`\n * @param objs The array of objects\n */\nexport const completeKeysWithDefault = (objs) => {\n    const unionKeys = Object.assign({}, ...objs);\n    for (const k in unionKeys)\n        unionKeys[k] = Default;\n    return objs.map(o => (Object.assign(Object.assign({}, unionKeys), o)));\n};\n/**\n * Test that a value is a Plain Old JavaScript Object (such as one created by an object\n * literal, e.g. `{x: 1, y: 2}`)\n * @param x The value to test\n */\nexport const isPOJO = (x) => typeof x === 'object' &&\n    x !== null &&\n    x.constructor === Object &&\n    x.toString() === '[object Object]';\n","zapatos/src/utils.ts":"/*\n** DON'T EDIT THIS FILE (unless you're working on Zapatos) **\nIt's part of Zapatos, and will be overwritten when the database schema is regenerated\n\nZapatos: https://jawj.github.io/zapatos/\nCopyright (C) 2020 George MacKerron\nReleased under the MIT licence: see LICENCE file\n*/\n\nimport { Default } from './core';\n\nexport type NoInfer<T> = [T][T extends any ? 0 : never];  // https://github.com/Microsoft/TypeScript/issues/14829\n\n/**\n * Simple promisification of setTimeout.\n * @param delayMs Time to wait, in milliseconds\n */\nexport const wait = (delayMs: number) => new Promise(resolve => setTimeout(resolve, delayMs));\n\n/**\n * Map an input array to an output array, interspersing a constant separator value \n * between the mapped values.\n * @param arr Input array\n * @param separator Separator value\n * @param cb Mapping function\n */\nexport const mapWithSeparator = <TIn, TSep, TOut>(\n  arr: TIn[],\n  separator: TSep,\n  cb: (x: TIn, i: number, a: typeof arr) => TOut\n): (TOut | TSep)[] => {\n\n  const result: (TOut | TSep)[] = [];\n  for (let i = 0, len = arr.length; i < len; i++) {\n    if (i > 0) result.push(separator);\n    result.push(cb(arr[i], i, arr));\n  }\n  return result;\n};\n\n/**\n * Map an array of objects to an output array by taking the union of all objects' keys\n * and ensuring that any key not present on any object gets the value Default. \n * \n * `e.g. [{ x: 1 }, { y: 2 }] => [{ x: 1, y: Default }, { x: Default, y: 2}]`\n * @param objs The array of objects\n */\nexport const completeKeysWithDefault = <T extends object>(objs: T[]): T[] => {\n  const unionKeys = Object.assign({}, ...objs);\n  for (const k in unionKeys) unionKeys[k] = Default;\n  return objs.map(o => ({ ...unionKeys, ...o }));\n};\n\n/**\n * Test that a value is a Plain Old JavaScript Object (such as one created by an object \n * literal, e.g. `{x: 1, y: 2}`)\n * @param x The value to test \n */\nexport const isPOJO = (x: any) =>\n  typeof x === 'object' &&\n  x !== null &&\n  x.constructor === Object &&\n  x.toString() === '[object Object]';\n","pg.ts":"\n      export class Pool {}\n      export class PoolClient {}\n      export class QueryResult {\n        rows: any;\n      }","pgPool.ts":"\n      import * as pg from 'pg';\n      export default new pg.Pool();","zapatos/src.ts":"\n      export * from './src/index';"};